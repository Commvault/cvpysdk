<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cvpysdk.plan API documentation</title>
<meta name="description" content="Main file for performing plan operations â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em;background-color:#f8f9fa}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#FE496A;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#FD0131}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" type="image/x-icon" href="https://commvault.github.io/cvpysdk/favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cvpysdk.plan</code></h1>
</header>
<section id="section-intro">
<p>Main file for performing plan operations.</p>
<p>Plans and Plan are the classes defined in this file.</p>
<p>Plans: Class for representing all the plans in the commcell</p>
<p>Plan: Class for representing a single plan of the commcell</p>
<h1 id="plans">Plans</h1>
<pre><code>__init__(commcell_object)   --  initialise object of plans class of the commcell

__str__()                   --  returns all the plans associated with the commcell

__repr__()                  --  returns the string for the instance of the plans class

__len__()                   --  returns the number of plans added to the Commcell

__getitem__()               --  returns the name of the plan for the given plan Id
or the details for the given plan name

_get_plans()                --  gets all the plans associated with the commcell specified

_get_plan_template()        --  gets the Plan subtype's JSON template

add()                       --  adds a new Plan to the CommCell

has_plan()                  --  checks if a plan exists with the given name or not

get()                       --  returns the instance of the Plans class

delete()                    --  deletes the plan from the commcell

refresh()                   --  refresh the plans associated with the commcell
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>**all_plans**   --  returns the dict consisting of plans and their details
</code></pre>
<dl>
<dt><strong><code>Plan</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>====</p>
<pre><code>__init__()                  -- initialise instance of the plan for the commcell

__repr__()                  -- return the plan name, the instance is associated with

_get_plan_id()              -- method to get the plan id, if not specified in __init__

_get_plan_properties()      -- get the properties of this plan

_update_plan_props()        -- method to update plan properties

_get_associated_entities()  -- method to get list of entities associated to a plan

derive_and_add()            -- add new plan by deriving from the parent Plan object

plan_name                   --  returns the name of the plan

plan_id                     --  returns the ID of the plan

refresh()                   --  refresh the properties of the plan

associate_user()            --  associates users to the plan

modify_schedule()           --  modifies the RPO schedules of the plan

add_storage_copy()          --  adds a storage pool as a copy to the plan

disable_full_schedule()     --  disables the full schedule of a plan
</code></pre>
<h2 id="plan-attributes">Plan Attributes</h2>
<pre><code>**plan_id**                 --  returns the id of the plan

**plan_name**               --  returns the name of the plan

**sla_in_minutes**          --  returns the SLA/RPO of the plan

**plan_type**               --  returns the type of the plan

**subtype**                 --  returns the subtype of the plan

**override_entities**       --  returns the override restrictions of the plan

**storage_policy**          --  returns the storage policy of the plan

**schedule_policies**       --  returns the schedule policy of the plan

**subclient_policy**        --  returns the subclient policy of the plan

**associated_entities**     --  returns all the backup entities associated with the plan

**operation_window**        --  returns the incremental operation window set by the plan

**full_operation_window**   --  returns the full operation window set by the plan

**associated_entities**     --  returns all the entities associated with the plan
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1-L1681" class="git-link">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

# --------------------------------------------------------------------------
# Copyright Commvault Systems, Inc.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# --------------------------------------------------------------------------

&#34;&#34;&#34;Main file for performing plan operations.

Plans and Plan are the classes defined in this file.

Plans: Class for representing all the plans in the commcell

Plan: Class for representing a single plan of the commcell

Plans
=====

    __init__(commcell_object)   --  initialise object of plans class of the commcell

    __str__()                   --  returns all the plans associated with the commcell

    __repr__()                  --  returns the string for the instance of the plans class

    __len__()                   --  returns the number of plans added to the Commcell

    __getitem__()               --  returns the name of the plan for the given plan Id
    or the details for the given plan name

    _get_plans()                --  gets all the plans associated with the commcell specified

    _get_plan_template()        --  gets the Plan subtype&#39;s JSON template

    add()                       --  adds a new Plan to the CommCell

    has_plan()                  --  checks if a plan exists with the given name or not

    get()                       --  returns the instance of the Plans class

    delete()                    --  deletes the plan from the commcell

    refresh()                   --  refresh the plans associated with the commcell

Attributes
----------

    **all_plans**   --  returns the dict consisting of plans and their details


Plan
====

    __init__()                  -- initialise instance of the plan for the commcell

    __repr__()                  -- return the plan name, the instance is associated with

    _get_plan_id()              -- method to get the plan id, if not specified in __init__

    _get_plan_properties()      -- get the properties of this plan

    _update_plan_props()        -- method to update plan properties

    _get_associated_entities()  -- method to get list of entities associated to a plan

    derive_and_add()            -- add new plan by deriving from the parent Plan object

    plan_name                   --  returns the name of the plan

    plan_id                     --  returns the ID of the plan

    refresh()                   --  refresh the properties of the plan

    associate_user()            --  associates users to the plan

    modify_schedule()           --  modifies the RPO schedules of the plan

    add_storage_copy()          --  adds a storage pool as a copy to the plan

    disable_full_schedule()     --  disables the full schedule of a plan

Plan Attributes
----------------
    **plan_id**                 --  returns the id of the plan

    **plan_name**               --  returns the name of the plan

    **sla_in_minutes**          --  returns the SLA/RPO of the plan

    **plan_type**               --  returns the type of the plan

    **subtype**                 --  returns the subtype of the plan

    **override_entities**       --  returns the override restrictions of the plan

    **storage_policy**          --  returns the storage policy of the plan

    **schedule_policies**       --  returns the schedule policy of the plan

    **subclient_policy**        --  returns the subclient policy of the plan

    **associated_entities**     --  returns all the backup entities associated with the plan

    **operation_window**        --  returns the incremental operation window set by the plan

    **full_operation_window**   --  returns the full operation window set by the plan

    **associated_entities**     --  returns all the entities associated with the plan
&#34;&#34;&#34;

from __future__ import unicode_literals

from past.builtins import basestring

from .exception import SDKException


class Plans(object):
    &#34;&#34;&#34;Class for representing all the plans in the commcell.&#34;&#34;&#34;

    def __init__(self, commcell_object):
        &#34;&#34;&#34;Initialize object of Plans class.

            Args:
                commcell_object (object)  -- instance of the Commcell class

            Returns:
                object - instance of Plans class
        &#34;&#34;&#34;

        self._commcell_object = commcell_object

        self._cvpysdk_object = commcell_object._cvpysdk_object
        self._services = commcell_object._services
        self._update_response_ = commcell_object._update_response_

        self._PLANS = self._services[&#39;PLANS&#39;]
        self._plans = None
        self.refresh()

    def __str__(self):
        &#34;&#34;&#34;Representation string consisting of all plans of the Commcell.

            Returns:
                str - string of all the plans for a commcell
        &#34;&#34;&#34;
        representation_string = &#34;{:^5}\t{:^50}\n\n&#34;.format(&#39;S. No.&#39;, &#39;Plan&#39;)

        for index, plan in enumerate(self._plans):
            sub_str = &#39;{:^5}\t{:30}\n&#39;.format(index + 1, plan)
            representation_string += sub_str

        return representation_string.strip()

    def __repr__(self):
        &#34;&#34;&#34;Representation string for the instance of the Plans class.&#34;&#34;&#34;
        return &#34;Plans class instance for Commcell: &#39;{0}&#39;&#34;.format(
            self._commcell_object.commserv_name
        )

    def __len__(self):
        &#34;&#34;&#34;Returns the number of the plans added to the Commcell.&#34;&#34;&#34;
        return len(self.all_plans)

    def __getitem__(self, value):
        &#34;&#34;&#34;Returns the name of the plan for the given plan ID or
            the details of the plan for given plan Name.

            Args:
                value   (str / int)     --  Name or ID of the plan

            Returns:
                str     -   name of the plan, if the plan id was given

                dict    -   dict of details of the plan, if plan name was given

            Raises:
                IndexError:
                    no plan exists with the given Name / Id

        &#34;&#34;&#34;
        value = str(value)

        if value in self.all_plans:
            return self.all_plans[value]
        else:
            try:
                return list(filter(lambda x: x[1][&#39;id&#39;] == value, self.all_plans.items()))[0][0]
            except IndexError:
                raise IndexError(&#39;No plan exists with the given Name / Id&#39;)

    def _get_plans(self):
        &#34;&#34;&#34;Gets all the plans associated with the commcell

            Returns:
                dict - consists of all plans in the commcell
                    {
                        &#34;plan1_name&#34;: plan1_id,
                        &#34;plan2_name&#34;: plan2_id
                    }

                Raises:
                    SDKException:
                        if response is empty

                        if response is not success
        &#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, self._PLANS)

        if flag:
            plans = {}

            if response.json() and &#39;plans&#39; in response.json():
                response_value = response.json()[&#39;plans&#39;]

                for temp in response_value:
                    temp_name = temp[&#39;plan&#39;][&#39;planName&#39;].lower()
                    temp_id = str(temp[&#39;plan&#39;][&#39;planId&#39;]).lower()
                    plans[temp_name] = temp_id

            return plans
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_plan_template(self, plan_sub_type, plan_type=&#34;MSP&#34;):
        &#34;&#34;&#34;Gets the Plan subtype&#39;s JSON template.

            Args:
                plan_sub_type    (str)   --  Sub-type of plan to add

                    &#34;Server&#34;    -   Server Plans

                    &#34;FSServer&#34;  -   File System Plans

                    &#34;Laptop&#34;    -   Laptop Plans


                plan_type       (str)   --  Type of plan to add

                    default: &#34;MSP&#34;

            Returns:
                str     -   JSON string of the Plan&#39;s template

            Raises:
                SDKException:
                    if type or subtype of the plan does not exist

                    if there is a failure in getting the template

        &#34;&#34;&#34;
        if not (isinstance(plan_sub_type, basestring) and
                isinstance(plan_type, basestring)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            template_url = self._services[&#39;GET_PLAN_TEMPLATE&#39;] % (plan_type, plan_sub_type)

            flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, template_url)

            if flag:
                if response.json() and &#39;plan&#39; in response.json():
                    return response.json()
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Failed to get Plan template&#39;)
            else:
                response_string = self._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def all_plans(self):
        &#34;&#34;&#34;Returns the dictionary consisting of all the plans added to the Commcell.

            dict - consists of all the plans configured on the commcell

                {
                    &#34;plan1_name&#34;: plan1_id,

                    &#34;plan2_name&#34;: plan2_id
                }

        &#34;&#34;&#34;
        return self._plans

    def has_plan(self, plan_name):
        &#34;&#34;&#34;Checks if a plan exists in the commcell with the input plan name.

            Args:
                plan_name   (str)   --  name of the plan

            Returns:
                bool    -   boolean output whether the plan exists in the commcell or not

            Raises:
                SDKException:
                    if type of the plan name argument is not string

        &#34;&#34;&#34;
        if not isinstance(plan_name, basestring):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)

        return self._plans and plan_name.lower() in self._plans

    def get(self, plan_name):
        &#34;&#34;&#34;Returns a plan object of the specified plan name.

            Args:
                plan_name (str)  --  name of the plan

            Returns:
                object - instance of the Plan class for the the given plan name

            Raises:
                SDKException:
                    if type of the plan name argument is not string

                    if no plan exists with the given name
        &#34;&#34;&#34;
        if not isinstance(plan_name, basestring):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            plan_name = plan_name.lower()

            if self.has_plan(plan_name):
                return Plan(
                    self._commcell_object,
                    plan_name,
                    self._plans[plan_name]
                )

            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                    plan_name)
            )

    def delete(self, plan_name):
        &#34;&#34;&#34;Deletes the plan from the commcell.

            Args:
                plan_name (str)  --  name of the plan to remove from the commcell

            Raises:
                SDKException:
                    if type of the plan name argument is not string

                    if failed to delete plan

                    if response is empty

                    if response is not success

                    if no plan exists with the given name
        &#34;&#34;&#34;
        if not isinstance(plan_name, basestring):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            plan_name = plan_name.lower()

            if self.has_plan(plan_name):
                plan_id = self._plans[plan_name]

                delete_plan = self._services[&#39;DELETE_PLAN&#39;] % (plan_id)

                flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, delete_plan)

                error_code = 0

                if flag:
                    if &#39;error&#39; in response.json():
                        if isinstance(response.json()[&#39;error&#39;], list):
                            error_code = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                        else:
                            error_code = response.json()[&#39;errorCode&#39;]

                    if error_code != 0:
                        o_str = &#39;Failed to delete plan&#39;
                        if isinstance(response.json()[&#39;error&#39;], list):
                            error_message = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]
                        else:
                            error_message = response.json()[&#39;errorMessage&#39;]
                        o_str += &#39;\nError: &#34;{0}&#34;&#39;.format(error_message)
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
                    else:
                        # initialize the plan again
                        # so the plan object has all the plan
                        self.refresh()
                else:
                    response_string = self._update_response_(response.text)
                    raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
            else:
                raise SDKException(
                    &#39;Plan&#39;,
                    &#39;102&#39;,
                    &#39;No plan exists with name: {0}&#39;.format(plan_name)
                )

    def add(self,
            plan_name,
            plan_sub_type,
            storage_pool_name=None,
            sla_in_minutes=1440,
            override_entities=None):
        &#34;&#34;&#34;Adds a new Plan to the CommCell.

        Args:
            plan_name           (str)   --  name of the new plan to add

            plan_sub_type       (str)   --  Type of plan to add

                &#34;Server&#34;    -   Server Plans

                &#34;FSServer&#34;  -   File System Plans

                &#34;Laptop&#34;    -   Laptop Plans

                &#34;ExchangeUser&#34;  -   Exchange Mailbox Plan


            storage_pool_name   (str)   --  name of the storage pool to be used for the plan

            sla_in_minutes      (int)   --  Backup SLA in hours

                default: 1440

            override_entities   (dict)  --  Specify the entities with respective
                                            inheritance values.

                default: None

                    {
                        &#39;privateEntities&#39;: [1, 4],

                        &#39;enforcedEntities&#39;: [256, 512, 1024]
                    }
                    - where,
                            privateEntities are set when respective entity overriding is required
                            enforcedEntities are set when respective entity overriding is not
                            allowed
                            left blank if overriding is optional

                    - entity IDs,
                            1    - Storage
                            4    - RPO/Schedules
                            256  - Windows content
                            512  - Unix content
                            1024 - Mac content

        Returns:
            object  -   instance of the Plan class created by this method

        Raises:
            SDKException:
                if input parameters are incorrect

                if Plan already exists

        &#34;&#34;&#34;
        if not (isinstance(plan_name, basestring) and
                isinstance(plan_sub_type, basestring)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            if self.has_plan(plan_name):
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(plan_name)
                )
        if not plan_sub_type == &#39;ExchangeUser&#39;:
            storage_pool_obj = self._commcell_object.storage_pools.get(
                storage_pool_name)
            is_dedupe = True
            if &#39;dedupDBDetailsList&#39; \
                    not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
                is_dedupe = False

        request_json = self._get_plan_template(plan_sub_type, &#34;MSP&#34;)

        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;rpoInMinutes&#39;] = sla_in_minutes
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
        request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][1][&#39;options&#39;][&#39;commonOpts&#39;][
            &#39;automaticSchedulePattern&#39;].update({
                &#39;minBackupInterval&#39;: 0,
                &#39;maxBackupIntervalMinutes&#39;: 0,
                &#39;minSyncInterval&#39;: 0,
                &#39;minSyncIntervalMinutes&#39;: 0
            })
        request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][1][&#39;options&#39;][&#39;commonOpts&#39;][
            &#39;automaticSchedulePattern&#39;][&#39;ignoreOpWindowPastMaxInterval&#39;] = True
        del request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;]
        if not plan_sub_type == &#39;ExchangeUser&#39;:
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
            }
            if is_dedupe:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;useGlobalDedupStore&#39;] = 1
            else:
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;enableDeduplication&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;enableClientSideDedup&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                    &#39;useGlobalStoragePolicy&#39;: 1
                }

        # Configurations for database and snap addons
        if plan_sub_type == &#34;Server&#34; and &#39;database&#39; in request_json[&#39;plan&#39;]:
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalDedupStore&#39;] = 1
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0].pop(
                &#39;DDBPartitionInfo&#39;, None
            )
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalPolicy&#39;] = {
                    &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
                }
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                &#39;useGlobalStoragePolicy&#39;: 1
            }
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
            }

        # Enable full backup schedule
        for subtask in request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;]:
            if &#39;flags&#39; in subtask[&#39;subTask&#39;] and subtask[&#39;subTask&#39;][&#39;flags&#39;] == 65536:
                import copy
                full_schedule = copy.deepcopy(subtask)
                del copy
                full_schedule[&#39;subTask&#39;].update({
                    &#39;subTaskName&#39;: &#39;Full backup schedule&#39;,
                    &#39;flags&#39;: 4194304
                })
                full_schedule[&#39;pattern&#39;].update({
                    &#39;freq_type&#39;: 4,
                    &#39;freq_interval&#39;: 1,
                    &#39;name&#39;: &#39;Full backup schedule&#39;,
                    &#39;active_end_time&#39;: 0
                })
                full_schedule[&#39;options&#39;][&#39;backupOpts&#39;][&#39;backupLevel&#39;] = &#39;FULL&#39;
                request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;].append(full_schedule)
                break

        if isinstance(override_entities, dict):
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: False
            }

            if &#39;enforcedEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = override_entities[
                    &#39;enforcedEntities&#39;]

            if &#39;privateEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = override_entities[
                    &#39;privateEntities&#39;]
        else:
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: True
            }

        headers = self._commcell_object._headers.copy()
        headers[&#39;LookupNames&#39;] = &#39;False&#39;

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._PLANS, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = None

                if &#39;errors&#39; in response_value:
                    error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                if error_code &gt; 1:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                    # initialize the plans again
                    # so that the plans object has all the plans
                    self.refresh()
                    # with plan delete storage policy associated might be deleted
                    # initialize storage policy again
                    self._commcell_object.storage_policies.refresh()

                    return self.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def get_eligible_plans(self, entities):
        &#34;&#34;&#34;Returns dict of plans that are eligible for the specified entities

            Args:
                entities    (dict)  - dictionary containing entities as keys and
                                        their respective IDs as values
                    {
                        &#39;clientId&#39;: id,
                        &#39;appId&#39;: id,
                        &#39;backupsetId&#39;: id
                    }

            Returns:
                dict                - dict of eligible plans

            Raises:
                SDKException:
                    if there is an error in the response
        &#34;&#34;&#34;
        query = &#39;&#39;
        for i in entities:
            query += &#39;{0}={1}&amp;&#39;.format(i, entities[i])
        requset_url = self._services[&#39;ELIGIBLE_PLANS&#39;] % query[0:-1]
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, requset_url)
        del query

        if flag:
            plans = {}

            if response.json() and &#39;plans&#39; in response.json():
                response_value = response.json()[&#39;plans&#39;]

                for temp in response_value:
                    temp_name = temp[&#39;plan&#39;][&#39;planName&#39;].lower()
                    temp_id = str(temp[&#39;plan&#39;][&#39;planId&#39;]).lower()
                    plans[temp_name] = temp_id

            return plans
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def refresh(self):
        &#34;&#34;&#34;Refresh the plans associated with the Commcell.&#34;&#34;&#34;
        self._plans = self._get_plans()


class Plan(object):
    &#34;&#34;&#34;Class for performing operations for a specific Plan.&#34;&#34;&#34;

    def __init__(self, commcell_object, plan_name, plan_id=None):
        &#34;&#34;&#34;Initialize the Plan class instance.

            Args:
                commcell_object     (object)  --  instance of the Commcell class

                plan_name           (str)     --  name of the plan

                plan_id             (str)     --  id of the plan
                    default: None

            Returns:
                object - instance of the Plan class

        &#34;&#34;&#34;
        self._commcell_object = commcell_object

        self._cvpysdk_object = commcell_object._cvpysdk_object
        self._services = commcell_object._services
        self._update_response_ = commcell_object._update_response_

        self._plan_name = plan_name.lower()
        self._plan_properties = None

        if plan_id:
            self._plan_id = str(plan_id)
        else:
            self._plan_id = self._get_plan_id()

        self._PLAN = self._services[&#39;PLAN&#39;] % (self.plan_id)
        self._ADD_USERS_TO_PLAN = self._services[&#39;ADD_USERS_TO_PLAN&#39;] % (self.plan_id)

        self._properties = None
        self._sla_in_minutes = None
        self._operation_window = None
        self._full_operation_window = None
        self._plan_type = None
        self._subtype = None
        self._security_associations = {}
        self._storage_pool = None
        self._child_policies = {
            &#39;storagePolicy&#39;: None,
            &#39;schedulePolicy&#39;: {},
            &#39;subclientPolicyIds&#39;: []
        }
        self._storage_copies = {}
        self._user_group = None
        self._client_group = None
        self._override_entities = None
        self._parent_plan_name = None
        self._addons = []
        self._associated_entities = {}
        self.refresh()

    def __repr__(self):
        &#34;&#34;&#34;String representation of the instance of this class.&#34;&#34;&#34;
        representation_string = &#39;Plan class instance for plan: &#34;{0}&#34;, of Commcell: &#34;{1}&#34;&#39;

        return representation_string.format(
            self._plan_name, self._commcell_object.commserv_name
        )

    def _get_plan_id(self):
        &#34;&#34;&#34;Gets the plan id associated with this plan.

            Returns:
                str - id associated with this plan
        &#34;&#34;&#34;
        plans = Plans(self._commcell_object)
        return plans.get(self.plan_name).plan_id

    def _get_plan_properties(self):
        &#34;&#34;&#34;Gets the plan properties of this plan.

            Returns:
                dict - dictionary consisting of the properties of this plan

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        plan_properties_url = &#39;{0}?propertyLevel=20&#39;.format(self._PLAN)
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, plan_properties_url)

        if flag:
            if response.json() and &#39;plan&#39; in response.json():
                self._plan_properties = response.json()[&#39;plan&#39;]

                if &#39;planName&#39; in self._plan_properties[&#39;summary&#39;][&#39;plan&#39;]:
                    self._plan_name = self._plan_properties[&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                if &#39;slaInMinutes&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._sla_in_minutes = self._plan_properties[&#39;summary&#39;][&#39;slaInMinutes&#39;]

                if &#39;type&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._plan_type = self._plan_properties[&#39;summary&#39;][&#39;type&#39;]

                if &#39;subtype&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._subtype = self._plan_properties[&#39;summary&#39;][&#39;subtype&#39;]

                if &#39;storage&#39; in self._plan_properties:
                    if &#39;copy&#39; in self._plan_properties[&#39;storage&#39;]:
                        for copy in self._plan_properties[&#39;storage&#39;][&#39;copy&#39;]:
                            self._storage_copies[copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]] = {
                                &#39;storagePool&#39;: copy[&#39;useGlobalPolicy&#39;][&#39;storagePolicyName&#39;].lower(),
                                &#39;retainBackupDataForDays&#39;: copy[
                                    &#39;retentionRules&#39;][&#39;retainBackupDataForDays&#39;],
                                &#39;isDefault&#39;: False,
                                &#39;isSnapCopy&#39;: False,
                            }
                            if &#39;extendedRetentionRuleOne&#39; in copy[&#39;retentionRules&#39;]:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;extendedRetention&#39;] = (
                                        1,
                                        True,
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;rule&#39;],
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;endDays&#39;],
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;graceDays&#39;]
                                    ) 
                            if copy[&#39;isDefault&#39;] == 1:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;isDefault&#39;] = True

                            if copy[&#39;isSnapCopy&#39;] == 1:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;isSnapCopy&#39;] = True

                    if &#39;storagePolicy&#39; in self._plan_properties[&#39;storage&#39;]:
                        self._commcell_object.storage_policies.refresh()
                        self._child_policies[&#39;storagePolicy&#39;] = self._commcell_object.storage_policies.get(
                            self._plan_properties[&#39;storage&#39;][&#39;storagePolicy&#39;][&#39;storagePolicyName&#39;]
                        )

                if self._subtype == 33554439:
                    if &#39;clientGroup&#39; in self._plan_properties[&#39;autoCreatedEntities&#39;]:
                        self._commcell_object.client_groups.refresh()
                        self._client_group = self._commcell_object.client_groups.get(
                            self._plan_properties[&#39;autoCreatedEntities&#39;][&#39;clientGroup&#39;][
                                &#39;clientGroupName&#39;]
                        )

                    if &#39;localUserGroup&#39; in self._plan_properties[&#39;autoCreatedEntities&#39;]:
                        self._user_group = self._plan_properties[&#39;autoCreatedEntities&#39;][
                            &#39;localUserGroup&#39;][&#39;userGroupName&#39;]

                if &#39;schedule&#39; in self._plan_properties:
                    if &#39;task&#39; in self._plan_properties[&#39;schedule&#39;]:
                        self._commcell_object.schedule_policies.refresh()
                        self._child_policies[&#39;schedulePolicy&#39;] = {
                            &#39;data&#39;: self._commcell_object.policies.schedule_policies.get(
                                self._plan_properties[&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;]
                            )
                        }
                        if self._subtype == 33554437:
                            self._child_policies[&#39;schedulePolicy&#39;].update({
                                &#39;log&#39;: self._commcell_object.policies.schedule_policies.get(
                                    self._plan_properties[
                                        &#39;database&#39;][&#39;scheduleLog&#39;][&#39;task&#39;][&#39;taskName&#39;]
                                )
                            })

                if self._plan_properties[&#39;operationWindow&#39;][&#39;ruleId&#39;] != 0:
                    self._operation_window = self._plan_properties[&#39;operationWindow&#39;]
                else:
                    self._operation_window = None

                if self._plan_properties[&#39;fullOperationWindow&#39;][&#39;ruleId&#39;] != 0:
                    self._full_operation_window = self._plan_properties[&#39;fullOperationWindow&#39;]
                else:
                    self._full_operation_window = None

                if &#39;laptop&#39; in self._plan_properties:
                    if &#39;backupContent&#39; in self._plan_properties[&#39;laptop&#39;][&#39;content&#39;]:
                        self._child_policies[&#39;subclientPolicyIds&#39;].clear()
                        for ida in self._plan_properties[&#39;laptop&#39;][&#39;content&#39;][&#39;backupContent&#39;]:
                            self._child_policies[&#39;subclientPolicyIds&#39;].append(
                                ida[&#39;subClientPolicy&#39;][&#39;backupSetEntity&#39;][&#39;backupsetId&#39;]
                            )

                if (&#39;inheritance&#39; in self._plan_properties and
                        not self._plan_properties[&#39;inheritance&#39;][&#39;isSealed&#39;]):
                    temp_dict = self._plan_properties[&#39;inheritance&#39;]
                    del temp_dict[&#39;isSealed&#39;]
                    if &#39;enforcedEntities&#39; not in temp_dict:
                        temp_dict[&#39;enforcedEntities&#39;] = []
                    if &#39;privateEntities&#39; not in temp_dict:
                        temp_dict[&#39;privateEntities&#39;] = []
                    self._override_entities = temp_dict

                if &#39;parent&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._parent_plan_name = self._plan_properties[&#39;summary&#39;][&#39;parent&#39;][&#39;planName&#39;]

                if &#39;securityAssociations&#39; in self._plan_properties:
                    for association in self._plan_properties[&#39;securityAssociations&#39;][&#39;associations&#39;]:
                        temp_key = None
                        if &#39;externalGroupName&#39; in association[&#39;userOrGroup&#39;][0]:
                            temp_key = &#39;{0}\\{1}&#39;.format(
                                    association[&#39;userOrGroup&#39;][0][&#39;providerDomainName&#39;],
                                    association[&#39;userOrGroup&#39;][0][&#39;externalGroupName&#39;]
                                )
                        elif &#39;userGroupName&#39; in association[&#39;userOrGroup&#39;][0]:
                            temp_key = association[&#39;userOrGroup&#39;][0][&#39;userGroupName&#39;]
                        else:
                            temp_key = association[&#39;userOrGroup&#39;][0][&#39;userName&#39;]
                        if &#39;role&#39; in association[&#39;properties&#39;]:
                            if temp_key in self._security_associations:
                                self._security_associations[temp_key].append(
                                    association[&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;]
                                )
                            else:
                                self._security_associations[temp_key] = [association[&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;]]

                self._get_associated_entities()

                return self._plan_properties
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def derive_and_add(self,
                       plan_name,
                       storage_pool_name=None,
                       sla_in_minutes=None,
                       override_entities=None):
        &#34;&#34;&#34;Derives the base plan based on the the inheritance properties to created a derived plan

            Args:
                plan_name           (str)        --  name of the new plan to add

                storage_pool_name   (str)   --  name of the storage pool to be used for the plan
                    default: None   :   when the name is left to default, it inherits the base plan
                                        storage pool if overriding is optional/not allowed

                sla_in_minutes        (int)        --  Backup SLA in hours
                    default: None   :   when the SLA is left to default, it inherits the base plan
                                        SLA if overriding is optional/not allowed

                override_entities   (dict)  --  Specify the entities with respective overriding.

                    default: None

                        {
                            &#39;privateEntities&#39;: [1, 4],

                            &#39;enforcedEntities&#39;: [256, 512, 1024]
                        }
                        - where,
                                privateEntities are set when respective entity overriding is must
                                enforcedEntities are set when respective entity overriding is
                                not allowed
                                left blank if overriding is optional

                        - entity IDs,
                                1    - Storage
                                4    - SLA/Schedules
                                256  - Windows content
                                512  - Unix content
                                1024 - Mac content


        Returns:
            object - instance of the Plan class created by this method

        Raises:
            SDKException:
                if plan name is in incorrect format

                if plan already exists

                if neccessary arguments are not passed

                if inheritance rules are not followed

        &#34;&#34;&#34;
        if not isinstance(plan_name, basestring):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;, &#39;Plan name must be string value&#39;)
        else:
            if self._commcell_object.plans.has_plan(plan_name):
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(
                        plan_name)
                )
        if self._override_entities is not None:
            request_json = self._commcell_object.plans._get_plan_template(
                str(self._subtype), &#34;MSP&#34;)

            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;parent&#39;] = {
                &#39;planId&#39;: int(self._plan_id)
            }

            is_dedupe = True
            if storage_pool_name is not None:
                storage_pool_obj = self._commcell_object.storage_pools.get(
                    storage_pool_name
                )
                if &#39;dedupDBDetailsList&#39; \
                        not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
                    is_dedupe = False
                storage_pool_id = int(storage_pool_obj.storage_pool_id)
                if is_dedupe:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;useGlobalDedupStore&#39;] = 1
                else:
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;enableDeduplication&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;enableClientSideDedup&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                        &#39;useGlobalStoragePolicy&#39;: 1
                    }
            else:
                storage_pool_id = None

            if 1 in self._override_entities[&#39;enforcedEntities&#39;]:
                if storage_pool_id is None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                        &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                    }
                    snap_copy_id = self.storage_policy.storage_policy_id
                else:
                    raise SDKException(
                        &#39;Plan&#39;, &#39;102&#39;, &#39;Storage is enforced by base plan, cannot be overridden&#39;)
            elif 1 in self._override_entities[&#39;privateEntities&#39;]:
                if storage_pool_id is not None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                        &#34;storagePolicyId&#34;: storage_pool_id
                    }
                    snap_copy_id = storage_pool_id
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Storage must be input&#39;)
            else:
                if storage_pool_id is not None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                        &#34;storagePolicyId&#34;: storage_pool_id
                    }
                    snap_copy_id = storage_pool_id
                else:
                    request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                        &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                    }
                    snap_copy_id = self.storage_policy.storage_policy_id

            if 4 in self._override_entities[&#39;enforcedEntities&#39;]:
                if sla_in_minutes is None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes
                else:
                    raise SDKException(
                        &#39;Plan&#39;, &#39;102&#39;, &#39;SLA is enforced by base plan, cannot be overridden&#39;)
            elif 4 in self._override_entities[&#39;privateEntities&#39;]:
                if sla_in_minutes is not None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;SLA must be input&#39;)
            else:
                if sla_in_minutes is not None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
                else:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes

            if isinstance(override_entities, dict):
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
                request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                    &#39;isSealed&#39;: False
                }
                for entity in self._override_entities[&#39;enforcedEntities&#39;]:
                    from functools import reduce
                    if override_entities and entity in reduce(
                            lambda i, j: i + j, override_entities.values()):
                        raise SDKException(
                            &#39;Plan&#39;, &#39;102&#39;, &#39;Override not allowed&#39;)
                if &#39;enforcedEntities&#39; in override_entities:
                    request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = (
                        override_entities[&#39;enforcedEntities&#39;]
                    )
                if &#39;privateEntities&#39; in override_entities:
                    request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = (
                        override_entities[&#39;privateEntities&#39;]
                    )
            else:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
                request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                    &#39;isSealed&#39;: True
                }

            if sla_in_minutes is not None:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                    &#39;definesEntity&#39;: True
                }
            else:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                    &#39;definesEntity&#39;: False
                }

            if isinstance(self._override_entities, dict):
                if (4 not in
                        self._override_entities[&#39;enforcedEntities&#39;] +
                        self._override_entities[&#39;privateEntities&#39;]):
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 0
                elif 4 in self._override_entities[&#39;enforcedEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 2
                elif 4 in self._override_entities[&#39;privateEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 1

            if storage_pool_id is not None:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                    &#39;definesEntity&#39;: True
                }
            else:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                    &#39;definesEntity&#39;: False
                }

            if isinstance(self._override_entities, dict):
                if (1 not in
                        self._override_entities[&#39;enforcedEntities&#39;] +
                        self._override_entities[&#39;privateEntities&#39;]):
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 0
                elif 1 in self._override_entities[&#39;enforcedEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 2
                elif 1 in self._override_entities[&#39;privateEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 1

            if self._subtype != 33554437:
                temp_defines_key = {
                    &#39;definesEntity&#39;: False
                }
                if isinstance(self._override_entities, dict):
                    if (not all(entity in
                                self._override_entities[&#39;enforcedEntities&#39;] +
                                self._override_entities[&#39;privateEntities&#39;]
                                for entity in [256, 512, 1024])):
                        temp_defines_key[&#39;overrideEntity&#39;] = 0
                    elif all(entity in self._override_entities[&#39;enforcedEntities&#39;]
                             for entity in [256, 512, 1024]):
                        temp_defines_key[&#39;overrideEntity&#39;] = 2
                    elif all(entity in self._override_entities[&#39;privateEntities&#39;]
                             for entity in [256, 512, 1024]):
                        temp_defines_key[&#39;overrideEntity&#39;] = 1
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientLin&#39;] = temp_defines_key
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientMac&#39;] = temp_defines_key
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientWin&#39;] = temp_defines_key

            if self._subtype == 33554437 and &#39;snap&#39; in self.addons and &#39;copy&#39; \
                    in request_json[&#39;plan&#39;][&#39;storage&#39;]:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                    &#39;storagePolicyId&#39;: snap_copy_id
                }
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                    &#39;useGlobalStoragePolicy&#39;: 1
                }

            add_plan_service = self._commcell_object.plans._PLANS
            headers = self._commcell_object._headers.copy()
            headers[&#39;LookupNames&#39;] = &#39;False&#39;

            flag, response = self._cvpysdk_object.make_request(
                &#39;POST&#39;, add_plan_service, request_json, headers=headers
            )

            if flag:
                if response.json():
                    response_value = response.json()
                    error_message = None
                    error_code = None

                    if &#39;errors&#39; in response_value:
                        error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                        error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                    # error_codes 0 - OK, 1 - plan without storage, 84 - restricted plan
                    if error_code not in [0, 1, 84]:
                        o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                            error_message
                        )
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                    if &#39;plan&#39; in response_value:
                        plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                        # initialize the plans again
                        # so that the plans object has all the plans
                        self._commcell_object.plans.refresh()

                        return self._commcell_object.plans.get(plan_name)
                    else:
                        o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                                 &#39;Please check the documentation for &#39;
                                 &#39;more details on the error&#39;).format(error_code)

                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
                else:
                    raise SDKException(&#39;Response&#39;, 102)
            else:
                response_string = self._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        else:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Inheritance disabled for plan&#39;)

    def modify_schedule(self, schedule_json, is_full_schedule=False):
        &#34;&#34;&#34;Modifies the incremental RPO schedule pattern of the plan with the given schedule json

            Args:
            schedule_json (dict) -- {
                    pattern : {}, -- Please refer SchedulePattern.create_schedule in schedules.py for the types of
                                     pattern to be sent

                                     eg: {
                                            &#34;freq_type&#34;: &#39;daily&#39;,
                                            &#34;active_start_time&#34;: time_in_%H/%S (str),
                                            &#34;repeat_days&#34;: days_to_repeat (int)
                                         }

                    options: {} -- Please refer ScheduleOptions.py classes for respective schedule options

                                    eg:  {
                                        &#34;maxNumberOfStreams&#34;: 0,
                                        &#34;useMaximumStreams&#34;: True,
                                        &#34;useScallableResourceManagement&#34;: True,
                                        &#34;totalJobsToProcess&#34;: 1000,
                                        &#34;allCopies&#34;: True,
                                        &#34;mediaAgent&#34;: {
                                            &#34;mediaAgentName&#34;: &#34;&lt;ANY MEDIAAGENT&gt;&#34;
                                        }
                                    }
                    }
            is_full_schedule (bool) --  Pass True if he schedule to be modified is the full backup schedule
        &#34;&#34;&#34;
        if is_full_schedule:
            try:
                schedule_id = list(filter(
                    lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
                ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
            except IndexError:
                raise IndexError(&#39;Full backup schedule not enabled&#39;)
        else:
            schedule_id = list(filter(
                lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 65536, self.schedule_policies[&#39;data&#39;]._subtasks
            ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
        self.schedule_policies[&#39;data&#39;].modify_schedule(
            schedule_json,
            schedule_id=schedule_id
        )
        self.refresh()

    def add_storage_copy(self, copy_name, storage_pool, retention=30, extended_retention=None):
        &#34;&#34;&#34;Add a storage copy as backup destination to this plan
            Args:
                copy_name   (str)   -   name of the copy that is being added

                storage_pool (str)  -   name of the storage pool for the copy to be added

                retention   (int)   -   retention period in days for the copy

                extended_retention (tuple)  -   extended retention rules of a copy
                                                Example: [1, True, &#34;EXTENDED_ALLFULL&#34;, 0, 0]
            Returns:
                dict    -   dictionary of all copies of this plan
        &#34;&#34;&#34;
        if isinstance(copy_name, str) and isinstance(storage_pool, str):
            if not self.storage_policy.has_copy(copy_name):
                self.storage_policy.create_secondary_copy(
                    copy_name,
                    global_policy=storage_pool
                )
                self.storage_policy.get_copy(copy_name).copy_retention = (retention, 0, 0)
                if extended_retention:
                    self.storage_policy.get_copy(
                        copy_name).extended_retention_rules = extended_retention
                self.refresh()
                return self.storage_copies
            else:
                err_msg = f&#39;Storage Policy copy &#34;{copy_name}&#34; already exists.&#39;
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Copy name and storage pool name must be a string.&#39;
            )

    def disable_full_schedule(self):
        &#34;&#34;&#34;Disable the full backup schedule of the plan&#34;&#34;&#34;
        try:
            self.schedule_policies[&#39;data&#39;].delete_schedule(schedule_id=list(filter(
                lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
            ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;])
        except IndexError:
            raise IndexError(&#39;Full backup schedule not enabled&#39;)

    def edit_association(self, entities, new_plan=None):
        &#34;&#34;&#34;Reassociates or dissociates the entities from this plan
            Args:
                entities    (list)  --  list containing entity objects whose plan association must be edited
                                        Eg: [
                                            {
                                                &#34;clientName&#34;: &#34;client&#34;,
                                                &#34;subclientName&#34;: &#34;subclient&#34;,
                                                &#34;backupsetName&#34;: &#34;backupset&#34;,
                                                &#34;appName&#34;: &#34;app&#34;
                                            }
                                        ]

                new_plan    (str)   --  new plan to which the associated entities must be reassociated with

            Raises:
                SDKException
                    if plan not found
        &#34;&#34;&#34;
        req_json = {
            &#39;plan&#39;: {
                &#39;planName&#39;: self.plan_name
            },
            &#39;entities&#39;: entities
        }
        if new_plan is not None:
            if self._commcell_object.plans.has_plan(new_plan):
                req_json.update({
                    &#39;planOperationType&#39;: &#39;OVERWRITE&#39;,
                    &#39;newPlan&#39;: {
                        &#39;planName&#39;: new_plan
                    }
                })
            else:
                SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                    new_plan)
                )
        else:
            req_json.update({
                &#39;planOperationType&#39;: &#39;DELETE&#39;
            })
        req_url = self._services[&#39;ASSOCIATED_ENTITIES&#39;] % (self._plan_id)
        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, req_url, req_json
        )

        if flag:
            if &#39;response&#39; in response.json():
                error_code = str(response.json()[&#34;response&#34;][0][&#34;errorCode&#34;])

                if error_code == &#34;0&#34;:
                    self.refresh()
                    return
            else:
                error_message = str(response.json()[&#34;errorMessage&#34;])
                o_str = &#39;Failed to edit plan associated entities\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_message))
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _update_plan_props(self, props):
        &#34;&#34;&#34;Updates the properties of the plan

            Args:
                props   (dict)  --  dictionary containing the properties to be updated
                                    {
                                        &#39;planName&#39;: &#39;NewName&#39;
                                    }

            Raises:
                SDKException
                    if there is failure in updating the plan
        &#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, self._PLAN, props
        )
        if flag:
            if response.json():
                error_code = str(response.json()[&#34;errors&#34;][0][&#34;status&#34;][&#34;errorCode&#34;])
                error_message = str(response.json()[&#34;errors&#34;][0][&#34;status&#34;][&#34;errorMessage&#34;])

                if error_code == &#34;0&#34;:
                    self.refresh()
                    return (True, error_code)
                else:
                    return (False, error_code, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_associated_entities(self):
        &#34;&#34;&#34;Gets all the backup entities associated with the plan.

            Returns:
                dict - dictionary containing list of entities that are
                       associated with the plan.

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        request_url = self._services[&#39;ASSOCIATED_ENTITIES&#39;] % (self._plan_id)
        flag, response = self._cvpysdk_object.make_request(
            &#39;GET&#39;, request_url
        )

        if flag:
            if response.json() and &#39;entities&#39; in response.json():
                self._associated_entities = response.json()[&#39;entities&#39;]
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def plan_id(self):
        &#34;&#34;&#34;Treats the plan id as a read-only attribute.&#34;&#34;&#34;
        return self._plan_id

    @property
    def plan_name(self):
        &#34;&#34;&#34;Treats the plan name as a read-only attribute.&#34;&#34;&#34;
        return self._plan_name

    @plan_name.setter
    def plan_name(self, value):
        &#34;&#34;&#34;modifies the plan name&#34;&#34;&#34;
        if isinstance(value, basestring):
            req_json = {
                &#39;summary&#39;: {
                    &#39;plan&#39;: {
                        &#39;planName&#39;: value
                    }
                }
            }
            resp = self._update_plan_props(req_json)

            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan name\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan name must be a string value&#39;
            )

    @property
    def sla_in_minutes(self):
        &#34;&#34;&#34;Treats the plan SLA/RPO as a read-only attribute.&#34;&#34;&#34;
        return self._sla_in_minutes

    @sla_in_minutes.setter
    def sla_in_minutes(self, value):
        &#34;&#34;&#34;Modifies the plan SLA/RPO&#34;&#34;&#34;
        if isinstance(value, int):
            req_json = {
                &#39;summary&#39;: {
                    &#39;slaInMinutes&#39;: value
                }
            }
            resp = self._update_plan_props(req_json)

            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan SLA\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan SLA must be an int value&#39;
            )

    @property
    def operation_window(self):
        &#34;&#34;&#34;Treats the plan incremental operation window as a read-only attribute&#34;&#34;&#34;
        return self._operation_window

    @operation_window.setter
    def operation_window(self, value):
        &#34;&#34;&#34;Modifies the incremental operation window of the plan

            Args:
                value   (list)    --  list of time slots for setting the backup window

                value   (None)      --  set value to None to clear the operation window

            Raises:
                SDKException:
                    if the input is incorrect

                    if the operation window configuration fails
        &#34;&#34;&#34;
        if isinstance(value, list):
            req_json = {
                &#34;operationWindow&#34;: {
                    &#34;operations&#34;: [
                        2,
                        4
                    ],
                    &#34;dayTime&#34;: value
                }
            }
            resp = self._update_plan_props(req_json)
            if resp[0]:
                self.refresh()
                return
            else:
                o_str = &#39;Failed to update the operation window\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        elif value is None:
            self._commcell_object.operation_window.delete_operation_window(
                rule_id=self._operation_window[&#39;ruleId&#39;]
            )
            self.refresh()
            return
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan operation window must be a list value or None&#39;
            )

    @property
    def full_operation_window(self):
        &#34;&#34;&#34;Treats the plan full backup operation window as a read-only attribute&#34;&#34;&#34;
        return self._full_operation_window

    @full_operation_window.setter
    def full_operation_window(self, value):
        &#34;&#34;&#34;Modifies the full backup operation window of the plan

            Args:
                value   (list)    --  list of time slots for setting the backup window

                value   (None)      --  set value to None to clear the operation window

            Raises:
                SDKException:
                    if the input is incorrect

                    if the operation window configuration fails
        &#34;&#34;&#34;
        if isinstance(value, list):
            req_json = {
                &#34;operationWindow&#34;: {
                    &#34;operations&#34;: [
                        1,
                    ],
                    &#34;dayTime&#34;: value
                }
            }
            resp = self._update_plan_props(req_json)
            if resp[0]:
                self.refresh()
                return
            else:
                o_str = &#39;Failed to update the full operation window\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        elif value is None:
            self._commcell_object.operation_window.delete_operation_window(
                rule_id=self._full_operation_window[&#39;ruleId&#39;]
            )
            self.refresh()
            return
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan full operation window must be a list value or None&#39;
            )

    @property
    def plan_type(self):
        &#34;&#34;&#34;Treats the plan type as a read-only attribute.&#34;&#34;&#34;
        return self._plan_type

    @property
    def subtype(self):
        &#34;&#34;&#34;Treats the plan subtype as a read-only attribute.&#34;&#34;&#34;
        return self._subtype

    @property
    def override_entities(self):
        &#34;&#34;&#34;Treats the plan override_entities as a read-only attribute.&#34;&#34;&#34;
        return self._override_entities

    @override_entities.setter
    def override_entities(self, value):
        &#34;&#34;&#34;Sets the override restrictions for the plan&#34;&#34;&#34;
        req_json = {
            &#34;inheritance&#34;: {
                &#34;isSealed&#34;: False,
                &#34;enforcedEntitiesOperationType&#34;: 1,
                &#34;privateEntitiesOperationType&#34;: 1
            }
        }
        if isinstance(value, dict):
            req_json[&#39;inheritance&#39;].update(value)
            resp = self._update_plan_props(req_json)
            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan override restrictions\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Override restrictions must be defined in a dict&#39;
            )

    @property
    def storage_policy(self):
        &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
        return self._child_policies[&#39;storagePolicy&#39;]

    @property
    def storage_copies(self):
        &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
        return self._storage_copies

    @property
    def schedule_policies(self):
        &#34;&#34;&#34;Treats the plan schedule policies as read-only attribute&#34;&#34;&#34;
        return self._child_policies[&#39;schedulePolicy&#39;]

    @property
    def addons(self):
        &#34;&#34;&#34;Treats the plan addons as read-only attribute&#34;&#34;&#34;
        for addon in self._plan_properties.get(&#39;summary&#39;, {}).get(&#39;addons&#39;, []):
            self._addons.append(
                addon
            )
        return self._addons

    @property
    def subclient_policy(self):
        &#34;&#34;&#34;Treats the plan subclient policy as a read-only attribute&#34;&#34;&#34;
        return self._child_policies[&#39;subclientPolicyIds&#39;]

    @property
    def associated_entities(self):
        &#34;&#34;&#34;getter for the backup entities associated with the plan&#34;&#34;&#34;
        return self._associated_entities

    @property
    def parent_plan(self):
        &#34;&#34;&#34;getter for the parent plan of a derived plan&#34;&#34;&#34;
        return self._commcell_object.plans.get(self._parent_plan_name)

    @property
    def security_associations(self):
        &#34;&#34;&#34;getter for the plan&#39;s security associations
            Eg:
                {
                    &#39;sample_user_group_name&#39;: &#39;role_name&#39;
                }
        &#34;&#34;&#34;
        return self._security_associations

    def refresh(self):
        &#34;&#34;&#34;Refresh the properties of the Plan.&#34;&#34;&#34;
        self._properties = self._get_plan_properties()

    def associate_user(self, userlist):
        &#34;&#34;&#34;associates the users to the plan.
            # TODO: Need to handle user groups.

           Arguments:
                userlist(list) - list of users to be associated to the plans.

            Raises:
                SDKException:
                    if response is empty

                    if response is not success

        &#34;&#34;&#34;
        users_list = []

        for user in userlist:
            if self._commcell_object.users.has_user(user):
                temp = self._commcell_object.users.get(user)

                temp_dict = {
                    &#39;sendInvite&#39;: True,
                    &#39;user&#39;: {
                        &#39;userName&#39;: temp.user_name,
                        &#39;userId&#39;: int(temp.user_id)
                    }
                }

                users_list.append(temp_dict)

        request_json = {
            &#34;userOperationType&#34;: 1,
            &#34;users&#34;: users_list
        }

        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, self._ADD_USERS_TO_PLAN, request_json
        )

        if flag:
            if response.json() and &#39;errors&#39; in response.json():
                for error in response.json()[&#34;errors&#34;]:
                    error_code = error[&#34;status&#34;][&#34;errorCode&#34;]

                    if error_code == 0:
                        pass
                    else:
                        o_str = &#39;Failed to add users with error code: &#34;{0}&#34;&#39;
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_code))
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cvpysdk.plan.Plan"><code class="flex name class">
<span>class <span class="ident">Plan</span></span>
<span>(</span><span>commcell_object, plan_name, plan_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for performing operations for a specific Plan.</p>
<p>Initialize the Plan class instance.</p>
<h2 id="args">Args</h2>
<p>commcell_object
(object)
&ndash;
instance of the Commcell class</p>
<p>plan_name
(str)
&ndash;
name of the plan</p>
<p>plan_id
(str)
&ndash;
id of the plan
default: None</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Plan class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L667-L1681" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Plan(object):
    &#34;&#34;&#34;Class for performing operations for a specific Plan.&#34;&#34;&#34;

    def __init__(self, commcell_object, plan_name, plan_id=None):
        &#34;&#34;&#34;Initialize the Plan class instance.

            Args:
                commcell_object     (object)  --  instance of the Commcell class

                plan_name           (str)     --  name of the plan

                plan_id             (str)     --  id of the plan
                    default: None

            Returns:
                object - instance of the Plan class

        &#34;&#34;&#34;
        self._commcell_object = commcell_object

        self._cvpysdk_object = commcell_object._cvpysdk_object
        self._services = commcell_object._services
        self._update_response_ = commcell_object._update_response_

        self._plan_name = plan_name.lower()
        self._plan_properties = None

        if plan_id:
            self._plan_id = str(plan_id)
        else:
            self._plan_id = self._get_plan_id()

        self._PLAN = self._services[&#39;PLAN&#39;] % (self.plan_id)
        self._ADD_USERS_TO_PLAN = self._services[&#39;ADD_USERS_TO_PLAN&#39;] % (self.plan_id)

        self._properties = None
        self._sla_in_minutes = None
        self._operation_window = None
        self._full_operation_window = None
        self._plan_type = None
        self._subtype = None
        self._security_associations = {}
        self._storage_pool = None
        self._child_policies = {
            &#39;storagePolicy&#39;: None,
            &#39;schedulePolicy&#39;: {},
            &#39;subclientPolicyIds&#39;: []
        }
        self._storage_copies = {}
        self._user_group = None
        self._client_group = None
        self._override_entities = None
        self._parent_plan_name = None
        self._addons = []
        self._associated_entities = {}
        self.refresh()

    def __repr__(self):
        &#34;&#34;&#34;String representation of the instance of this class.&#34;&#34;&#34;
        representation_string = &#39;Plan class instance for plan: &#34;{0}&#34;, of Commcell: &#34;{1}&#34;&#39;

        return representation_string.format(
            self._plan_name, self._commcell_object.commserv_name
        )

    def _get_plan_id(self):
        &#34;&#34;&#34;Gets the plan id associated with this plan.

            Returns:
                str - id associated with this plan
        &#34;&#34;&#34;
        plans = Plans(self._commcell_object)
        return plans.get(self.plan_name).plan_id

    def _get_plan_properties(self):
        &#34;&#34;&#34;Gets the plan properties of this plan.

            Returns:
                dict - dictionary consisting of the properties of this plan

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        plan_properties_url = &#39;{0}?propertyLevel=20&#39;.format(self._PLAN)
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, plan_properties_url)

        if flag:
            if response.json() and &#39;plan&#39; in response.json():
                self._plan_properties = response.json()[&#39;plan&#39;]

                if &#39;planName&#39; in self._plan_properties[&#39;summary&#39;][&#39;plan&#39;]:
                    self._plan_name = self._plan_properties[&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                if &#39;slaInMinutes&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._sla_in_minutes = self._plan_properties[&#39;summary&#39;][&#39;slaInMinutes&#39;]

                if &#39;type&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._plan_type = self._plan_properties[&#39;summary&#39;][&#39;type&#39;]

                if &#39;subtype&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._subtype = self._plan_properties[&#39;summary&#39;][&#39;subtype&#39;]

                if &#39;storage&#39; in self._plan_properties:
                    if &#39;copy&#39; in self._plan_properties[&#39;storage&#39;]:
                        for copy in self._plan_properties[&#39;storage&#39;][&#39;copy&#39;]:
                            self._storage_copies[copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]] = {
                                &#39;storagePool&#39;: copy[&#39;useGlobalPolicy&#39;][&#39;storagePolicyName&#39;].lower(),
                                &#39;retainBackupDataForDays&#39;: copy[
                                    &#39;retentionRules&#39;][&#39;retainBackupDataForDays&#39;],
                                &#39;isDefault&#39;: False,
                                &#39;isSnapCopy&#39;: False,
                            }
                            if &#39;extendedRetentionRuleOne&#39; in copy[&#39;retentionRules&#39;]:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;extendedRetention&#39;] = (
                                        1,
                                        True,
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;rule&#39;],
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;endDays&#39;],
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;graceDays&#39;]
                                    ) 
                            if copy[&#39;isDefault&#39;] == 1:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;isDefault&#39;] = True

                            if copy[&#39;isSnapCopy&#39;] == 1:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;isSnapCopy&#39;] = True

                    if &#39;storagePolicy&#39; in self._plan_properties[&#39;storage&#39;]:
                        self._commcell_object.storage_policies.refresh()
                        self._child_policies[&#39;storagePolicy&#39;] = self._commcell_object.storage_policies.get(
                            self._plan_properties[&#39;storage&#39;][&#39;storagePolicy&#39;][&#39;storagePolicyName&#39;]
                        )

                if self._subtype == 33554439:
                    if &#39;clientGroup&#39; in self._plan_properties[&#39;autoCreatedEntities&#39;]:
                        self._commcell_object.client_groups.refresh()
                        self._client_group = self._commcell_object.client_groups.get(
                            self._plan_properties[&#39;autoCreatedEntities&#39;][&#39;clientGroup&#39;][
                                &#39;clientGroupName&#39;]
                        )

                    if &#39;localUserGroup&#39; in self._plan_properties[&#39;autoCreatedEntities&#39;]:
                        self._user_group = self._plan_properties[&#39;autoCreatedEntities&#39;][
                            &#39;localUserGroup&#39;][&#39;userGroupName&#39;]

                if &#39;schedule&#39; in self._plan_properties:
                    if &#39;task&#39; in self._plan_properties[&#39;schedule&#39;]:
                        self._commcell_object.schedule_policies.refresh()
                        self._child_policies[&#39;schedulePolicy&#39;] = {
                            &#39;data&#39;: self._commcell_object.policies.schedule_policies.get(
                                self._plan_properties[&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;]
                            )
                        }
                        if self._subtype == 33554437:
                            self._child_policies[&#39;schedulePolicy&#39;].update({
                                &#39;log&#39;: self._commcell_object.policies.schedule_policies.get(
                                    self._plan_properties[
                                        &#39;database&#39;][&#39;scheduleLog&#39;][&#39;task&#39;][&#39;taskName&#39;]
                                )
                            })

                if self._plan_properties[&#39;operationWindow&#39;][&#39;ruleId&#39;] != 0:
                    self._operation_window = self._plan_properties[&#39;operationWindow&#39;]
                else:
                    self._operation_window = None

                if self._plan_properties[&#39;fullOperationWindow&#39;][&#39;ruleId&#39;] != 0:
                    self._full_operation_window = self._plan_properties[&#39;fullOperationWindow&#39;]
                else:
                    self._full_operation_window = None

                if &#39;laptop&#39; in self._plan_properties:
                    if &#39;backupContent&#39; in self._plan_properties[&#39;laptop&#39;][&#39;content&#39;]:
                        self._child_policies[&#39;subclientPolicyIds&#39;].clear()
                        for ida in self._plan_properties[&#39;laptop&#39;][&#39;content&#39;][&#39;backupContent&#39;]:
                            self._child_policies[&#39;subclientPolicyIds&#39;].append(
                                ida[&#39;subClientPolicy&#39;][&#39;backupSetEntity&#39;][&#39;backupsetId&#39;]
                            )

                if (&#39;inheritance&#39; in self._plan_properties and
                        not self._plan_properties[&#39;inheritance&#39;][&#39;isSealed&#39;]):
                    temp_dict = self._plan_properties[&#39;inheritance&#39;]
                    del temp_dict[&#39;isSealed&#39;]
                    if &#39;enforcedEntities&#39; not in temp_dict:
                        temp_dict[&#39;enforcedEntities&#39;] = []
                    if &#39;privateEntities&#39; not in temp_dict:
                        temp_dict[&#39;privateEntities&#39;] = []
                    self._override_entities = temp_dict

                if &#39;parent&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._parent_plan_name = self._plan_properties[&#39;summary&#39;][&#39;parent&#39;][&#39;planName&#39;]

                if &#39;securityAssociations&#39; in self._plan_properties:
                    for association in self._plan_properties[&#39;securityAssociations&#39;][&#39;associations&#39;]:
                        temp_key = None
                        if &#39;externalGroupName&#39; in association[&#39;userOrGroup&#39;][0]:
                            temp_key = &#39;{0}\\{1}&#39;.format(
                                    association[&#39;userOrGroup&#39;][0][&#39;providerDomainName&#39;],
                                    association[&#39;userOrGroup&#39;][0][&#39;externalGroupName&#39;]
                                )
                        elif &#39;userGroupName&#39; in association[&#39;userOrGroup&#39;][0]:
                            temp_key = association[&#39;userOrGroup&#39;][0][&#39;userGroupName&#39;]
                        else:
                            temp_key = association[&#39;userOrGroup&#39;][0][&#39;userName&#39;]
                        if &#39;role&#39; in association[&#39;properties&#39;]:
                            if temp_key in self._security_associations:
                                self._security_associations[temp_key].append(
                                    association[&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;]
                                )
                            else:
                                self._security_associations[temp_key] = [association[&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;]]

                self._get_associated_entities()

                return self._plan_properties
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def derive_and_add(self,
                       plan_name,
                       storage_pool_name=None,
                       sla_in_minutes=None,
                       override_entities=None):
        &#34;&#34;&#34;Derives the base plan based on the the inheritance properties to created a derived plan

            Args:
                plan_name           (str)        --  name of the new plan to add

                storage_pool_name   (str)   --  name of the storage pool to be used for the plan
                    default: None   :   when the name is left to default, it inherits the base plan
                                        storage pool if overriding is optional/not allowed

                sla_in_minutes        (int)        --  Backup SLA in hours
                    default: None   :   when the SLA is left to default, it inherits the base plan
                                        SLA if overriding is optional/not allowed

                override_entities   (dict)  --  Specify the entities with respective overriding.

                    default: None

                        {
                            &#39;privateEntities&#39;: [1, 4],

                            &#39;enforcedEntities&#39;: [256, 512, 1024]
                        }
                        - where,
                                privateEntities are set when respective entity overriding is must
                                enforcedEntities are set when respective entity overriding is
                                not allowed
                                left blank if overriding is optional

                        - entity IDs,
                                1    - Storage
                                4    - SLA/Schedules
                                256  - Windows content
                                512  - Unix content
                                1024 - Mac content


        Returns:
            object - instance of the Plan class created by this method

        Raises:
            SDKException:
                if plan name is in incorrect format

                if plan already exists

                if neccessary arguments are not passed

                if inheritance rules are not followed

        &#34;&#34;&#34;
        if not isinstance(plan_name, basestring):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;, &#39;Plan name must be string value&#39;)
        else:
            if self._commcell_object.plans.has_plan(plan_name):
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(
                        plan_name)
                )
        if self._override_entities is not None:
            request_json = self._commcell_object.plans._get_plan_template(
                str(self._subtype), &#34;MSP&#34;)

            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;parent&#39;] = {
                &#39;planId&#39;: int(self._plan_id)
            }

            is_dedupe = True
            if storage_pool_name is not None:
                storage_pool_obj = self._commcell_object.storage_pools.get(
                    storage_pool_name
                )
                if &#39;dedupDBDetailsList&#39; \
                        not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
                    is_dedupe = False
                storage_pool_id = int(storage_pool_obj.storage_pool_id)
                if is_dedupe:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;useGlobalDedupStore&#39;] = 1
                else:
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;enableDeduplication&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;enableClientSideDedup&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                        &#39;useGlobalStoragePolicy&#39;: 1
                    }
            else:
                storage_pool_id = None

            if 1 in self._override_entities[&#39;enforcedEntities&#39;]:
                if storage_pool_id is None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                        &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                    }
                    snap_copy_id = self.storage_policy.storage_policy_id
                else:
                    raise SDKException(
                        &#39;Plan&#39;, &#39;102&#39;, &#39;Storage is enforced by base plan, cannot be overridden&#39;)
            elif 1 in self._override_entities[&#39;privateEntities&#39;]:
                if storage_pool_id is not None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                        &#34;storagePolicyId&#34;: storage_pool_id
                    }
                    snap_copy_id = storage_pool_id
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Storage must be input&#39;)
            else:
                if storage_pool_id is not None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                        &#34;storagePolicyId&#34;: storage_pool_id
                    }
                    snap_copy_id = storage_pool_id
                else:
                    request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                        &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                    }
                    snap_copy_id = self.storage_policy.storage_policy_id

            if 4 in self._override_entities[&#39;enforcedEntities&#39;]:
                if sla_in_minutes is None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes
                else:
                    raise SDKException(
                        &#39;Plan&#39;, &#39;102&#39;, &#39;SLA is enforced by base plan, cannot be overridden&#39;)
            elif 4 in self._override_entities[&#39;privateEntities&#39;]:
                if sla_in_minutes is not None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;SLA must be input&#39;)
            else:
                if sla_in_minutes is not None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
                else:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes

            if isinstance(override_entities, dict):
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
                request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                    &#39;isSealed&#39;: False
                }
                for entity in self._override_entities[&#39;enforcedEntities&#39;]:
                    from functools import reduce
                    if override_entities and entity in reduce(
                            lambda i, j: i + j, override_entities.values()):
                        raise SDKException(
                            &#39;Plan&#39;, &#39;102&#39;, &#39;Override not allowed&#39;)
                if &#39;enforcedEntities&#39; in override_entities:
                    request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = (
                        override_entities[&#39;enforcedEntities&#39;]
                    )
                if &#39;privateEntities&#39; in override_entities:
                    request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = (
                        override_entities[&#39;privateEntities&#39;]
                    )
            else:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
                request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                    &#39;isSealed&#39;: True
                }

            if sla_in_minutes is not None:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                    &#39;definesEntity&#39;: True
                }
            else:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                    &#39;definesEntity&#39;: False
                }

            if isinstance(self._override_entities, dict):
                if (4 not in
                        self._override_entities[&#39;enforcedEntities&#39;] +
                        self._override_entities[&#39;privateEntities&#39;]):
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 0
                elif 4 in self._override_entities[&#39;enforcedEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 2
                elif 4 in self._override_entities[&#39;privateEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 1

            if storage_pool_id is not None:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                    &#39;definesEntity&#39;: True
                }
            else:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                    &#39;definesEntity&#39;: False
                }

            if isinstance(self._override_entities, dict):
                if (1 not in
                        self._override_entities[&#39;enforcedEntities&#39;] +
                        self._override_entities[&#39;privateEntities&#39;]):
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 0
                elif 1 in self._override_entities[&#39;enforcedEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 2
                elif 1 in self._override_entities[&#39;privateEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 1

            if self._subtype != 33554437:
                temp_defines_key = {
                    &#39;definesEntity&#39;: False
                }
                if isinstance(self._override_entities, dict):
                    if (not all(entity in
                                self._override_entities[&#39;enforcedEntities&#39;] +
                                self._override_entities[&#39;privateEntities&#39;]
                                for entity in [256, 512, 1024])):
                        temp_defines_key[&#39;overrideEntity&#39;] = 0
                    elif all(entity in self._override_entities[&#39;enforcedEntities&#39;]
                             for entity in [256, 512, 1024]):
                        temp_defines_key[&#39;overrideEntity&#39;] = 2
                    elif all(entity in self._override_entities[&#39;privateEntities&#39;]
                             for entity in [256, 512, 1024]):
                        temp_defines_key[&#39;overrideEntity&#39;] = 1
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientLin&#39;] = temp_defines_key
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientMac&#39;] = temp_defines_key
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientWin&#39;] = temp_defines_key

            if self._subtype == 33554437 and &#39;snap&#39; in self.addons and &#39;copy&#39; \
                    in request_json[&#39;plan&#39;][&#39;storage&#39;]:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                    &#39;storagePolicyId&#39;: snap_copy_id
                }
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                    &#39;useGlobalStoragePolicy&#39;: 1
                }

            add_plan_service = self._commcell_object.plans._PLANS
            headers = self._commcell_object._headers.copy()
            headers[&#39;LookupNames&#39;] = &#39;False&#39;

            flag, response = self._cvpysdk_object.make_request(
                &#39;POST&#39;, add_plan_service, request_json, headers=headers
            )

            if flag:
                if response.json():
                    response_value = response.json()
                    error_message = None
                    error_code = None

                    if &#39;errors&#39; in response_value:
                        error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                        error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                    # error_codes 0 - OK, 1 - plan without storage, 84 - restricted plan
                    if error_code not in [0, 1, 84]:
                        o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                            error_message
                        )
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                    if &#39;plan&#39; in response_value:
                        plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                        # initialize the plans again
                        # so that the plans object has all the plans
                        self._commcell_object.plans.refresh()

                        return self._commcell_object.plans.get(plan_name)
                    else:
                        o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                                 &#39;Please check the documentation for &#39;
                                 &#39;more details on the error&#39;).format(error_code)

                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
                else:
                    raise SDKException(&#39;Response&#39;, 102)
            else:
                response_string = self._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        else:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Inheritance disabled for plan&#39;)

    def modify_schedule(self, schedule_json, is_full_schedule=False):
        &#34;&#34;&#34;Modifies the incremental RPO schedule pattern of the plan with the given schedule json

            Args:
            schedule_json (dict) -- {
                    pattern : {}, -- Please refer SchedulePattern.create_schedule in schedules.py for the types of
                                     pattern to be sent

                                     eg: {
                                            &#34;freq_type&#34;: &#39;daily&#39;,
                                            &#34;active_start_time&#34;: time_in_%H/%S (str),
                                            &#34;repeat_days&#34;: days_to_repeat (int)
                                         }

                    options: {} -- Please refer ScheduleOptions.py classes for respective schedule options

                                    eg:  {
                                        &#34;maxNumberOfStreams&#34;: 0,
                                        &#34;useMaximumStreams&#34;: True,
                                        &#34;useScallableResourceManagement&#34;: True,
                                        &#34;totalJobsToProcess&#34;: 1000,
                                        &#34;allCopies&#34;: True,
                                        &#34;mediaAgent&#34;: {
                                            &#34;mediaAgentName&#34;: &#34;&lt;ANY MEDIAAGENT&gt;&#34;
                                        }
                                    }
                    }
            is_full_schedule (bool) --  Pass True if he schedule to be modified is the full backup schedule
        &#34;&#34;&#34;
        if is_full_schedule:
            try:
                schedule_id = list(filter(
                    lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
                ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
            except IndexError:
                raise IndexError(&#39;Full backup schedule not enabled&#39;)
        else:
            schedule_id = list(filter(
                lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 65536, self.schedule_policies[&#39;data&#39;]._subtasks
            ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
        self.schedule_policies[&#39;data&#39;].modify_schedule(
            schedule_json,
            schedule_id=schedule_id
        )
        self.refresh()

    def add_storage_copy(self, copy_name, storage_pool, retention=30, extended_retention=None):
        &#34;&#34;&#34;Add a storage copy as backup destination to this plan
            Args:
                copy_name   (str)   -   name of the copy that is being added

                storage_pool (str)  -   name of the storage pool for the copy to be added

                retention   (int)   -   retention period in days for the copy

                extended_retention (tuple)  -   extended retention rules of a copy
                                                Example: [1, True, &#34;EXTENDED_ALLFULL&#34;, 0, 0]
            Returns:
                dict    -   dictionary of all copies of this plan
        &#34;&#34;&#34;
        if isinstance(copy_name, str) and isinstance(storage_pool, str):
            if not self.storage_policy.has_copy(copy_name):
                self.storage_policy.create_secondary_copy(
                    copy_name,
                    global_policy=storage_pool
                )
                self.storage_policy.get_copy(copy_name).copy_retention = (retention, 0, 0)
                if extended_retention:
                    self.storage_policy.get_copy(
                        copy_name).extended_retention_rules = extended_retention
                self.refresh()
                return self.storage_copies
            else:
                err_msg = f&#39;Storage Policy copy &#34;{copy_name}&#34; already exists.&#39;
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Copy name and storage pool name must be a string.&#39;
            )

    def disable_full_schedule(self):
        &#34;&#34;&#34;Disable the full backup schedule of the plan&#34;&#34;&#34;
        try:
            self.schedule_policies[&#39;data&#39;].delete_schedule(schedule_id=list(filter(
                lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
            ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;])
        except IndexError:
            raise IndexError(&#39;Full backup schedule not enabled&#39;)

    def edit_association(self, entities, new_plan=None):
        &#34;&#34;&#34;Reassociates or dissociates the entities from this plan
            Args:
                entities    (list)  --  list containing entity objects whose plan association must be edited
                                        Eg: [
                                            {
                                                &#34;clientName&#34;: &#34;client&#34;,
                                                &#34;subclientName&#34;: &#34;subclient&#34;,
                                                &#34;backupsetName&#34;: &#34;backupset&#34;,
                                                &#34;appName&#34;: &#34;app&#34;
                                            }
                                        ]

                new_plan    (str)   --  new plan to which the associated entities must be reassociated with

            Raises:
                SDKException
                    if plan not found
        &#34;&#34;&#34;
        req_json = {
            &#39;plan&#39;: {
                &#39;planName&#39;: self.plan_name
            },
            &#39;entities&#39;: entities
        }
        if new_plan is not None:
            if self._commcell_object.plans.has_plan(new_plan):
                req_json.update({
                    &#39;planOperationType&#39;: &#39;OVERWRITE&#39;,
                    &#39;newPlan&#39;: {
                        &#39;planName&#39;: new_plan
                    }
                })
            else:
                SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                    new_plan)
                )
        else:
            req_json.update({
                &#39;planOperationType&#39;: &#39;DELETE&#39;
            })
        req_url = self._services[&#39;ASSOCIATED_ENTITIES&#39;] % (self._plan_id)
        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, req_url, req_json
        )

        if flag:
            if &#39;response&#39; in response.json():
                error_code = str(response.json()[&#34;response&#34;][0][&#34;errorCode&#34;])

                if error_code == &#34;0&#34;:
                    self.refresh()
                    return
            else:
                error_message = str(response.json()[&#34;errorMessage&#34;])
                o_str = &#39;Failed to edit plan associated entities\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_message))
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _update_plan_props(self, props):
        &#34;&#34;&#34;Updates the properties of the plan

            Args:
                props   (dict)  --  dictionary containing the properties to be updated
                                    {
                                        &#39;planName&#39;: &#39;NewName&#39;
                                    }

            Raises:
                SDKException
                    if there is failure in updating the plan
        &#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, self._PLAN, props
        )
        if flag:
            if response.json():
                error_code = str(response.json()[&#34;errors&#34;][0][&#34;status&#34;][&#34;errorCode&#34;])
                error_message = str(response.json()[&#34;errors&#34;][0][&#34;status&#34;][&#34;errorMessage&#34;])

                if error_code == &#34;0&#34;:
                    self.refresh()
                    return (True, error_code)
                else:
                    return (False, error_code, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_associated_entities(self):
        &#34;&#34;&#34;Gets all the backup entities associated with the plan.

            Returns:
                dict - dictionary containing list of entities that are
                       associated with the plan.

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        request_url = self._services[&#39;ASSOCIATED_ENTITIES&#39;] % (self._plan_id)
        flag, response = self._cvpysdk_object.make_request(
            &#39;GET&#39;, request_url
        )

        if flag:
            if response.json() and &#39;entities&#39; in response.json():
                self._associated_entities = response.json()[&#39;entities&#39;]
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def plan_id(self):
        &#34;&#34;&#34;Treats the plan id as a read-only attribute.&#34;&#34;&#34;
        return self._plan_id

    @property
    def plan_name(self):
        &#34;&#34;&#34;Treats the plan name as a read-only attribute.&#34;&#34;&#34;
        return self._plan_name

    @plan_name.setter
    def plan_name(self, value):
        &#34;&#34;&#34;modifies the plan name&#34;&#34;&#34;
        if isinstance(value, basestring):
            req_json = {
                &#39;summary&#39;: {
                    &#39;plan&#39;: {
                        &#39;planName&#39;: value
                    }
                }
            }
            resp = self._update_plan_props(req_json)

            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan name\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan name must be a string value&#39;
            )

    @property
    def sla_in_minutes(self):
        &#34;&#34;&#34;Treats the plan SLA/RPO as a read-only attribute.&#34;&#34;&#34;
        return self._sla_in_minutes

    @sla_in_minutes.setter
    def sla_in_minutes(self, value):
        &#34;&#34;&#34;Modifies the plan SLA/RPO&#34;&#34;&#34;
        if isinstance(value, int):
            req_json = {
                &#39;summary&#39;: {
                    &#39;slaInMinutes&#39;: value
                }
            }
            resp = self._update_plan_props(req_json)

            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan SLA\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan SLA must be an int value&#39;
            )

    @property
    def operation_window(self):
        &#34;&#34;&#34;Treats the plan incremental operation window as a read-only attribute&#34;&#34;&#34;
        return self._operation_window

    @operation_window.setter
    def operation_window(self, value):
        &#34;&#34;&#34;Modifies the incremental operation window of the plan

            Args:
                value   (list)    --  list of time slots for setting the backup window

                value   (None)      --  set value to None to clear the operation window

            Raises:
                SDKException:
                    if the input is incorrect

                    if the operation window configuration fails
        &#34;&#34;&#34;
        if isinstance(value, list):
            req_json = {
                &#34;operationWindow&#34;: {
                    &#34;operations&#34;: [
                        2,
                        4
                    ],
                    &#34;dayTime&#34;: value
                }
            }
            resp = self._update_plan_props(req_json)
            if resp[0]:
                self.refresh()
                return
            else:
                o_str = &#39;Failed to update the operation window\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        elif value is None:
            self._commcell_object.operation_window.delete_operation_window(
                rule_id=self._operation_window[&#39;ruleId&#39;]
            )
            self.refresh()
            return
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan operation window must be a list value or None&#39;
            )

    @property
    def full_operation_window(self):
        &#34;&#34;&#34;Treats the plan full backup operation window as a read-only attribute&#34;&#34;&#34;
        return self._full_operation_window

    @full_operation_window.setter
    def full_operation_window(self, value):
        &#34;&#34;&#34;Modifies the full backup operation window of the plan

            Args:
                value   (list)    --  list of time slots for setting the backup window

                value   (None)      --  set value to None to clear the operation window

            Raises:
                SDKException:
                    if the input is incorrect

                    if the operation window configuration fails
        &#34;&#34;&#34;
        if isinstance(value, list):
            req_json = {
                &#34;operationWindow&#34;: {
                    &#34;operations&#34;: [
                        1,
                    ],
                    &#34;dayTime&#34;: value
                }
            }
            resp = self._update_plan_props(req_json)
            if resp[0]:
                self.refresh()
                return
            else:
                o_str = &#39;Failed to update the full operation window\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        elif value is None:
            self._commcell_object.operation_window.delete_operation_window(
                rule_id=self._full_operation_window[&#39;ruleId&#39;]
            )
            self.refresh()
            return
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan full operation window must be a list value or None&#39;
            )

    @property
    def plan_type(self):
        &#34;&#34;&#34;Treats the plan type as a read-only attribute.&#34;&#34;&#34;
        return self._plan_type

    @property
    def subtype(self):
        &#34;&#34;&#34;Treats the plan subtype as a read-only attribute.&#34;&#34;&#34;
        return self._subtype

    @property
    def override_entities(self):
        &#34;&#34;&#34;Treats the plan override_entities as a read-only attribute.&#34;&#34;&#34;
        return self._override_entities

    @override_entities.setter
    def override_entities(self, value):
        &#34;&#34;&#34;Sets the override restrictions for the plan&#34;&#34;&#34;
        req_json = {
            &#34;inheritance&#34;: {
                &#34;isSealed&#34;: False,
                &#34;enforcedEntitiesOperationType&#34;: 1,
                &#34;privateEntitiesOperationType&#34;: 1
            }
        }
        if isinstance(value, dict):
            req_json[&#39;inheritance&#39;].update(value)
            resp = self._update_plan_props(req_json)
            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan override restrictions\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Override restrictions must be defined in a dict&#39;
            )

    @property
    def storage_policy(self):
        &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
        return self._child_policies[&#39;storagePolicy&#39;]

    @property
    def storage_copies(self):
        &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
        return self._storage_copies

    @property
    def schedule_policies(self):
        &#34;&#34;&#34;Treats the plan schedule policies as read-only attribute&#34;&#34;&#34;
        return self._child_policies[&#39;schedulePolicy&#39;]

    @property
    def addons(self):
        &#34;&#34;&#34;Treats the plan addons as read-only attribute&#34;&#34;&#34;
        for addon in self._plan_properties.get(&#39;summary&#39;, {}).get(&#39;addons&#39;, []):
            self._addons.append(
                addon
            )
        return self._addons

    @property
    def subclient_policy(self):
        &#34;&#34;&#34;Treats the plan subclient policy as a read-only attribute&#34;&#34;&#34;
        return self._child_policies[&#39;subclientPolicyIds&#39;]

    @property
    def associated_entities(self):
        &#34;&#34;&#34;getter for the backup entities associated with the plan&#34;&#34;&#34;
        return self._associated_entities

    @property
    def parent_plan(self):
        &#34;&#34;&#34;getter for the parent plan of a derived plan&#34;&#34;&#34;
        return self._commcell_object.plans.get(self._parent_plan_name)

    @property
    def security_associations(self):
        &#34;&#34;&#34;getter for the plan&#39;s security associations
            Eg:
                {
                    &#39;sample_user_group_name&#39;: &#39;role_name&#39;
                }
        &#34;&#34;&#34;
        return self._security_associations

    def refresh(self):
        &#34;&#34;&#34;Refresh the properties of the Plan.&#34;&#34;&#34;
        self._properties = self._get_plan_properties()

    def associate_user(self, userlist):
        &#34;&#34;&#34;associates the users to the plan.
            # TODO: Need to handle user groups.

           Arguments:
                userlist(list) - list of users to be associated to the plans.

            Raises:
                SDKException:
                    if response is empty

                    if response is not success

        &#34;&#34;&#34;
        users_list = []

        for user in userlist:
            if self._commcell_object.users.has_user(user):
                temp = self._commcell_object.users.get(user)

                temp_dict = {
                    &#39;sendInvite&#39;: True,
                    &#39;user&#39;: {
                        &#39;userName&#39;: temp.user_name,
                        &#39;userId&#39;: int(temp.user_id)
                    }
                }

                users_list.append(temp_dict)

        request_json = {
            &#34;userOperationType&#34;: 1,
            &#34;users&#34;: users_list
        }

        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, self._ADD_USERS_TO_PLAN, request_json
        )

        if flag:
            if response.json() and &#39;errors&#39; in response.json():
                for error in response.json()[&#34;errors&#34;]:
                    error_code = error[&#34;status&#34;][&#34;errorCode&#34;]

                    if error_code == 0:
                        pass
                    else:
                        o_str = &#39;Failed to add users with error code: &#34;{0}&#34;&#39;
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_code))
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="cvpysdk.plan.Plan.addons"><code class="name">var <span class="ident">addons</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan addons as read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1590-L1597" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def addons(self):
    &#34;&#34;&#34;Treats the plan addons as read-only attribute&#34;&#34;&#34;
    for addon in self._plan_properties.get(&#39;summary&#39;, {}).get(&#39;addons&#39;, []):
        self._addons.append(
            addon
        )
    return self._addons</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.associated_entities"><code class="name">var <span class="ident">associated_entities</span></code></dt>
<dd>
<div class="desc"><p>getter for the backup entities associated with the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1604-L1607" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def associated_entities(self):
    &#34;&#34;&#34;getter for the backup entities associated with the plan&#34;&#34;&#34;
    return self._associated_entities</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.full_operation_window"><code class="name">var <span class="ident">full_operation_window</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan full backup operation window as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1490-L1493" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def full_operation_window(self):
    &#34;&#34;&#34;Treats the plan full backup operation window as a read-only attribute&#34;&#34;&#34;
    return self._full_operation_window</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.operation_window"><code class="name">var <span class="ident">operation_window</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan incremental operation window as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1442-L1445" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def operation_window(self):
    &#34;&#34;&#34;Treats the plan incremental operation window as a read-only attribute&#34;&#34;&#34;
    return self._operation_window</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.override_entities"><code class="name">var <span class="ident">override_entities</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan override_entities as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1547-L1550" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def override_entities(self):
    &#34;&#34;&#34;Treats the plan override_entities as a read-only attribute.&#34;&#34;&#34;
    return self._override_entities</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.parent_plan"><code class="name">var <span class="ident">parent_plan</span></code></dt>
<dd>
<div class="desc"><p>getter for the parent plan of a derived plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1609-L1612" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def parent_plan(self):
    &#34;&#34;&#34;getter for the parent plan of a derived plan&#34;&#34;&#34;
    return self._commcell_object.plans.get(self._parent_plan_name)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.plan_id"><code class="name">var <span class="ident">plan_id</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan id as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1383-L1386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def plan_id(self):
    &#34;&#34;&#34;Treats the plan id as a read-only attribute.&#34;&#34;&#34;
    return self._plan_id</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.plan_name"><code class="name">var <span class="ident">plan_name</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan name as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1388-L1391" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def plan_name(self):
    &#34;&#34;&#34;Treats the plan name as a read-only attribute.&#34;&#34;&#34;
    return self._plan_name</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.plan_type"><code class="name">var <span class="ident">plan_type</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan type as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1537-L1540" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def plan_type(self):
    &#34;&#34;&#34;Treats the plan type as a read-only attribute.&#34;&#34;&#34;
    return self._plan_type</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.schedule_policies"><code class="name">var <span class="ident">schedule_policies</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan schedule policies as read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1585-L1588" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def schedule_policies(self):
    &#34;&#34;&#34;Treats the plan schedule policies as read-only attribute&#34;&#34;&#34;
    return self._child_policies[&#39;schedulePolicy&#39;]</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.security_associations"><code class="name">var <span class="ident">security_associations</span></code></dt>
<dd>
<div class="desc"><p>getter for the plan's security associations</p>
<h2 id="eg">Eg</h2>
<p>{
'sample_user_group_name': 'role_name'
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1614-L1622" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def security_associations(self):
    &#34;&#34;&#34;getter for the plan&#39;s security associations
        Eg:
            {
                &#39;sample_user_group_name&#39;: &#39;role_name&#39;
            }
    &#34;&#34;&#34;
    return self._security_associations</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.sla_in_minutes"><code class="name">var <span class="ident">sla_in_minutes</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan SLA/RPO as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1416-L1419" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sla_in_minutes(self):
    &#34;&#34;&#34;Treats the plan SLA/RPO as a read-only attribute.&#34;&#34;&#34;
    return self._sla_in_minutes</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.storage_copies"><code class="name">var <span class="ident">storage_copies</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan storage policy as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1580-L1583" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def storage_copies(self):
    &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
    return self._storage_copies</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.storage_policy"><code class="name">var <span class="ident">storage_policy</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan storage policy as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1575-L1578" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def storage_policy(self):
    &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
    return self._child_policies[&#39;storagePolicy&#39;]</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.subclient_policy"><code class="name">var <span class="ident">subclient_policy</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan subclient policy as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1599-L1602" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def subclient_policy(self):
    &#34;&#34;&#34;Treats the plan subclient policy as a read-only attribute&#34;&#34;&#34;
    return self._child_policies[&#39;subclientPolicyIds&#39;]</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.subtype"><code class="name">var <span class="ident">subtype</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan subtype as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1542-L1545" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def subtype(self):
    &#34;&#34;&#34;Treats the plan subtype as a read-only attribute.&#34;&#34;&#34;
    return self._subtype</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cvpysdk.plan.Plan.add_storage_copy"><code class="name flex">
<span>def <span class="ident">add_storage_copy</span></span>(<span>self, copy_name, storage_pool, retention=30, extended_retention=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a storage copy as backup destination to this plan</p>
<h2 id="args">Args</h2>
<p>copy_name
(str)
-
name of the copy that is being added</p>
<p>storage_pool (str)
-
name of the storage pool for the copy to be added</p>
<p>retention
(int)
-
retention period in days for the copy</p>
<p>extended_retention (tuple)
-
extended retention rules of a copy
Example: [1, True, "EXTENDED_ALLFULL", 0, 0]</p>
<h2 id="returns">Returns</h2>
<p>dict
-
dictionary of all copies of this plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1222-L1254" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_storage_copy(self, copy_name, storage_pool, retention=30, extended_retention=None):
    &#34;&#34;&#34;Add a storage copy as backup destination to this plan
        Args:
            copy_name   (str)   -   name of the copy that is being added

            storage_pool (str)  -   name of the storage pool for the copy to be added

            retention   (int)   -   retention period in days for the copy

            extended_retention (tuple)  -   extended retention rules of a copy
                                            Example: [1, True, &#34;EXTENDED_ALLFULL&#34;, 0, 0]
        Returns:
            dict    -   dictionary of all copies of this plan
    &#34;&#34;&#34;
    if isinstance(copy_name, str) and isinstance(storage_pool, str):
        if not self.storage_policy.has_copy(copy_name):
            self.storage_policy.create_secondary_copy(
                copy_name,
                global_policy=storage_pool
            )
            self.storage_policy.get_copy(copy_name).copy_retention = (retention, 0, 0)
            if extended_retention:
                self.storage_policy.get_copy(
                    copy_name).extended_retention_rules = extended_retention
            self.refresh()
            return self.storage_copies
        else:
            err_msg = f&#39;Storage Policy copy &#34;{copy_name}&#34; already exists.&#39;
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)
    else:
        raise SDKException(
            &#39;Plan&#39;, &#39;102&#39;, &#39;Copy name and storage pool name must be a string.&#39;
        )</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.associate_user"><code class="name flex">
<span>def <span class="ident">associate_user</span></span>(<span>self, userlist)</span>
</code></dt>
<dd>
<div class="desc"><p>associates the users to the plan.
# TODO: Need to handle user groups.</p>
<h2 id="arguments">Arguments</h2>
<p>userlist(list) - list of users to be associated to the plans.</p>
<p>Raises:
SDKException:
if response is empty</p>
<pre><code>     if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1628-L1681" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def associate_user(self, userlist):
    &#34;&#34;&#34;associates the users to the plan.
        # TODO: Need to handle user groups.

       Arguments:
            userlist(list) - list of users to be associated to the plans.

        Raises:
            SDKException:
                if response is empty

                if response is not success

    &#34;&#34;&#34;
    users_list = []

    for user in userlist:
        if self._commcell_object.users.has_user(user):
            temp = self._commcell_object.users.get(user)

            temp_dict = {
                &#39;sendInvite&#39;: True,
                &#39;user&#39;: {
                    &#39;userName&#39;: temp.user_name,
                    &#39;userId&#39;: int(temp.user_id)
                }
            }

            users_list.append(temp_dict)

    request_json = {
        &#34;userOperationType&#34;: 1,
        &#34;users&#34;: users_list
    }

    flag, response = self._cvpysdk_object.make_request(
        &#39;PUT&#39;, self._ADD_USERS_TO_PLAN, request_json
    )

    if flag:
        if response.json() and &#39;errors&#39; in response.json():
            for error in response.json()[&#34;errors&#34;]:
                error_code = error[&#34;status&#34;][&#34;errorCode&#34;]

                if error_code == 0:
                    pass
                else:
                    o_str = &#39;Failed to add users with error code: &#34;{0}&#34;&#39;
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_code))
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.derive_and_add"><code class="name flex">
<span>def <span class="ident">derive_and_add</span></span>(<span>self, plan_name, storage_pool_name=None, sla_in_minutes=None, override_entities=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Derives the base plan based on the the inheritance properties to created a derived plan</p>
<pre><code>Args:
    plan_name           (str)        --  name of the new plan to add

    storage_pool_name   (str)   --  name of the storage pool to be used for the plan
        default: None   :   when the name is left to default, it inherits the base plan
                            storage pool if overriding is optional/not allowed

    sla_in_minutes        (int)        --  Backup SLA in hours
        default: None   :   when the SLA is left to default, it inherits the base plan
                            SLA if overriding is optional/not allowed

    override_entities   (dict)  --  Specify the entities with respective overriding.

        default: None

            {
                'privateEntities': [1, 4],

                'enforcedEntities': [256, 512, 1024]
            }
            - where,
                    privateEntities are set when respective entity overriding is must
                    enforcedEntities are set when respective entity overriding is
                    not allowed
                    left blank if overriding is optional

            - entity IDs,
                    1    - Storage
                    4    - SLA/Schedules
                    256  - Windows content
                    512  - Unix content
                    1024 - Mac content
</code></pre>
<h2 id="returns">Returns</h2>
<p>object - instance of the Plan class created by this method</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if plan name is in incorrect format</p>
<pre><code>if plan already exists

if neccessary arguments are not passed

if inheritance rules are not followed
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L893-L1174" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def derive_and_add(self,
                   plan_name,
                   storage_pool_name=None,
                   sla_in_minutes=None,
                   override_entities=None):
    &#34;&#34;&#34;Derives the base plan based on the the inheritance properties to created a derived plan

        Args:
            plan_name           (str)        --  name of the new plan to add

            storage_pool_name   (str)   --  name of the storage pool to be used for the plan
                default: None   :   when the name is left to default, it inherits the base plan
                                    storage pool if overriding is optional/not allowed

            sla_in_minutes        (int)        --  Backup SLA in hours
                default: None   :   when the SLA is left to default, it inherits the base plan
                                    SLA if overriding is optional/not allowed

            override_entities   (dict)  --  Specify the entities with respective overriding.

                default: None

                    {
                        &#39;privateEntities&#39;: [1, 4],

                        &#39;enforcedEntities&#39;: [256, 512, 1024]
                    }
                    - where,
                            privateEntities are set when respective entity overriding is must
                            enforcedEntities are set when respective entity overriding is
                            not allowed
                            left blank if overriding is optional

                    - entity IDs,
                            1    - Storage
                            4    - SLA/Schedules
                            256  - Windows content
                            512  - Unix content
                            1024 - Mac content


    Returns:
        object - instance of the Plan class created by this method

    Raises:
        SDKException:
            if plan name is in incorrect format

            if plan already exists

            if neccessary arguments are not passed

            if inheritance rules are not followed

    &#34;&#34;&#34;
    if not isinstance(plan_name, basestring):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;, &#39;Plan name must be string value&#39;)
    else:
        if self._commcell_object.plans.has_plan(plan_name):
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(
                    plan_name)
            )
    if self._override_entities is not None:
        request_json = self._commcell_object.plans._get_plan_template(
            str(self._subtype), &#34;MSP&#34;)

        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;parent&#39;] = {
            &#39;planId&#39;: int(self._plan_id)
        }

        is_dedupe = True
        if storage_pool_name is not None:
            storage_pool_obj = self._commcell_object.storage_pools.get(
                storage_pool_name
            )
            if &#39;dedupDBDetailsList&#39; \
                    not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
                is_dedupe = False
            storage_pool_id = int(storage_pool_obj.storage_pool_id)
            if is_dedupe:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;useGlobalDedupStore&#39;] = 1
            else:
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;enableDeduplication&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;enableClientSideDedup&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                    &#39;useGlobalStoragePolicy&#39;: 1
                }
        else:
            storage_pool_id = None

        if 1 in self._override_entities[&#39;enforcedEntities&#39;]:
            if storage_pool_id is None:
                request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                    &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                }
                snap_copy_id = self.storage_policy.storage_policy_id
            else:
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;Storage is enforced by base plan, cannot be overridden&#39;)
        elif 1 in self._override_entities[&#39;privateEntities&#39;]:
            if storage_pool_id is not None:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                    &#34;storagePolicyId&#34;: storage_pool_id
                }
                snap_copy_id = storage_pool_id
            else:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Storage must be input&#39;)
        else:
            if storage_pool_id is not None:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                    &#34;storagePolicyId&#34;: storage_pool_id
                }
                snap_copy_id = storage_pool_id
            else:
                request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                    &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                }
                snap_copy_id = self.storage_policy.storage_policy_id

        if 4 in self._override_entities[&#39;enforcedEntities&#39;]:
            if sla_in_minutes is None:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes
            else:
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;SLA is enforced by base plan, cannot be overridden&#39;)
        elif 4 in self._override_entities[&#39;privateEntities&#39;]:
            if sla_in_minutes is not None:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
            else:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;SLA must be input&#39;)
        else:
            if sla_in_minutes is not None:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
            else:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes

        if isinstance(override_entities, dict):
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: False
            }
            for entity in self._override_entities[&#39;enforcedEntities&#39;]:
                from functools import reduce
                if override_entities and entity in reduce(
                        lambda i, j: i + j, override_entities.values()):
                    raise SDKException(
                        &#39;Plan&#39;, &#39;102&#39;, &#39;Override not allowed&#39;)
            if &#39;enforcedEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = (
                    override_entities[&#39;enforcedEntities&#39;]
                )
            if &#39;privateEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = (
                    override_entities[&#39;privateEntities&#39;]
                )
        else:
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: True
            }

        if sla_in_minutes is not None:
            request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                &#39;definesEntity&#39;: True
            }
        else:
            request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                &#39;definesEntity&#39;: False
            }

        if isinstance(self._override_entities, dict):
            if (4 not in
                    self._override_entities[&#39;enforcedEntities&#39;] +
                    self._override_entities[&#39;privateEntities&#39;]):
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 0
            elif 4 in self._override_entities[&#39;enforcedEntities&#39;]:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 2
            elif 4 in self._override_entities[&#39;privateEntities&#39;]:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 1

        if storage_pool_id is not None:
            request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                &#39;definesEntity&#39;: True
            }
        else:
            request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                &#39;definesEntity&#39;: False
            }

        if isinstance(self._override_entities, dict):
            if (1 not in
                    self._override_entities[&#39;enforcedEntities&#39;] +
                    self._override_entities[&#39;privateEntities&#39;]):
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 0
            elif 1 in self._override_entities[&#39;enforcedEntities&#39;]:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 2
            elif 1 in self._override_entities[&#39;privateEntities&#39;]:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 1

        if self._subtype != 33554437:
            temp_defines_key = {
                &#39;definesEntity&#39;: False
            }
            if isinstance(self._override_entities, dict):
                if (not all(entity in
                            self._override_entities[&#39;enforcedEntities&#39;] +
                            self._override_entities[&#39;privateEntities&#39;]
                            for entity in [256, 512, 1024])):
                    temp_defines_key[&#39;overrideEntity&#39;] = 0
                elif all(entity in self._override_entities[&#39;enforcedEntities&#39;]
                         for entity in [256, 512, 1024]):
                    temp_defines_key[&#39;overrideEntity&#39;] = 2
                elif all(entity in self._override_entities[&#39;privateEntities&#39;]
                         for entity in [256, 512, 1024]):
                    temp_defines_key[&#39;overrideEntity&#39;] = 1
            request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientLin&#39;] = temp_defines_key
            request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientMac&#39;] = temp_defines_key
            request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientWin&#39;] = temp_defines_key

        if self._subtype == 33554437 and &#39;snap&#39; in self.addons and &#39;copy&#39; \
                in request_json[&#39;plan&#39;][&#39;storage&#39;]:
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                &#39;storagePolicyId&#39;: snap_copy_id
            }
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                &#39;useGlobalStoragePolicy&#39;: 1
            }

        add_plan_service = self._commcell_object.plans._PLANS
        headers = self._commcell_object._headers.copy()
        headers[&#39;LookupNames&#39;] = &#39;False&#39;

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, add_plan_service, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = None

                if &#39;errors&#39; in response_value:
                    error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                # error_codes 0 - OK, 1 - plan without storage, 84 - restricted plan
                if error_code not in [0, 1, 84]:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                    # initialize the plans again
                    # so that the plans object has all the plans
                    self._commcell_object.plans.refresh()

                    return self._commcell_object.plans.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
    else:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Inheritance disabled for plan&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.disable_full_schedule"><code class="name flex">
<span>def <span class="ident">disable_full_schedule</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable the full backup schedule of the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1256-L1263" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def disable_full_schedule(self):
    &#34;&#34;&#34;Disable the full backup schedule of the plan&#34;&#34;&#34;
    try:
        self.schedule_policies[&#39;data&#39;].delete_schedule(schedule_id=list(filter(
            lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
        ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;])
    except IndexError:
        raise IndexError(&#39;Full backup schedule not enabled&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.edit_association"><code class="name flex">
<span>def <span class="ident">edit_association</span></span>(<span>self, entities, new_plan=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reassociates or dissociates the entities from this plan</p>
<h2 id="args">Args</h2>
<p>entities
(list)
&ndash;
list containing entity objects whose plan association must be edited
Eg: [
{
"clientName": "client",
"subclientName": "subclient",
"backupsetName": "backupset",
"appName": "app"
}
]</p>
<p>new_plan
(str)
&ndash;
new plan to which the associated entities must be reassociated with</p>
<h2 id="raises">Raises</h2>
<p>SDKException
if plan not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1265-L1324" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def edit_association(self, entities, new_plan=None):
    &#34;&#34;&#34;Reassociates or dissociates the entities from this plan
        Args:
            entities    (list)  --  list containing entity objects whose plan association must be edited
                                    Eg: [
                                        {
                                            &#34;clientName&#34;: &#34;client&#34;,
                                            &#34;subclientName&#34;: &#34;subclient&#34;,
                                            &#34;backupsetName&#34;: &#34;backupset&#34;,
                                            &#34;appName&#34;: &#34;app&#34;
                                        }
                                    ]

            new_plan    (str)   --  new plan to which the associated entities must be reassociated with

        Raises:
            SDKException
                if plan not found
    &#34;&#34;&#34;
    req_json = {
        &#39;plan&#39;: {
            &#39;planName&#39;: self.plan_name
        },
        &#39;entities&#39;: entities
    }
    if new_plan is not None:
        if self._commcell_object.plans.has_plan(new_plan):
            req_json.update({
                &#39;planOperationType&#39;: &#39;OVERWRITE&#39;,
                &#39;newPlan&#39;: {
                    &#39;planName&#39;: new_plan
                }
            })
        else:
            SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                new_plan)
            )
    else:
        req_json.update({
            &#39;planOperationType&#39;: &#39;DELETE&#39;
        })
    req_url = self._services[&#39;ASSOCIATED_ENTITIES&#39;] % (self._plan_id)
    flag, response = self._cvpysdk_object.make_request(
        &#39;PUT&#39;, req_url, req_json
    )

    if flag:
        if &#39;response&#39; in response.json():
            error_code = str(response.json()[&#34;response&#34;][0][&#34;errorCode&#34;])

            if error_code == &#34;0&#34;:
                self.refresh()
                return
        else:
            error_message = str(response.json()[&#34;errorMessage&#34;])
            o_str = &#39;Failed to edit plan associated entities\nError: &#34;{0}&#34;&#39;
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_message))
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.modify_schedule"><code class="name flex">
<span>def <span class="ident">modify_schedule</span></span>(<span>self, schedule_json, is_full_schedule=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Modifies the incremental RPO schedule pattern of the plan with the given schedule json</p>
<p>Args:
schedule_json (dict) &ndash; {
pattern : {}, &ndash; Please refer SchedulePattern.create_schedule in schedules.py for the types of
pattern to be sent</p>
<pre><code>                     eg: {
                            "freq_type": 'daily',
                            "active_start_time": time_in_%H/%S (str),
                            "repeat_days": days_to_repeat (int)
                         }

    options: {} -- Please refer ScheduleOptions.py classes for respective schedule options

                    eg:  {
                        "maxNumberOfStreams": 0,
                        "useMaximumStreams": True,
                        "useScallableResourceManagement": True,
                        "totalJobsToProcess": 1000,
                        "allCopies": True,
                        "mediaAgent": {
                            "mediaAgentName": "&lt;ANY MEDIAAGENT&gt;"
                        }
                    }
    }
</code></pre>
<p>is_full_schedule (bool) &ndash;
Pass True if he schedule to be modified is the full backup schedule</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1176-L1220" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def modify_schedule(self, schedule_json, is_full_schedule=False):
    &#34;&#34;&#34;Modifies the incremental RPO schedule pattern of the plan with the given schedule json

        Args:
        schedule_json (dict) -- {
                pattern : {}, -- Please refer SchedulePattern.create_schedule in schedules.py for the types of
                                 pattern to be sent

                                 eg: {
                                        &#34;freq_type&#34;: &#39;daily&#39;,
                                        &#34;active_start_time&#34;: time_in_%H/%S (str),
                                        &#34;repeat_days&#34;: days_to_repeat (int)
                                     }

                options: {} -- Please refer ScheduleOptions.py classes for respective schedule options

                                eg:  {
                                    &#34;maxNumberOfStreams&#34;: 0,
                                    &#34;useMaximumStreams&#34;: True,
                                    &#34;useScallableResourceManagement&#34;: True,
                                    &#34;totalJobsToProcess&#34;: 1000,
                                    &#34;allCopies&#34;: True,
                                    &#34;mediaAgent&#34;: {
                                        &#34;mediaAgentName&#34;: &#34;&lt;ANY MEDIAAGENT&gt;&#34;
                                    }
                                }
                }
        is_full_schedule (bool) --  Pass True if he schedule to be modified is the full backup schedule
    &#34;&#34;&#34;
    if is_full_schedule:
        try:
            schedule_id = list(filter(
                lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
            ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
        except IndexError:
            raise IndexError(&#39;Full backup schedule not enabled&#39;)
    else:
        schedule_id = list(filter(
            lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 65536, self.schedule_policies[&#39;data&#39;]._subtasks
        ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
    self.schedule_policies[&#39;data&#39;].modify_schedule(
        schedule_json,
        schedule_id=schedule_id
    )
    self.refresh()</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the properties of the Plan.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L1624-L1626" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Refresh the properties of the Plan.&#34;&#34;&#34;
    self._properties = self._get_plan_properties()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cvpysdk.plan.Plans"><code class="flex name class">
<span>class <span class="ident">Plans</span></span>
<span>(</span><span>commcell_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for representing all the plans in the commcell.</p>
<p>Initialize object of Plans class.</p>
<h2 id="args">Args</h2>
<p>commcell_object (object)
&ndash; instance of the Commcell class</p>
<h2 id="returns">Returns</h2>
<p>object - instance of Plans class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L128-L664" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Plans(object):
    &#34;&#34;&#34;Class for representing all the plans in the commcell.&#34;&#34;&#34;

    def __init__(self, commcell_object):
        &#34;&#34;&#34;Initialize object of Plans class.

            Args:
                commcell_object (object)  -- instance of the Commcell class

            Returns:
                object - instance of Plans class
        &#34;&#34;&#34;

        self._commcell_object = commcell_object

        self._cvpysdk_object = commcell_object._cvpysdk_object
        self._services = commcell_object._services
        self._update_response_ = commcell_object._update_response_

        self._PLANS = self._services[&#39;PLANS&#39;]
        self._plans = None
        self.refresh()

    def __str__(self):
        &#34;&#34;&#34;Representation string consisting of all plans of the Commcell.

            Returns:
                str - string of all the plans for a commcell
        &#34;&#34;&#34;
        representation_string = &#34;{:^5}\t{:^50}\n\n&#34;.format(&#39;S. No.&#39;, &#39;Plan&#39;)

        for index, plan in enumerate(self._plans):
            sub_str = &#39;{:^5}\t{:30}\n&#39;.format(index + 1, plan)
            representation_string += sub_str

        return representation_string.strip()

    def __repr__(self):
        &#34;&#34;&#34;Representation string for the instance of the Plans class.&#34;&#34;&#34;
        return &#34;Plans class instance for Commcell: &#39;{0}&#39;&#34;.format(
            self._commcell_object.commserv_name
        )

    def __len__(self):
        &#34;&#34;&#34;Returns the number of the plans added to the Commcell.&#34;&#34;&#34;
        return len(self.all_plans)

    def __getitem__(self, value):
        &#34;&#34;&#34;Returns the name of the plan for the given plan ID or
            the details of the plan for given plan Name.

            Args:
                value   (str / int)     --  Name or ID of the plan

            Returns:
                str     -   name of the plan, if the plan id was given

                dict    -   dict of details of the plan, if plan name was given

            Raises:
                IndexError:
                    no plan exists with the given Name / Id

        &#34;&#34;&#34;
        value = str(value)

        if value in self.all_plans:
            return self.all_plans[value]
        else:
            try:
                return list(filter(lambda x: x[1][&#39;id&#39;] == value, self.all_plans.items()))[0][0]
            except IndexError:
                raise IndexError(&#39;No plan exists with the given Name / Id&#39;)

    def _get_plans(self):
        &#34;&#34;&#34;Gets all the plans associated with the commcell

            Returns:
                dict - consists of all plans in the commcell
                    {
                        &#34;plan1_name&#34;: plan1_id,
                        &#34;plan2_name&#34;: plan2_id
                    }

                Raises:
                    SDKException:
                        if response is empty

                        if response is not success
        &#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, self._PLANS)

        if flag:
            plans = {}

            if response.json() and &#39;plans&#39; in response.json():
                response_value = response.json()[&#39;plans&#39;]

                for temp in response_value:
                    temp_name = temp[&#39;plan&#39;][&#39;planName&#39;].lower()
                    temp_id = str(temp[&#39;plan&#39;][&#39;planId&#39;]).lower()
                    plans[temp_name] = temp_id

            return plans
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_plan_template(self, plan_sub_type, plan_type=&#34;MSP&#34;):
        &#34;&#34;&#34;Gets the Plan subtype&#39;s JSON template.

            Args:
                plan_sub_type    (str)   --  Sub-type of plan to add

                    &#34;Server&#34;    -   Server Plans

                    &#34;FSServer&#34;  -   File System Plans

                    &#34;Laptop&#34;    -   Laptop Plans


                plan_type       (str)   --  Type of plan to add

                    default: &#34;MSP&#34;

            Returns:
                str     -   JSON string of the Plan&#39;s template

            Raises:
                SDKException:
                    if type or subtype of the plan does not exist

                    if there is a failure in getting the template

        &#34;&#34;&#34;
        if not (isinstance(plan_sub_type, basestring) and
                isinstance(plan_type, basestring)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            template_url = self._services[&#39;GET_PLAN_TEMPLATE&#39;] % (plan_type, plan_sub_type)

            flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, template_url)

            if flag:
                if response.json() and &#39;plan&#39; in response.json():
                    return response.json()
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Failed to get Plan template&#39;)
            else:
                response_string = self._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def all_plans(self):
        &#34;&#34;&#34;Returns the dictionary consisting of all the plans added to the Commcell.

            dict - consists of all the plans configured on the commcell

                {
                    &#34;plan1_name&#34;: plan1_id,

                    &#34;plan2_name&#34;: plan2_id
                }

        &#34;&#34;&#34;
        return self._plans

    def has_plan(self, plan_name):
        &#34;&#34;&#34;Checks if a plan exists in the commcell with the input plan name.

            Args:
                plan_name   (str)   --  name of the plan

            Returns:
                bool    -   boolean output whether the plan exists in the commcell or not

            Raises:
                SDKException:
                    if type of the plan name argument is not string

        &#34;&#34;&#34;
        if not isinstance(plan_name, basestring):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)

        return self._plans and plan_name.lower() in self._plans

    def get(self, plan_name):
        &#34;&#34;&#34;Returns a plan object of the specified plan name.

            Args:
                plan_name (str)  --  name of the plan

            Returns:
                object - instance of the Plan class for the the given plan name

            Raises:
                SDKException:
                    if type of the plan name argument is not string

                    if no plan exists with the given name
        &#34;&#34;&#34;
        if not isinstance(plan_name, basestring):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            plan_name = plan_name.lower()

            if self.has_plan(plan_name):
                return Plan(
                    self._commcell_object,
                    plan_name,
                    self._plans[plan_name]
                )

            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                    plan_name)
            )

    def delete(self, plan_name):
        &#34;&#34;&#34;Deletes the plan from the commcell.

            Args:
                plan_name (str)  --  name of the plan to remove from the commcell

            Raises:
                SDKException:
                    if type of the plan name argument is not string

                    if failed to delete plan

                    if response is empty

                    if response is not success

                    if no plan exists with the given name
        &#34;&#34;&#34;
        if not isinstance(plan_name, basestring):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            plan_name = plan_name.lower()

            if self.has_plan(plan_name):
                plan_id = self._plans[plan_name]

                delete_plan = self._services[&#39;DELETE_PLAN&#39;] % (plan_id)

                flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, delete_plan)

                error_code = 0

                if flag:
                    if &#39;error&#39; in response.json():
                        if isinstance(response.json()[&#39;error&#39;], list):
                            error_code = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                        else:
                            error_code = response.json()[&#39;errorCode&#39;]

                    if error_code != 0:
                        o_str = &#39;Failed to delete plan&#39;
                        if isinstance(response.json()[&#39;error&#39;], list):
                            error_message = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]
                        else:
                            error_message = response.json()[&#39;errorMessage&#39;]
                        o_str += &#39;\nError: &#34;{0}&#34;&#39;.format(error_message)
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
                    else:
                        # initialize the plan again
                        # so the plan object has all the plan
                        self.refresh()
                else:
                    response_string = self._update_response_(response.text)
                    raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
            else:
                raise SDKException(
                    &#39;Plan&#39;,
                    &#39;102&#39;,
                    &#39;No plan exists with name: {0}&#39;.format(plan_name)
                )

    def add(self,
            plan_name,
            plan_sub_type,
            storage_pool_name=None,
            sla_in_minutes=1440,
            override_entities=None):
        &#34;&#34;&#34;Adds a new Plan to the CommCell.

        Args:
            plan_name           (str)   --  name of the new plan to add

            plan_sub_type       (str)   --  Type of plan to add

                &#34;Server&#34;    -   Server Plans

                &#34;FSServer&#34;  -   File System Plans

                &#34;Laptop&#34;    -   Laptop Plans

                &#34;ExchangeUser&#34;  -   Exchange Mailbox Plan


            storage_pool_name   (str)   --  name of the storage pool to be used for the plan

            sla_in_minutes      (int)   --  Backup SLA in hours

                default: 1440

            override_entities   (dict)  --  Specify the entities with respective
                                            inheritance values.

                default: None

                    {
                        &#39;privateEntities&#39;: [1, 4],

                        &#39;enforcedEntities&#39;: [256, 512, 1024]
                    }
                    - where,
                            privateEntities are set when respective entity overriding is required
                            enforcedEntities are set when respective entity overriding is not
                            allowed
                            left blank if overriding is optional

                    - entity IDs,
                            1    - Storage
                            4    - RPO/Schedules
                            256  - Windows content
                            512  - Unix content
                            1024 - Mac content

        Returns:
            object  -   instance of the Plan class created by this method

        Raises:
            SDKException:
                if input parameters are incorrect

                if Plan already exists

        &#34;&#34;&#34;
        if not (isinstance(plan_name, basestring) and
                isinstance(plan_sub_type, basestring)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            if self.has_plan(plan_name):
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(plan_name)
                )
        if not plan_sub_type == &#39;ExchangeUser&#39;:
            storage_pool_obj = self._commcell_object.storage_pools.get(
                storage_pool_name)
            is_dedupe = True
            if &#39;dedupDBDetailsList&#39; \
                    not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
                is_dedupe = False

        request_json = self._get_plan_template(plan_sub_type, &#34;MSP&#34;)

        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;rpoInMinutes&#39;] = sla_in_minutes
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
        request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][1][&#39;options&#39;][&#39;commonOpts&#39;][
            &#39;automaticSchedulePattern&#39;].update({
                &#39;minBackupInterval&#39;: 0,
                &#39;maxBackupIntervalMinutes&#39;: 0,
                &#39;minSyncInterval&#39;: 0,
                &#39;minSyncIntervalMinutes&#39;: 0
            })
        request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][1][&#39;options&#39;][&#39;commonOpts&#39;][
            &#39;automaticSchedulePattern&#39;][&#39;ignoreOpWindowPastMaxInterval&#39;] = True
        del request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;]
        if not plan_sub_type == &#39;ExchangeUser&#39;:
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
            }
            if is_dedupe:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;useGlobalDedupStore&#39;] = 1
            else:
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;enableDeduplication&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;enableClientSideDedup&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                    &#39;useGlobalStoragePolicy&#39;: 1
                }

        # Configurations for database and snap addons
        if plan_sub_type == &#34;Server&#34; and &#39;database&#39; in request_json[&#39;plan&#39;]:
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalDedupStore&#39;] = 1
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0].pop(
                &#39;DDBPartitionInfo&#39;, None
            )
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalPolicy&#39;] = {
                    &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
                }
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                &#39;useGlobalStoragePolicy&#39;: 1
            }
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
            }

        # Enable full backup schedule
        for subtask in request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;]:
            if &#39;flags&#39; in subtask[&#39;subTask&#39;] and subtask[&#39;subTask&#39;][&#39;flags&#39;] == 65536:
                import copy
                full_schedule = copy.deepcopy(subtask)
                del copy
                full_schedule[&#39;subTask&#39;].update({
                    &#39;subTaskName&#39;: &#39;Full backup schedule&#39;,
                    &#39;flags&#39;: 4194304
                })
                full_schedule[&#39;pattern&#39;].update({
                    &#39;freq_type&#39;: 4,
                    &#39;freq_interval&#39;: 1,
                    &#39;name&#39;: &#39;Full backup schedule&#39;,
                    &#39;active_end_time&#39;: 0
                })
                full_schedule[&#39;options&#39;][&#39;backupOpts&#39;][&#39;backupLevel&#39;] = &#39;FULL&#39;
                request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;].append(full_schedule)
                break

        if isinstance(override_entities, dict):
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: False
            }

            if &#39;enforcedEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = override_entities[
                    &#39;enforcedEntities&#39;]

            if &#39;privateEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = override_entities[
                    &#39;privateEntities&#39;]
        else:
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: True
            }

        headers = self._commcell_object._headers.copy()
        headers[&#39;LookupNames&#39;] = &#39;False&#39;

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._PLANS, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = None

                if &#39;errors&#39; in response_value:
                    error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                if error_code &gt; 1:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                    # initialize the plans again
                    # so that the plans object has all the plans
                    self.refresh()
                    # with plan delete storage policy associated might be deleted
                    # initialize storage policy again
                    self._commcell_object.storage_policies.refresh()

                    return self.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def get_eligible_plans(self, entities):
        &#34;&#34;&#34;Returns dict of plans that are eligible for the specified entities

            Args:
                entities    (dict)  - dictionary containing entities as keys and
                                        their respective IDs as values
                    {
                        &#39;clientId&#39;: id,
                        &#39;appId&#39;: id,
                        &#39;backupsetId&#39;: id
                    }

            Returns:
                dict                - dict of eligible plans

            Raises:
                SDKException:
                    if there is an error in the response
        &#34;&#34;&#34;
        query = &#39;&#39;
        for i in entities:
            query += &#39;{0}={1}&amp;&#39;.format(i, entities[i])
        requset_url = self._services[&#39;ELIGIBLE_PLANS&#39;] % query[0:-1]
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, requset_url)
        del query

        if flag:
            plans = {}

            if response.json() and &#39;plans&#39; in response.json():
                response_value = response.json()[&#39;plans&#39;]

                for temp in response_value:
                    temp_name = temp[&#39;plan&#39;][&#39;planName&#39;].lower()
                    temp_id = str(temp[&#39;plan&#39;][&#39;planId&#39;]).lower()
                    plans[temp_name] = temp_id

            return plans
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def refresh(self):
        &#34;&#34;&#34;Refresh the plans associated with the Commcell.&#34;&#34;&#34;
        self._plans = self._get_plans()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="cvpysdk.plan.Plans.all_plans"><code class="name">var <span class="ident">all_plans</span></code></dt>
<dd>
<div class="desc"><p>Returns the dictionary consisting of all the plans added to the Commcell.</p>
<p>dict - consists of all the plans configured on the commcell</p>
<pre><code>{
    "plan1_name": plan1_id,

    "plan2_name": plan2_id
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L280-L293" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def all_plans(self):
    &#34;&#34;&#34;Returns the dictionary consisting of all the plans added to the Commcell.

        dict - consists of all the plans configured on the commcell

            {
                &#34;plan1_name&#34;: plan1_id,

                &#34;plan2_name&#34;: plan2_id
            }

    &#34;&#34;&#34;
    return self._plans</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cvpysdk.plan.Plans.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, plan_name, plan_sub_type, storage_pool_name=None, sla_in_minutes=1440, override_entities=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new Plan to the CommCell.</p>
<h2 id="args">Args</h2>
<p>plan_name
(str)
&ndash;
name of the new plan to add</p>
<p>plan_sub_type
(str)
&ndash;
Type of plan to add</p>
<pre><code>"Server"    -   Server Plans

"FSServer"  -   File System Plans

"Laptop"    -   Laptop Plans

"ExchangeUser"  -   Exchange Mailbox Plan
</code></pre>
<p>storage_pool_name
(str)
&ndash;
name of the storage pool to be used for the plan</p>
<p>sla_in_minutes
(int)
&ndash;
Backup SLA in hours</p>
<pre><code>default: 1440
</code></pre>
<p>override_entities
(dict)
&ndash;
Specify the entities with respective
inheritance values.</p>
<pre><code>default: None

    {
        'privateEntities': [1, 4],

        'enforcedEntities': [256, 512, 1024]
    }
    - where,
            privateEntities are set when respective entity overriding is required
            enforcedEntities are set when respective entity overriding is not
            allowed
            left blank if overriding is optional

    - entity IDs,
            1    - Storage
            4    - RPO/Schedules
            256  - Windows content
            512  - Unix content
            1024 - Mac content
</code></pre>
<h2 id="returns">Returns</h2>
<p>object
-
instance of the Plan class created by this method</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if input parameters are incorrect</p>
<pre><code>if Plan already exists
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L407-L618" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add(self,
        plan_name,
        plan_sub_type,
        storage_pool_name=None,
        sla_in_minutes=1440,
        override_entities=None):
    &#34;&#34;&#34;Adds a new Plan to the CommCell.

    Args:
        plan_name           (str)   --  name of the new plan to add

        plan_sub_type       (str)   --  Type of plan to add

            &#34;Server&#34;    -   Server Plans

            &#34;FSServer&#34;  -   File System Plans

            &#34;Laptop&#34;    -   Laptop Plans

            &#34;ExchangeUser&#34;  -   Exchange Mailbox Plan


        storage_pool_name   (str)   --  name of the storage pool to be used for the plan

        sla_in_minutes      (int)   --  Backup SLA in hours

            default: 1440

        override_entities   (dict)  --  Specify the entities with respective
                                        inheritance values.

            default: None

                {
                    &#39;privateEntities&#39;: [1, 4],

                    &#39;enforcedEntities&#39;: [256, 512, 1024]
                }
                - where,
                        privateEntities are set when respective entity overriding is required
                        enforcedEntities are set when respective entity overriding is not
                        allowed
                        left blank if overriding is optional

                - entity IDs,
                        1    - Storage
                        4    - RPO/Schedules
                        256  - Windows content
                        512  - Unix content
                        1024 - Mac content

    Returns:
        object  -   instance of the Plan class created by this method

    Raises:
        SDKException:
            if input parameters are incorrect

            if Plan already exists

    &#34;&#34;&#34;
    if not (isinstance(plan_name, basestring) and
            isinstance(plan_sub_type, basestring)):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    else:
        if self.has_plan(plan_name):
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(plan_name)
            )
    if not plan_sub_type == &#39;ExchangeUser&#39;:
        storage_pool_obj = self._commcell_object.storage_pools.get(
            storage_pool_name)
        is_dedupe = True
        if &#39;dedupDBDetailsList&#39; \
                not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
            is_dedupe = False

    request_json = self._get_plan_template(plan_sub_type, &#34;MSP&#34;)

    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;rpoInMinutes&#39;] = sla_in_minutes
    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
    request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][1][&#39;options&#39;][&#39;commonOpts&#39;][
        &#39;automaticSchedulePattern&#39;].update({
            &#39;minBackupInterval&#39;: 0,
            &#39;maxBackupIntervalMinutes&#39;: 0,
            &#39;minSyncInterval&#39;: 0,
            &#39;minSyncIntervalMinutes&#39;: 0
        })
    request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][1][&#39;options&#39;][&#39;commonOpts&#39;][
        &#39;automaticSchedulePattern&#39;][&#39;ignoreOpWindowPastMaxInterval&#39;] = True
    del request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;]
    if not plan_sub_type == &#39;ExchangeUser&#39;:
        request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
            &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
        }
        if is_dedupe:
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalDedupStore&#39;] = 1
        else:
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;enableDeduplication&#39;]
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;enableClientSideDedup&#39;]
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                &#39;useGlobalStoragePolicy&#39;: 1
            }

    # Configurations for database and snap addons
    if plan_sub_type == &#34;Server&#34; and &#39;database&#39; in request_json[&#39;plan&#39;]:
        request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
            &#39;useGlobalDedupStore&#39;] = 1
        request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0].pop(
            &#39;DDBPartitionInfo&#39;, None
        )
        request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
            &#39;useGlobalPolicy&#39;] = {
                &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
            }
        request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
            &#39;useGlobalStoragePolicy&#39;: 1
        }
        request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
            &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
        }

    # Enable full backup schedule
    for subtask in request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;]:
        if &#39;flags&#39; in subtask[&#39;subTask&#39;] and subtask[&#39;subTask&#39;][&#39;flags&#39;] == 65536:
            import copy
            full_schedule = copy.deepcopy(subtask)
            del copy
            full_schedule[&#39;subTask&#39;].update({
                &#39;subTaskName&#39;: &#39;Full backup schedule&#39;,
                &#39;flags&#39;: 4194304
            })
            full_schedule[&#39;pattern&#39;].update({
                &#39;freq_type&#39;: 4,
                &#39;freq_interval&#39;: 1,
                &#39;name&#39;: &#39;Full backup schedule&#39;,
                &#39;active_end_time&#39;: 0
            })
            full_schedule[&#39;options&#39;][&#39;backupOpts&#39;][&#39;backupLevel&#39;] = &#39;FULL&#39;
            request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;].append(full_schedule)
            break

    if isinstance(override_entities, dict):
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
        request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
            &#39;isSealed&#39;: False
        }

        if &#39;enforcedEntities&#39; in override_entities:
            request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = override_entities[
                &#39;enforcedEntities&#39;]

        if &#39;privateEntities&#39; in override_entities:
            request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = override_entities[
                &#39;privateEntities&#39;]
    else:
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
        request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
            &#39;isSealed&#39;: True
        }

    headers = self._commcell_object._headers.copy()
    headers[&#39;LookupNames&#39;] = &#39;False&#39;

    flag, response = self._cvpysdk_object.make_request(
        &#39;POST&#39;, self._PLANS, request_json, headers=headers
    )

    if flag:
        if response.json():
            response_value = response.json()
            error_message = None
            error_code = None

            if &#39;errors&#39; in response_value:
                error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

            if error_code &gt; 1:
                o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                    error_message
                )
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

            if &#39;plan&#39; in response_value:
                plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                # initialize the plans again
                # so that the plans object has all the plans
                self.refresh()
                # with plan delete storage policy associated might be deleted
                # initialize storage policy again
                self._commcell_object.storage_policies.refresh()

                return self.get(plan_name)
            else:
                o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                         &#39;Please check the documentation for &#39;
                         &#39;more details on the error&#39;).format(error_code)

                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
        else:
            raise SDKException(&#39;Response&#39;, 102)
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, plan_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the plan from the commcell.</p>
<h2 id="args">Args</h2>
<p>plan_name (str)
&ndash;
name of the plan to remove from the commcell</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the plan name argument is not string</p>
<pre><code>if failed to delete plan

if response is empty

if response is not success

if no plan exists with the given name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L346-L405" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delete(self, plan_name):
    &#34;&#34;&#34;Deletes the plan from the commcell.

        Args:
            plan_name (str)  --  name of the plan to remove from the commcell

        Raises:
            SDKException:
                if type of the plan name argument is not string

                if failed to delete plan

                if response is empty

                if response is not success

                if no plan exists with the given name
    &#34;&#34;&#34;
    if not isinstance(plan_name, basestring):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    else:
        plan_name = plan_name.lower()

        if self.has_plan(plan_name):
            plan_id = self._plans[plan_name]

            delete_plan = self._services[&#39;DELETE_PLAN&#39;] % (plan_id)

            flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, delete_plan)

            error_code = 0

            if flag:
                if &#39;error&#39; in response.json():
                    if isinstance(response.json()[&#39;error&#39;], list):
                        error_code = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    else:
                        error_code = response.json()[&#39;errorCode&#39;]

                if error_code != 0:
                    o_str = &#39;Failed to delete plan&#39;
                    if isinstance(response.json()[&#39;error&#39;], list):
                        error_message = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]
                    else:
                        error_message = response.json()[&#39;errorMessage&#39;]
                    o_str += &#39;\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
                else:
                    # initialize the plan again
                    # so the plan object has all the plan
                    self.refresh()
            else:
                response_string = self._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        else:
            raise SDKException(
                &#39;Plan&#39;,
                &#39;102&#39;,
                &#39;No plan exists with name: {0}&#39;.format(plan_name)
            )</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, plan_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a plan object of the specified plan name.</p>
<h2 id="args">Args</h2>
<p>plan_name (str)
&ndash;
name of the plan</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Plan class for the the given plan name</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the plan name argument is not string</p>
<pre><code>if no plan exists with the given name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L314-L344" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get(self, plan_name):
    &#34;&#34;&#34;Returns a plan object of the specified plan name.

        Args:
            plan_name (str)  --  name of the plan

        Returns:
            object - instance of the Plan class for the the given plan name

        Raises:
            SDKException:
                if type of the plan name argument is not string

                if no plan exists with the given name
    &#34;&#34;&#34;
    if not isinstance(plan_name, basestring):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    else:
        plan_name = plan_name.lower()

        if self.has_plan(plan_name):
            return Plan(
                self._commcell_object,
                plan_name,
                self._plans[plan_name]
            )

        raise SDKException(
            &#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                plan_name)
        )</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.get_eligible_plans"><code class="name flex">
<span>def <span class="ident">get_eligible_plans</span></span>(<span>self, entities)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns dict of plans that are eligible for the specified entities</p>
<h2 id="args">Args</h2>
<p>entities
(dict)
- dictionary containing entities as keys and
their respective IDs as values
{
'clientId': id,
'appId': id,
'backupsetId': id
}</p>
<h2 id="returns">Returns</h2>
<p>dict
- dict of eligible plans</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if there is an error in the response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L620-L660" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_eligible_plans(self, entities):
    &#34;&#34;&#34;Returns dict of plans that are eligible for the specified entities

        Args:
            entities    (dict)  - dictionary containing entities as keys and
                                    their respective IDs as values
                {
                    &#39;clientId&#39;: id,
                    &#39;appId&#39;: id,
                    &#39;backupsetId&#39;: id
                }

        Returns:
            dict                - dict of eligible plans

        Raises:
            SDKException:
                if there is an error in the response
    &#34;&#34;&#34;
    query = &#39;&#39;
    for i in entities:
        query += &#39;{0}={1}&amp;&#39;.format(i, entities[i])
    requset_url = self._services[&#39;ELIGIBLE_PLANS&#39;] % query[0:-1]
    flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, requset_url)
    del query

    if flag:
        plans = {}

        if response.json() and &#39;plans&#39; in response.json():
            response_value = response.json()[&#39;plans&#39;]

            for temp in response_value:
                temp_name = temp[&#39;plan&#39;][&#39;planName&#39;].lower()
                temp_id = str(temp[&#39;plan&#39;][&#39;planId&#39;]).lower()
                plans[temp_name] = temp_id

        return plans
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.has_plan"><code class="name flex">
<span>def <span class="ident">has_plan</span></span>(<span>self, plan_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a plan exists in the commcell with the input plan name.</p>
<h2 id="args">Args</h2>
<p>plan_name
(str)
&ndash;
name of the plan</p>
<h2 id="returns">Returns</h2>
<p>bool
-
boolean output whether the plan exists in the commcell or not</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the plan name argument is not string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L295-L312" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_plan(self, plan_name):
    &#34;&#34;&#34;Checks if a plan exists in the commcell with the input plan name.

        Args:
            plan_name   (str)   --  name of the plan

        Returns:
            bool    -   boolean output whether the plan exists in the commcell or not

        Raises:
            SDKException:
                if type of the plan name argument is not string

    &#34;&#34;&#34;
    if not isinstance(plan_name, basestring):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)

    return self._plans and plan_name.lower() in self._plans</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the plans associated with the Commcell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/4d7305086b2627f8aea7960778819d7cead463fc/cvpysdk/plan.py#L662-L664" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Refresh the plans associated with the Commcell.&#34;&#34;&#34;
    self._plans = self._get_plans()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GitHub home" href="https://github.com/Commvault/cvpysdk">
<img src="https://commvault.github.io/cvpysdk/logo.png" alt="" width="100%"> Commvault Python SDK
</a> <br>
<a class="homelink" title="Go to Top Level" href="https://commvault.github.io/cvpysdk/cvpysdk/index.html"> Go to Top Level </a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#plans">Plans</a><ul>
<li><a href="#attributes">Attributes</a></li>
</ul>
</li>
<li><a href="#plan">Plan</a><ul>
<li><a href="#plan-attributes">Plan Attributes</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cvpysdk" href="index.html">cvpysdk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cvpysdk.plan.Plan" href="#cvpysdk.plan.Plan">Plan</a></code></h4>
<ul class="">
<li><code><a title="cvpysdk.plan.Plan.add_storage_copy" href="#cvpysdk.plan.Plan.add_storage_copy">add_storage_copy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.addons" href="#cvpysdk.plan.Plan.addons">addons</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.associate_user" href="#cvpysdk.plan.Plan.associate_user">associate_user</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.associated_entities" href="#cvpysdk.plan.Plan.associated_entities">associated_entities</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.derive_and_add" href="#cvpysdk.plan.Plan.derive_and_add">derive_and_add</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.disable_full_schedule" href="#cvpysdk.plan.Plan.disable_full_schedule">disable_full_schedule</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.edit_association" href="#cvpysdk.plan.Plan.edit_association">edit_association</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.full_operation_window" href="#cvpysdk.plan.Plan.full_operation_window">full_operation_window</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.modify_schedule" href="#cvpysdk.plan.Plan.modify_schedule">modify_schedule</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.operation_window" href="#cvpysdk.plan.Plan.operation_window">operation_window</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.override_entities" href="#cvpysdk.plan.Plan.override_entities">override_entities</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.parent_plan" href="#cvpysdk.plan.Plan.parent_plan">parent_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.plan_id" href="#cvpysdk.plan.Plan.plan_id">plan_id</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.plan_name" href="#cvpysdk.plan.Plan.plan_name">plan_name</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.plan_type" href="#cvpysdk.plan.Plan.plan_type">plan_type</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.refresh" href="#cvpysdk.plan.Plan.refresh">refresh</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.schedule_policies" href="#cvpysdk.plan.Plan.schedule_policies">schedule_policies</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.security_associations" href="#cvpysdk.plan.Plan.security_associations">security_associations</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.sla_in_minutes" href="#cvpysdk.plan.Plan.sla_in_minutes">sla_in_minutes</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.storage_copies" href="#cvpysdk.plan.Plan.storage_copies">storage_copies</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.storage_policy" href="#cvpysdk.plan.Plan.storage_policy">storage_policy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.subclient_policy" href="#cvpysdk.plan.Plan.subclient_policy">subclient_policy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.subtype" href="#cvpysdk.plan.Plan.subtype">subtype</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cvpysdk.plan.Plans" href="#cvpysdk.plan.Plans">Plans</a></code></h4>
<ul class="two-column">
<li><code><a title="cvpysdk.plan.Plans.add" href="#cvpysdk.plan.Plans.add">add</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.all_plans" href="#cvpysdk.plan.Plans.all_plans">all_plans</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.delete" href="#cvpysdk.plan.Plans.delete">delete</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.get" href="#cvpysdk.plan.Plans.get">get</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.get_eligible_plans" href="#cvpysdk.plan.Plans.get_eligible_plans">get_eligible_plans</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.has_plan" href="#cvpysdk.plan.Plans.has_plan">has_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.refresh" href="#cvpysdk.plan.Plans.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>