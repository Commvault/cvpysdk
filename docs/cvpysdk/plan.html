<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cvpysdk.plan API documentation</title>
<meta name="description" content="Main file for performing plan operations â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em;background-color:#f8f9fa}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#FE496A;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#FD0131}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" type="image/x-icon" href="https://commvault.github.io/cvpysdk/favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cvpysdk.plan</code></h1>
</header>
<section id="section-intro">
<p>Main file for performing plan operations.</p>
<p>Plans,PlanTypes and Plan are the classes defined in this file.</p>
<p>Plans: Class for representing all the plans in the commcell</p>
<p>PlanTypes : Class for representing plan types</p>
<p>Plan: Class for representing a single plan of the commcell</p>
<h1 id="plans">Plans</h1>
<pre><code>__init__(commcell_object)   --  initialise object of plans class of the commcell

__str__()                   --  returns all the plans associated with the commcell

__repr__()                  --  returns the string for the instance of the plans class

__len__()                   --  returns the number of plans added to the Commcell

__getitem__()               --  returns the name of the plan for the given plan Id
or the details for the given plan name

_get_plans()                --  gets all the plans associated with the commcell specified

_get_plan_template()        --  gets the Plan subtype's JSON template

add()                       --  adds a new Plan to the CommCell

has_plan()                  --  checks if a plan exists with the given name or not

get()                       --  returns the instance of the Plans class

delete()                    --  deletes the plan from the commcell

refresh()                   --  refresh the plans associated with the commcell

add_data_classification_plan()-  Adds data classification plan to the commcell

add_risk_analysis_dc_plan() --  Adds Risk Analysis data classification plan to the commcell

get_supported_solutions()   --  returns the supported solutions for plans

add_exchange_plan()         --  Adds a new exchange plan to the commcell

create_server_plan()        --  creates a new server plan to the commcell

_get_fl_parameters()        --  Returns the fl parameters to be passed in the mongodb caching api call

_get_sort_parameters()      --  Returns the sort parameters to be passed in the mongodb caching api call

_get_fq_parameters()        --  Returns the fq parameters based on the fq list passed

get_plans_cache()           --  Returns plan cache in response
</code></pre>
<h2 id="attributes">Attributes</h2>
<pre><code>**all_plans**   --  returns the dict consisting of plans and their details

**all_plans_cache** --  Returns the dictionary consisting of all the plans cache present in mongoDB

**all_plans_prop**  --  Return complete GET API response
</code></pre>
<dl>
<dt><strong><code>Plan</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>====</p>
<pre><code>__init__()                  -- initialise instance of the plan for the commcell

__repr__()                  -- return the plan name, the instance is associated with

_get_plan_id()              -- method to get the plan id, if not specified in __init__

_get_plan_properties()      -- get the properties of this plan

_update_plan_props()        -- method to update plan properties

_get_associated_entities()  -- method to get list of entities associated to a plan

_enable_content_indexing_o365_plan() --method to enable content indexing for O365 plan

derive_and_add()            -- add new plan by deriving from the parent Plan object

plan_name                   --  returns the name of the plan

plan_id                     --  returns the ID of the plan

refresh()                   --  refresh the properties of the plan

associate_user()            --  associates users to the plan

modify_schedule()           --  modifies the RPO schedules of the plan

add_storage_copy()          --  adds a storage pool as a copy to the plan

disable_full_schedule()     --  disables the full schedule of a plan

share()                     --  shares plan with given user by associating given role

schedule()                  --  create/delete schedule on DC Plan

edit_plan()                 --  edit plan options

edit_risk_analysis_dc_plan()--  Edit Risk Analysis Data Classification Plan options

update_security_associations() -- to update security associations of a plan

get_plan_properties()       --  method to get the properties of the plan fetched via v4 API

get_storage_copy_details()  --  method to get storage copy details

get_storage_copy_id()       --  method to get storage copy id

add_copy()                  --  method to add a copy to the plan

edit_copy()                 --  method to edit a copy of the plan

delete_copy()               --  method to delete a copy from the plan

add_region()                --  method to add a region to the plan

remove_region()             --  method to remove a region from the plan

get_schedule_properties()   --  method to get the schedule properties of the plan

add_schedule()              --  method to add a schedule to the plan

edit_schedule()             --  method to edit a schedule of the plan

delete_schedule()           --  method to delete a schedule from the plan

edit_snapshot_options()     --  method to edit snapshot options of the plan

update_backup_content()     --  method to update backup content of the plan

enable_data_aging()         --  Enable data aging for the copy of the plan
</code></pre>
<h2 id="plan-attributes">Plan Attributes</h2>
<pre><code>**plan_id**                 --  returns the id of the plan

**plan_name**               --  returns the name of the plan

**sla_in_minutes**          --  returns the SLA/RPO of the plan

**plan_type**               --  returns the type of the plan

**subtype**                 --  returns the subtype of the plan

**override_entities**       --  returns the override restrictions of the plan

**storage_policy**          --  returns the storage policy of the plan

**schedule_policies**       --  returns the schedule policy of the plan

**subclient_policy**        --  returns the subclient policy of the plan

**associated_entities**     --  returns all the backup entities associated with the plan

**operation_window**        --  returns the incremental operation window set by the plan

**full_operation_window**   --  returns the full operation window set by the plan

**associated_entities**     --  returns all the entities associated with the plan

**content_indexing_props**  --  returns the DC plan related properties from the plan

**region_id**               --  Returns the Backup destination region id

**company**                 --  Returns the company of the plan

**resources**               --  Returns the resources stored in storage resource pool

**applicable_solutions**    --  returns applicable solutions configured on server plan

**data_schedule_policy**    --  returns the data schedule policy of the plan

**log_schedule_policy**     --  returns the log schedule policy of the plan

**snap_schedule_policy**    --  returns the snap schedule policy of the plan

**content_indexing**        --  returns the status of content indexing of O365 plan

**all_copies**              --  returns all the copies for a plan
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L1-L4416" class="git-link">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

# --------------------------------------------------------------------------
# Copyright Commvault Systems, Inc.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# --------------------------------------------------------------------------

&#34;&#34;&#34;Main file for performing plan operations.

Plans,PlanTypes and Plan are the classes defined in this file.

Plans: Class for representing all the plans in the commcell

PlanTypes : Class for representing plan types

Plan: Class for representing a single plan of the commcell

Plans
=====

    __init__(commcell_object)   --  initialise object of plans class of the commcell

    __str__()                   --  returns all the plans associated with the commcell

    __repr__()                  --  returns the string for the instance of the plans class

    __len__()                   --  returns the number of plans added to the Commcell

    __getitem__()               --  returns the name of the plan for the given plan Id
    or the details for the given plan name

    _get_plans()                --  gets all the plans associated with the commcell specified

    _get_plan_template()        --  gets the Plan subtype&#39;s JSON template

    add()                       --  adds a new Plan to the CommCell

    has_plan()                  --  checks if a plan exists with the given name or not

    get()                       --  returns the instance of the Plans class

    delete()                    --  deletes the plan from the commcell

    refresh()                   --  refresh the plans associated with the commcell

    add_data_classification_plan()-  Adds data classification plan to the commcell

    add_risk_analysis_dc_plan() --  Adds Risk Analysis data classification plan to the commcell

    get_supported_solutions()   --  returns the supported solutions for plans

    add_exchange_plan()         --  Adds a new exchange plan to the commcell

    create_server_plan()        --  creates a new server plan to the commcell

    _get_fl_parameters()        --  Returns the fl parameters to be passed in the mongodb caching api call

    _get_sort_parameters()      --  Returns the sort parameters to be passed in the mongodb caching api call

    _get_fq_parameters()        --  Returns the fq parameters based on the fq list passed

    get_plans_cache()           --  Returns plan cache in response

Attributes
----------

    **all_plans**   --  returns the dict consisting of plans and their details

    **all_plans_cache** --  Returns the dictionary consisting of all the plans cache present in mongoDB

    **all_plans_prop**  --  Return complete GET API response

Plan
====

    __init__()                  -- initialise instance of the plan for the commcell

    __repr__()                  -- return the plan name, the instance is associated with

    _get_plan_id()              -- method to get the plan id, if not specified in __init__

    _get_plan_properties()      -- get the properties of this plan

    _update_plan_props()        -- method to update plan properties

    _get_associated_entities()  -- method to get list of entities associated to a plan

    _enable_content_indexing_o365_plan() --method to enable content indexing for O365 plan

    derive_and_add()            -- add new plan by deriving from the parent Plan object

    plan_name                   --  returns the name of the plan

    plan_id                     --  returns the ID of the plan

    refresh()                   --  refresh the properties of the plan

    associate_user()            --  associates users to the plan

    modify_schedule()           --  modifies the RPO schedules of the plan

    add_storage_copy()          --  adds a storage pool as a copy to the plan

    disable_full_schedule()     --  disables the full schedule of a plan

    share()                     --  shares plan with given user by associating given role

    schedule()                  --  create/delete schedule on DC Plan

    edit_plan()                 --  edit plan options

    edit_risk_analysis_dc_plan()--  Edit Risk Analysis Data Classification Plan options
    
    update_security_associations() -- to update security associations of a plan

    get_plan_properties()       --  method to get the properties of the plan fetched via v4 API
    
    get_storage_copy_details()  --  method to get storage copy details

    get_storage_copy_id()       --  method to get storage copy id

    add_copy()                  --  method to add a copy to the plan

    edit_copy()                 --  method to edit a copy of the plan

    delete_copy()               --  method to delete a copy from the plan

    add_region()                --  method to add a region to the plan

    remove_region()             --  method to remove a region from the plan

    get_schedule_properties()   --  method to get the schedule properties of the plan

    add_schedule()              --  method to add a schedule to the plan

    edit_schedule()             --  method to edit a schedule of the plan

    delete_schedule()           --  method to delete a schedule from the plan

    edit_snapshot_options()     --  method to edit snapshot options of the plan

    update_backup_content()     --  method to update backup content of the plan

    enable_data_aging()         --  Enable data aging for the copy of the plan

Plan Attributes
----------------
    **plan_id**                 --  returns the id of the plan

    **plan_name**               --  returns the name of the plan

    **sla_in_minutes**          --  returns the SLA/RPO of the plan

    **plan_type**               --  returns the type of the plan

    **subtype**                 --  returns the subtype of the plan

    **override_entities**       --  returns the override restrictions of the plan

    **storage_policy**          --  returns the storage policy of the plan

    **schedule_policies**       --  returns the schedule policy of the plan

    **subclient_policy**        --  returns the subclient policy of the plan

    **associated_entities**     --  returns all the backup entities associated with the plan

    **operation_window**        --  returns the incremental operation window set by the plan

    **full_operation_window**   --  returns the full operation window set by the plan

    **associated_entities**     --  returns all the entities associated with the plan

    **content_indexing_props**  --  returns the DC plan related properties from the plan

    **region_id**               --  Returns the Backup destination region id

    **company**                 --  Returns the company of the plan

    **resources**               --  Returns the resources stored in storage resource pool
    
    **applicable_solutions**    --  returns applicable solutions configured on server plan

    **data_schedule_policy**    --  returns the data schedule policy of the plan

    **log_schedule_policy**     --  returns the log schedule policy of the plan

    **snap_schedule_policy**    --  returns the snap schedule policy of the plan

    **content_indexing**        --  returns the status of content indexing of O365 plan

    **all_copies**              --  returns all the copies for a plan

&#34;&#34;&#34;
from __future__ import unicode_literals

import copy
from enum import Enum

from .exception import SDKException
from .security.security_association import SecurityAssociation
from .activateapps.constants import TargetApps, PlanConstants
from functools import reduce
from typing import List, Tuple, Dict, Union

class PlanTypes(Enum):
    &#34;&#34;&#34;Class Enum to represent different plan types&#34;&#34;&#34;
    Any = 0
    DLO = 1
    MSP = 2
    FS = 3
    SNAP = 4
    VSA = 5
    EXCHANGE = 6
    DC = 7
    EDISCOVERY = 8
    ARCHIVER = 9

class _PayloadGeneratorPlanV4:
    &#34;&#34;&#34;Class to provide payload for creating/modifying server plans using V4 API.&#34;&#34;&#34;

    def __init__(self, commcell):
        &#34;&#34;&#34;Initialize the _PayloadGeneratorPlanV4 class instance&#34;&#34;&#34;
        self.__commcell = commcell

    def get_copy_payload(self, copy_details: dict, is_aux_copy: bool=False) -&gt; dict:
        &#34;&#34;&#34;
            Method to get single copy details payload based on the provided configuration.

            Args:
                - copy_details (dict): Configuration for the copy.
                Should contain the following keys:
                    - &#39;storage_name&#39; (str): Name of the storage.
                    - &#39;retentionPeriodDays&#39; (int): Retention days for the copy (Default: 30 days)
                    - &#39;backupDestinationName&#39; (str): Name of the copy (Default: &#39;Primary&#39;)
                    - &#39;region_name&#39; (str, optional): Name of the region
                    - &#39;storageTemplateTags&#39; (dict): To indentify storage based on tags (Needed only for Global Plans)

                Note: Additional properties can be sent in the input to update the payload with the same exact key names.
                    
                - is_aux_copy (bool, optional): Indicates if the copy is an aux copy. Default: False
                    
            Returns:
                dict: Copy details as a dictionary.
        &#34;&#34;&#34;
        # validate the input
        if &#39;storageTemplateTags&#39; not in copy_details and &#39;storage_name&#39; not in copy_details:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Storage details is required for copy configuration.&#39;)
        
        temp_dict = copy_details.copy() # make a copy of the input to avoid modifying the original input

        payload = {
            &#34;backupDestinationName&#34;: copy_details.get(&#34;backupDestinationName&#34;, &#34;Primary&#34;),
            &#34;retentionPeriodDays&#34;: copy_details.get(&#34;retentionPeriodDays&#34;, 30),
            &#34;useExtendedRetentionRules&#34;: False,
            &#34;overrideRetentionSettings&#34;: True,
            &#34;backupStartTime&#34;: -1,
        }

        # If storage_name is provided, update the payload with storage details
        if &#39;storage_name&#39; in copy_details:
            storage_pool = self.__commcell.storage_pools.get(copy_details[&#34;storage_name&#34;])
            payload[&#39;storagePool&#39;] = {
                &#34;id&#34;: int(storage_pool.storage_pool_id),
                &#34;name&#34;: storage_pool.storage_pool_name
            }
            payload[&#39;storageType&#39;] = storage_pool.storage_pool_properties[&#39;storagePoolDetails&#39;][&#39;libraryList&#39;][0][&#39;model&#39;].upper()

        # Add aux copy specific properties
        if is_aux_copy:
            payload[&#34;backupsToCopy&#34;] = copy_details.get(&#34;backupsToCopy&#34;, &#34;All_JOBS&#34;)

        # Add region if available
        if region_name := copy_details.get(&#34;region_name&#34;):
            payload[&#34;region&#34;] = {&#34;id&#34;: int(self.__commcell.regions.get(region_name).region_id)}

            # remove the keys that are already set and doesnot match payload keys
            temp_dict.pop(&#39;region_name&#39;)

        # If the input as advanced properties like extended retention or others, update the payload
        payload = self.update_payload(original_payload=payload, update_info_dict=temp_dict)

        return payload

    def get_backupdestinations_payload(self, destinations_config: List[dict]) -&gt; list:
        &#34;&#34;&#34;
            Method to get the payload for multiple copies based on the provided configuration.

            Args:
                - destinations_config (list): List of dictionaries representing copy configurations.
                Each dictionary should contain the following keys:
                    - &#39;storage_name&#39; (str): Name of the storage.
                    - &#39;retentionPeriodDays&#39; (int): Retention days for the copy (Default: 30 days)
                    - &#39;backupDestinationName&#39; (str): Name of the copy (Default: &#39;Primary&#39;)
                    - &#39;region_name&#39; (str, optional): Name of the region

                Note: Additional properties can be sent in the input to update the payload with the same exact key names.

            Returns:
                dict: Backup destinations payload as a dictionary.
            &#34;&#34;&#34;
        backup_destinations = []

        # primary copy
        copy_details = self.get_copy_payload(destinations_config[0], is_aux_copy=False)
        backup_destinations.append(copy_details)

        # aux copies
        for copy_config in destinations_config[1:]:
            copy_details = self.get_copy_payload(copy_config, is_aux_copy=True)
            backup_destinations.append(copy_details)

        return backup_destinations

    def get_schedule_payload(self, schedule_details: Dict) -&gt; Dict:
        &#34;&#34;&#34;
        Method to get the payload for a single schedule based on the provided configuration.

        Args:
            - backupType (str): Type of backup schedule
            - scheduleOperation (str): Operation to perform on the schedule. (Default: ADD)
            - forDatabasesOnly (bool): Indicates if the schedule is for databases only (Default: False)

            For scheduleOperation = MODIFY / DELETE:
            - scheduleId (int): ID of the schedule
            - policyId (int): ID of the policy

            Note: Additional properties can be sent in the input to update the payload with the same exact key names. Get the path and key names from the API documentation or Command Center equivalent API.

        Returns:
            dict: Schedule details as a dictionary.
        &#34;&#34;&#34;
        # Validate the input
        if &#39;backupType&#39; not in schedule_details:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;backupType is required for schedule configuration.&#39;)

        operation_type = schedule_details.get(&#39;scheduleOperation&#39;, &#39;ADD&#39;)
        if operation_type in [&#39;MODIFY&#39;, &#39;DELETE&#39;]:
            if &#39;scheduleId&#39; not in schedule_details or &#39;policyId&#39; not in schedule_details:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;scheduleId and policyId are required for MODIFY / DELETE operations.&#39;)

        payload = {}
        backup_type = schedule_details[&#39;backupType&#39;]
        is_transaction_log = backup_type == &#34;TRANSACTIONLOG&#34;

        # Set default values for the payload
        if is_transaction_log:
            payload[&#39;schedulePattern&#39;] = {
                &#34;scheduleFrequencyType&#34;: &#34;AUTOMATIC&#34;,
                &#34;maxBackupIntervalInMins&#34;: 240
            }
            payload[&#39;scheduleOption&#39;] = {
                &#34;useDiskCacheForLogBackups&#34;: False,
                &#34;commitFrequencyInHours&#34;: 8,
                &#34;logsDiskUtilizationPercent&#34;: 80,
                &#34;logFilesThreshold&#34;: 50
            }
            payload[&#39;forDatabasesOnly&#39;] = True
        else:
            payload[&#39;schedulePattern&#39;] = {
                &#34;scheduleFrequencyType&#34;: &#34;DAILY&#34;,
                &#34;startTime&#34;: 75600,
                &#34;frequency&#34;: 1
            }
            payload[&#39;forDatabasesOnly&#39;] = False

        payload[&#39;scheduleOperation&#39;] = operation_type

        # Update the payload with the provided input details
        # This will override the default values
        # This will also set advanced properties for schedule if provided in the input
        payload = self.update_payload(original_payload=payload, update_info_dict=schedule_details)
        
        return payload

    def get_rpo_payload(self, schedules: List[dict]) -&gt; dict:
        &#34;&#34;&#34;
            Method to get the payload for multiple schedules based on the provided configuration

            Args:
                - backupType (str): Type of backup
                - scheduleOperation (str): Operation to perform on the schedule. (Default: ADD)
                - forDatabasesOnly (bool): Indicates if the schedule is for databases only (Default: False)

                Note: Additional properties can be sent in the input to update the payload with the same exact key names.

            Returns:
                dict: Full schedule payload as a dictionary.
        &#34;&#34;&#34;
        schedules_payload = []

        for schedule_config in schedules:
            schedule_details = self.get_schedule_payload(schedule_config)
            schedules_payload.append(schedule_details)

        return {&#34;schedules&#34;: schedules_payload}

    def get_create_server_plan_payload(self, plan_name: str, backup_destinations: List[dict], schedules: List[dict], **additional_params) -&gt; dict:
        &#34;&#34;&#34;
            Method to get a payload for creating a server plan.

            Args:
                - plan_name (str): Name of the backup plan.
                - backup_destinations (list): List of dictionaries representing backup destinations.
                - schedules (list): List of dictionaries representing backup schedules.

                - additional_params (dict): Additional parameters for the plan. Include:
                - rpo_backup_window (list, optional): Backup window for RPO schedules.
                - full_backup_window (list, optional): Backup window for full backup schedules.
                - enable_backup_copy (bool, optional): Enable backup copy.
                - backup_copy_rpo_mins (int, optional): RPO for backup copy in minutes.
                - snap_retention_days (int, optional): Retention period in days.
                - snap_recovery_points (int, optional): Snap recovery point.

            Returns:
                dict: Payload for creating a backup plan.
            &#34;&#34;&#34;
        plan_payload = {
            &#34;planName&#34;: plan_name,
            &#34;backupDestinations&#34;: self.get_backupdestinations_payload(backup_destinations),
            &#34;rpo&#34;: {
                &#34;backupFrequency&#34;: self.get_rpo_payload(schedules),
                &#34;backupWindow&#34;: additional_params.get(&#34;rpo_backup_window&#34;, []),
                &#34;fullBackupWindow&#34;: additional_params.get(&#34;full_backup_window&#34;, [])
            },
            &#34;snapshotOptions&#34;: {
                &#34;enableBackupCopy&#34;: additional_params.get(&#34;enable_backup_copy&#34;, True),
                &#34;backupCopyRPOMins&#34;: additional_params.get(&#34;backup_copy_rpo_mins&#34;, 240)
            }
        }

        if snap_recovery_points := additional_params.get(&#34;snap_recovery_points&#34;):
            plan_payload[&#34;snapshotOptions&#34;][&#34;snapRecoveryPoints&#34;] = snap_recovery_points
            plan_payload[&#34;snapshotOptions&#34;][&#34;retentionRuleType&#34;] = &#39;SNAP_RECOVERY_POINTS&#39;
        else:
            plan_payload[&#34;snapshotOptions&#34;][&#34;retentionPeriodDays&#34;] = additional_params.get(&#34;snap_retention_days&#34;, 30)
            plan_payload[&#34;snapshotOptions&#34;][&#34;retentionRuleType&#34;] = &#39;RETENTION_PERIOD&#39;

        return plan_payload

    def update_payload(self, original_payload, update_info_dict) -&gt; Dict:
        &#34;&#34;&#34;
        Recursively update the original dictionary with the values from the update dictionary.

        This function handles nested dictionaries, allowing for updates at different levels of depth.

        Args:
            original_payload (dict): The original dictionary to be updated.
            update_info_dict (dict): The dictionary containing values for update.

        Returns:
            dict: The updated dictionary.

        Example:
            &gt;&gt;&gt; original = {&#39;a&#39;: 1, &#39;b&#39;: {&#39;c&#39;: 2, &#39;d&#39;: 3}}
            &gt;&gt;&gt; update = {&#39;b&#39;: {&#39;d&#39;: 4}, &#39;e&#39;: 5}
            &gt;&gt;&gt; updated = update_payload(original, update)
            &gt;&gt;&gt; print(updated)
            {&#39;a&#39;: 1, &#39;b&#39;: {&#39;c&#39;: 2, &#39;d&#39;: 4}, &#39;e&#39;: 5}
        &#34;&#34;&#34;
        for key, value in update_info_dict.items():
            if isinstance(value, dict):
                original_payload[key] = self.update_payload(original_payload.get(key, {}), value)
            else:
                original_payload[key] = value
        return original_payload

class Plans(object):
    &#34;&#34;&#34;Class for representing all the plans in the commcell.&#34;&#34;&#34;

    def __init__(self, commcell_object):
        &#34;&#34;&#34;Initialize object of Plans class.

            Args:
                commcell_object (object)  -- instance of the Commcell class

            Returns:
                object - instance of Plans class
        &#34;&#34;&#34;

        self._all_plans_props = None
        self._commcell_object = commcell_object

        self._cvpysdk_object = commcell_object._cvpysdk_object
        self._services = commcell_object._services
        self._update_response_ = commcell_object._update_response_

        self._PLANS = self._services[&#39;PLANS&#39;]
        self._V4_DC_PLANS = self._services[&#39;V4_DC_PLANS&#39;]
        self._V4_PLANS = self._services[&#39;V4_SERVER_PLANS&#39;]
        self._V4_GLOBAL_PLANS = self._services[&#39;V4_GLOBAL_SERVER_PLANS&#39;]
        self._plans = None
        self._plans_cache = None
        self.filter_query_count = 0
        self.refresh()

    def __str__(self):
        &#34;&#34;&#34;Representation string consisting of all plans of the Commcell.

            Returns:
                str - string of all the plans for a commcell
        &#34;&#34;&#34;
        representation_string = &#34;{:^5}\t{:^50}\n\n&#34;.format(&#39;S. No.&#39;, &#39;Plan&#39;)

        for index, plan in enumerate(self._plans):
            sub_str = &#39;{:^5}\t{:30}\n&#39;.format(index + 1, plan)
            representation_string += sub_str

        return representation_string.strip()

    def __repr__(self):
        &#34;&#34;&#34;Representation string for the instance of the Plans class.&#34;&#34;&#34;
        return &#34;Plans class instance for Commcell&#34;

    def __len__(self):
        &#34;&#34;&#34;Returns the number of the plans added to the Commcell.&#34;&#34;&#34;
        return len(self.all_plans)

    def __getitem__(self, value):
        &#34;&#34;&#34;Returns the name of the plan for the given plan ID or
            the details of the plan for given plan Name.

            Args:
                value   (str / int)     --  Name or ID of the plan

            Returns:
                str     -   name of the plan, if the plan id was given

                dict    -   dict of details of the plan, if plan name was given

            Raises:
                IndexError:
                    no plan exists with the given Name / Id

        &#34;&#34;&#34;
        value = str(value)

        if value in self.all_plans:
            return self.all_plans[value]
        else:
            try:
                return list(filter(lambda x: x[1][&#39;id&#39;] == value, self.all_plans.items()))[0][0]
            except IndexError:
                raise IndexError(&#39;No plan exists with the given Name / Id&#39;)

    def _get_plans(self, full_response: bool = False):
        &#34;&#34;&#34;Gets all the plans associated with the commcell
            Args:
                full_response(bool) --  flag to return complete response
            Returns:
                dict - consists of all plans in the commcell
                    {
                        &#34;plan1_name&#34;: plan1_id,
                        &#34;plan2_name&#34;: plan2_id
                    }

                Raises:
                    SDKException:
                        if response is empty

                        if response is not success
        &#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, self._PLANS)

        if flag:
            plans = {}

            if response.json() and &#39;plans&#39; in response.json():
                if full_response:
                    return response.json()

                name_count = {}

                for temp in response.json()[&#39;plans&#39;]:
                    temp_name = temp.get(&#39;plan&#39;, {}).get(&#39;planName&#39;, &#39;&#39;).lower()
                    temp_company = temp.get(&#39;plan&#39;, {}).get(&#39;entityInfo&#39;, {}).get(&#39;companyName&#39;, &#39;&#39;).lower()

                    if temp_name in name_count:
                        name_count[temp_name].add(temp_company)
                    else:
                        name_count[temp_name] = {temp_company}

                for temp in response.json()[&#39;plans&#39;]:
                    temp_name = temp.get(&#39;plan&#39;, {}).get(&#39;planName&#39;, &#39;&#39;).lower()
                    temp_id = str(temp[&#39;plan&#39;][&#39;planId&#39;]).lower()
                    temp_company = temp.get(&#39;plan&#39;, {}).get(&#39;entityInfo&#39;, {}).get(&#39;companyName&#39;, &#39;&#39;).lower()

                    if len(name_count[temp_name]) &gt; 1:
                        unique_key = f&#34;{temp_name}_({temp_company})&#34;
                    else:
                        unique_key = temp_name

                    plans[unique_key] = temp_id

            return plans
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_plan_template(self, plan_sub_type, plan_type=&#34;MSP&#34;):
        &#34;&#34;&#34;Gets the Plan subtype&#39;s JSON template.

            Args:
                plan_sub_type    (str)   --  Sub-type of plan to add

                    &#34;Server&#34;    -   Server Plans

                    &#34;FSServer&#34;  -   File System Plans

                    &#34;Laptop&#34;    -   Laptop Plans


                plan_type       (str)   --  Type of plan to add

                    default: &#34;MSP&#34;

            Returns:
                str     -   JSON string of the Plan&#39;s template

            Raises:
                SDKException:
                    if type or subtype of the plan does not exist

                    if there is a failure in getting the template

        &#34;&#34;&#34;
        if not (isinstance(plan_sub_type, str) and
                isinstance(plan_type, str)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            template_url = self._services[&#39;GET_PLAN_TEMPLATE&#39;] % (plan_type, plan_sub_type)

            flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, template_url)

            if flag:
                if response.json() and &#39;plan&#39; in response.json():
                    return response.json()
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Failed to get Plan template&#39;)
            else:
                response_string = self._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_fl_parameters(self, fl: list = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the fl parameters to be passed in the mongodb caching api call

        Args:
            fl    (list)  --   list of columns to be passed in API request

        Returns:
            fl_parameters(str) -- fl parameter string
        &#34;&#34;&#34;
        self.valid_columns = {
            &#39;planName&#39;: &#39;plans.plan.planName&#39;,
            &#39;planId&#39;: &#39;plans.plan.planId&#39;,
            &#39;planType&#39;: &#39;plans.subtype&#39;,
            &#39;description&#39;: &#39;plans.description&#39;,
            &#39;numAssocEntities&#39;: &#39;plans.numAssocEntities&#39;,
            &#39;rpoInMinutes&#39;: &#39;plans.rpoInMinutes&#39;,
            &#39;numCopies&#39;: &#39;plans.numCopies&#39;,
            &#39;planStatusFlag&#39;: &#39;plans.planStatusFlag&#39;,
            &#39;storage&#39;: &#39;plans.storageResourcePoolMaps.resources.resourcePool&#39;,
            &#39;companyName&#39;: &#39;plans.plan.entityInfo.companyName&#39;,
            &#39;tags&#39;: &#39;tags&#39;
        }
        default_columns = &#39;plans.plan.planName,plans.plan.planId&#39;

        if fl:
            if all(col in self.valid_columns for col in fl):
                fl_parameters = f&#34;&amp;fl={default_columns},{&#39;,&#39;.join(self.valid_columns[column] for column in fl)}&#34;
            else:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid column name passed&#39;)
        else:
            fl_parameters = f&#34;&amp;fl={default_columns},{&#39;,&#39;.join(column for column in self.valid_columns.values())}&#34;

        return fl_parameters

    def _get_sort_parameters(self, sort: list = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the sort parameters to be passed in the mongodb caching api call

        Args:
            sort  (list)  --   contains the name of the column on which sorting will be performed and type of sort
                                valid sor type -- 1 for ascending and -1 for descending
                                e.g. sort = [&#39;connectName&#39;,&#39;1&#39;]

        Returns:
            sort_parameters(str) -- sort parameter string
        &#34;&#34;&#34;
        sort_type = str(sort[1])
        col = sort[0]
        if col in self.valid_columns.keys() and sort_type in [&#39;1&#39;, &#39;-1&#39;]:
            sort_parameter = &#39;&amp;sort=&#39; + self.valid_columns[col] + &#39;:&#39; + sort_type
        else:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid column name passed&#39;)
        return sort_parameter

    def _get_fq_parameters(self, fq: list = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the fq parameters based on the fq list passed
        Args:
             fq     (list) --   contains the columnName, condition and value
                    e.g. fq = [[&#39;planName&#39;,&#39;contains&#39;, test&#39;],[&#39;numAssocEntities&#39;,&#39;between&#39;, &#39;0-1&#39;]]

        Returns:
            fq_parameters(str) -- fq parameter string
        &#34;&#34;&#34;
        conditions = {&#34;contains&#34;, &#34;notContain&#34;, &#34;eq&#34;, &#34;neq&#34;, &#34;gt&#34;, &#34;lt&#34;}
        params = []

        for column, condition, *value in fq or []:
            if column not in self.valid_columns:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid column name passed&#39;)

            # Handle &#39;tags&#39; column separately
            if column == &#34;tags&#34; and condition == &#34;contains&#34;:
                params.append(f&#34;&amp;tags={value[0]}&#34;)
            elif condition in conditions:
                params.append(f&#34;&amp;fq={self.valid_columns[column]}:{condition.lower()}:{value[0]}&#34;)
            elif condition == &#34;isEmpty&#34; and not value:
                params.append(f&#34;&amp;fq={self.valid_columns[column]}:in:null,&#34;)
            elif condition == &#34;between&#34; and value and &#34;-&#34; in value[0]:
                start, end = value[0].split(&#34;-&#34;, 1)
                params.append(f&#34;&amp;fq={self.valid_columns[column]}:gteq:{start}&#34;)
                params.append(f&#34;&amp;fq={self.valid_columns[column]}:lteq:{end}&#34;)
            else:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid condition passed&#39;)

        return &#34;&#34;.join(params)

    def get_plans_cache(self, hard: bool = False, **kwargs) -&gt; dict:
        &#34;&#34;&#34;
        Returns plan cache in response.

        Args:
            hard  (bool)    --   Flag to perform hard refresh on plans cache.
            **kwargs (dict):
                fl (list)   --   List of columns to return in response (default: None).
                sort (list) --   Contains the name of the column on which sorting will be performed and type of sort.
                                       Valid sort type: 1 for ascending and -1 for descending
                                       e.g. sort = [&#39;columnName&#39;, &#39;1&#39;] (default: None).
                limit (list)--   Contains the start and limit parameter value.
                                        Default [&#39;0&#39;, &#39;100&#39;].
                search (str)--   Contains the string to search in the commcell entity cache (default: None).
                fq (list)   --   Contains the columnName, condition, and value.
                                        e.g. fq = [[&#39;planName&#39;, &#39;contains&#39;, &#39;test&#39;],
                                        [&#39;numAssocEntities&#39;, &#39;between&#39;, &#39;0-1&#39;]] (default: None).

        Returns:
            dict: Dictionary of all the properties present in response.
        &#34;&#34;&#34;
        # computing parameters
        fl_parameters = self._get_fl_parameters(kwargs.get(&#39;fl&#39;, None))
        fq_parameters = self._get_fq_parameters(kwargs.get(&#39;fq&#39;, None))
        limit = kwargs.get(&#39;limit&#39;, None)
        limit_parameters = f&#39;start={limit[0]}&amp;limit={limit[1]}&#39; if limit else &#39;&#39;
        hard_refresh = &#39;&amp;hardRefresh=true&#39; if hard else &#39;&#39;
        sort_parameters = self._get_sort_parameters(kwargs.get(&#39;sort&#39;, None)) if kwargs.get(&#39;sort&#39;, None) else &#39;&#39;

        # Search operation can only be performed on limited columns, so filtering out the columns on which search works
        searchable_columns = [&#34;planName&#34;,&#34;planType&#34;,&#34;planStatusFlag&#34;,&#34;companyName&#34;,&#34;description&#34;]
        search_parameter = (f&#39;&amp;search=tagName,tagValue,{&#34;,&#34;.join(self.valid_columns[col] for col in searchable_columns)}&#39;
                            f&#39;:contains:{kwargs.get(&#34;search&#34;, None)}&#39;) if kwargs.get(&#39;search&#39;, None) else &#39;&#39;

        params = [
            limit_parameters,
            sort_parameters,
            fl_parameters,
            hard_refresh,
            search_parameter,
            fq_parameters
        ]
        request_url = f&#34;{self._PLANS}?&#34; + &#34;&#34;.join(params)
        flag, response = self._cvpysdk_object.make_request(&#34;GET&#34;, request_url)

        if not flag:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        plans_summary = {}
        if response.json() and &#39;plans&#39; in response.json():
            self.filter_query_count = response.json().get(&#39;filterQueryCount&#39;,0)
            for plan in response.json()[&#39;plans&#39;]:
                name = plan.get(&#34;plan&#34;, {}).get(&#34;planName&#34;, None)
                company = plan.get(&#39;plan&#39;, {}).get(&#39;entityInfo&#39;, {}).get(&#39;companyName&#39;, None)

                plan_config = {
                    &#39;planName&#39;:name,
                    &#39;planId&#39;: plan.get(&#39;plan&#39;, {}).get(&#39;planId&#39;, None),
                    &#39;planType&#39;: plan.get(&#39;subtype&#39;),
                    &#39;description&#39;: plan.get(&#39;description&#39;),
                    &#39;numCopies&#39;: plan.get(&#39;numCopies&#39;),
                    &#39;numAssocEntities&#39;: plan.get(&#39;numAssocEntities&#39;),
                    &#39;rpoInMinutes&#39;: plan.get(&#39;rpoInMinutes&#39;,0),
                    &#39;planStatusFlag&#39;: plan.get(&#39;planStatusFlag&#39;),
                    &#39;companyName&#39;: company,
                    &#39;tags&#39;: (plan.get(&#39;plan&#39;) or {}).get(&#39;tags&#39;) or []
                }
                if &#39;storageResourcePoolMaps&#39; in plan and &#39;resources&#39; in plan.get(&#39;storageResourcePoolMaps&#39;, {})[0]:
                    plan_config[&#39;resourcePool&#39;] = [
                        resource.get(&#39;resourcePool&#39;, {}).get(&#39;resourcePoolName&#39;)
                        for resource in plan.get(&#39;storageResourcePoolMaps&#39;, {})[0].get(&#39;resources&#39;)
                    ]
                # Check if plan name already exists for a different company
                unique_name = name
                if name in plans_summary and plans_summary[name].get(&#39;companyName&#39;) != company:
                    unique_name = f&#34;{name}_({company})&#34;
                plans_summary[unique_name] = plan_config

            return plans_summary
        else:
            raise SDKException(&#34;Plan&#34;, &#34;102&#34;, &#34;Failed to get plans summary&#34;)

    @property
    def all_plans(self):
        &#34;&#34;&#34;Returns the dictionary consisting of all the plans added to the Commcell.

            dict - consists of all the plans configured on the commcell

                {
                    &#34;plan1_name&#34;: plan1_id,

                    &#34;plan2_name&#34;: plan2_id
                }

        &#34;&#34;&#34;
        return self._plans

    @property
    def all_plans_cache(self):
        &#34;&#34;&#34;Returns the dictionary consisting of all the plans cache present in mongoDB

                    dict - consists of all the plans configured on the commcell

                        {
                        &#34;plan1_name&#34;:
                         {
                         id : &lt;plan&#39;s id&gt;,
                         Type : &lt;type of plan&gt;,
                         subtype : &lt;sub type of plan&gt;,
                         status: &lt;status of the plan&gt;,
                         numCopies: &lt;number of copies&gt;,
                         numAssocEntities: &lt;associated Entities Count&gt;,
                         RPO: &lt;rpo in minutes&gt;,
                         planStatusFlag: &lt;status of plan&gt;,
                         company: &lt;name of the company plan belongs to&gt;
                         },

                        &#34;plan2_name&#34;:
                         {
                         id : &lt;plan&#39;s id&gt;,
                         Type : &lt;type of plan&gt;,
                         subtype : &lt;sub type of plan&gt;,
                         status: &lt;status of the plan&gt;,
                         numCopies: &lt;number of copies&gt;,
                         numAssocEntities: &lt;associated Entities Count&gt;,
                         RPO: &lt;rpo in minutes&gt;,
                         planStatusFlag: &lt;status of plan&gt;,
                         company: &lt;name of the company plan belongs to&gt;
                         },
                    }

                &#34;&#34;&#34;
        if not self._plans_cache:
            self._plans_cache = self.get_plans_cache()
        return self._plans_cache

    def filter_plans(self, plan_type, company_name=None):
        &#34;&#34;&#34;
        Returns the dictionary consisting of specified type and company plans.

        Args:
            plan_type (str)      --      Type of plan [&#39;DLO&#39;, &#39;Server&#39;, &#39;Laptop&#39;, &#39;Database&#39;, &#39;FSServer&#39;, &#39;FSIBMiVTL&#39;, &#39;Snap&#39;, &#39;VSAServer&#39;, &#39;VSAReplication&#39;, 
                                                        &#39;ExchangeUser&#39;, &#39;ExchangeJournal&#39;, &#39;Office365&#39;, &#39;Dynamics365&#39;, &#39;DataClassification&#39;, &#39;Archiver&#39;]
            company_name (str)    --     To filter plans based on the company. For Commcell, company_name = &#39;Commcell&#39;. Default will return all plans

        Returns:
            dict - consists of all the plans with specified types configured on the commcell
                {
                    &#34;plan1_name&#34;: plan1_id,
                    &#34;plan2_name&#34;: plan2_id
                }

        Raises:
            SDKException:
                if input data type is not valid
                if an invalid plan type is passed as a parameter
                if failed to get the response
        &#34;&#34;&#34;
        if not isinstance(plan_type, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        
        plan_type_lower = plan_type.lower()
        
        if plan_type_lower not in [&#34;dlo&#34;, &#34;server&#34;, &#34;laptop&#34;, &#34;database&#34;, &#34;fsserver&#34;, &#34;fsibmivtl&#34;, &#34;snap&#34;, 
                                    &#34;vsaserver&#34;, &#34;vsareplication&#34;, &#34;exchangeuser&#34;, &#34;exchangejournal&#34;, 
                                    &#34;office365&#34;, &#34;dynamics365&#34;, &#34;dataclassification&#34;, &#34;archiver&#34;]:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid Plan Type Passed as Parameter&#39;)

        params = f&#34;fq=plans.subtype%3Ain%3A{plan_type}&amp;fl=plans.plan.planId%2Cplans.plan.planName%2Cplans.subtype%2Cplans.type&#34;

        if company_name:
            company_id = (
                self._commcell_object.organizations.get(company_name).organization_id 
                if company_name != &#39;Commcell&#39; else 0
            )
            params += f&#34;&amp;fq=companyId%3Aeq%3A{company_id}&#34;

        template_url = self._services[&#39;PLAN_SUMMARY&#39;] % params

        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, template_url)

        if flag:
            result = dict()
            if &#39;plans&#39; in response.json():
                for plan in response.json()[&#39;plans&#39;]:
                    result[plan[&#39;plan&#39;][&#39;name&#39;]] = plan[&#39;plan&#39;][&#39;id&#39;]
            return result
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def has_plan(self, plan_name):
        &#34;&#34;&#34;Checks if a plan exists in the commcell with the input plan name.

            Args:
                plan_name   (str)   --  name of the plan

            Returns:
                bool    -   boolean output whether the plan exists in the commcell or not

            Raises:
                SDKException:
                    if type of the plan name argument is not string

        &#34;&#34;&#34;
        if not isinstance(plan_name, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)

        return self._plans and plan_name.lower() in self._plans

    def get(self, plan_name):
        &#34;&#34;&#34;Returns a plan object of the specified plan name.

            Args:
                plan_name (str)  --  name of the plan

            Returns:
                object - instance of the Plan class for the the given plan name

            Raises:
                SDKException:
                    if type of the plan name argument is not string

                    if no plan exists with the given name
        &#34;&#34;&#34;
        if not isinstance(plan_name, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            plan_name = plan_name.lower()

            if self.has_plan(plan_name):
                return Plan(
                    self._commcell_object,
                    plan_name,
                    self._plans[plan_name]
                )

            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                    plan_name)
            )

    def delete(self, plan_name):
        &#34;&#34;&#34;Deletes the plan from the commcell.

            Args:
                plan_name (str)  --  name of the plan to remove from the commcell

            Raises:
                SDKException:
                    if type of the plan name argument is not string

                    if failed to delete plan

                    if response is empty

                    if response is not success

                    if no plan exists with the given name
        &#34;&#34;&#34;
        if not isinstance(plan_name, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            plan_name = plan_name.lower()

            if self.has_plan(plan_name):
                plan_id = self._plans[plan_name]

                delete_plan = self._services[&#39;DELETE_PLAN&#39;] % (plan_id)

                flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, delete_plan)

                error_code = 0

                if flag:
                    if &#39;error&#39; in response.json():
                        if isinstance(response.json()[&#39;error&#39;], list):
                            error_code = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                        else:
                            error_code = response.json()[&#39;errorCode&#39;]

                    if error_code != 0:
                        o_str = &#39;Failed to delete plan&#39;
                        if isinstance(response.json()[&#39;error&#39;], list):
                            error_message = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]
                        else:
                            error_message = response.json()[&#39;errorMessage&#39;]
                        o_str += &#39;\nError: &#34;{0}&#34;&#39;.format(error_message)
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
                    else:
                        # initialize the plan again
                        # so the plan object has all the plan
                        self.refresh()
                        self._commcell_object.storage_policies.refresh()
                else:
                    response_string = self._update_response_(response.text)
                    raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
            else:
                raise SDKException(
                    &#39;Plan&#39;,
                    &#39;102&#39;,
                    &#39;No plan exists with name: {0}&#39;.format(plan_name)
                )

    def add_exchange_plan(self, plan_name: str, plan_sub_type: str = &#39;ExchangeUser&#39;, **kwargs):
        &#34;&#34;&#34;Adds a new exchange plan to the commcell.

            Args:
                plan_name           (str)   --  name of the new plan to add

                plan_sub_type       (str)   --  Type of plan to add - ExchangeUser or ExchangeJournal
                    Default: ExchangeUser

                kwargs              (dict)  --  Optional parameters for creating a plan
                    Accepted Values:
                        retain_msgs_received_time           (int)   -- Retain messages based on received time
                        retain_msgs_deletion_time           (int)   -- Retain messages based on deletion time
                        enable_cleanup_archive_mailbox      (bool)  -- Enable cleanup on archive mailbox
                        cleanup_msg_older_than              (int)   -- Cleanup messages older than
                        cleanup_msg_larger_than             (int)   -- Cleanup messages larger than
                        enable_content_search               (bool)  -- Enable content indexing
                        enable_archive_on_archive_mailbox   (bool)  -- Enable archive on archived mailbox
                        create_stubs                        (bool)  -- Create stubs during cleanup
                        prune_stubs                         (bool)  -- Prune stubs during cleanup
                        prune_msgs                          (bool)  -- Prune messages during cleanup
                        number_of_days_src_pruning          (int)   -- Number of days for source pruning
                        include_msgs_older_than             (int)   -- Include messages older than for archiving
                        include_msgs_larger_than            (int)   -- Inlcude messages larger than for archiving
                        exclude_folder_filter               (list)  -- Exclude folder filter
                        include_folder_filter               (list)  -- Include folder filter
                        enable_message_rules                (bool)  -- Enable message rules
                        truncate_body                       (bool)  -- Truncate body
                        truncate_body_to_size               (int)   -- Size to which body should be truncated (default: 1024)

            Returns:
                Plan object of the created plan

            Raises:
                SDKException:
                    if input parameters are incorrect

                    if Plan already exists

                    if error in creating the plan

        &#34;&#34;&#34;
        if plan_sub_type not in [&#39;ExchangeUser&#39;, &#39;ExchangeJournal&#39;]:
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;, &#34;Plan subtype should be ExchangeUser or ExchangeJournal.&#34;)
        elif self.has_plan(plan_name):
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(plan_name))
        request_json = self._get_plan_template(plan_sub_type)
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
        exch_retention = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbRetention&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;retentionPolicy&#39;]
        exch_retention[&#39;numOfDaysForMediaPruning&#39;] = kwargs.get(&#39;retain_msgs_received_time&#39;, -1)
        if plan_sub_type == &#39;ExchangeUser&#39;:
            exch_arch = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbArchiving&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;archivePolicy&#39;]
            exch_cleanup = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbCleanup&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;cleanupPolicy&#39;]
            exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsSelected&#39;].remove(&#39;Drafts&#39;)
            exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;].append(&#39;Drafts&#39;)
            if kwargs.get(&#39;enable_message_rules&#39;):
                exch_cleanup[&#39;enableMessageRules&#39;] = True
            exclude_folders = kwargs.get(&#39;exclude_folder_filter&#39;, [])
            for folder in exclude_folders:
                if folder in exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;]:
                    exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;].remove(folder)
                exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsSelected&#39;].append(folder)
            include_folders = kwargs.get(&#39;include_folder_filter&#39;, [])
            exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsSelected&#39;] = []
            for folder in include_folders:
                if folder in exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;]:
                    exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;].remove(folder)
                exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsSelected&#39;].append(folder)
            if kwargs.get(&#39;truncate_body&#39;):
                exch_cleanup[&#39;truncateBody&#39;] = True
                exch_cleanup[&#39;truncateBodyToSize&#39;] = kwargs.get(&#39;truncate_body_to_size&#39;, 1024)
            exch_cleanup[&#39;archiveMailbox&#39;] = kwargs.get(&#39;enable_cleanup_archive_mailbox&#39;, False)
            exch_cleanup[&#39;collectMsgsDaysAfter&#39;] = kwargs.get(&#39;cleanup_msg_older_than&#39;, 0)
            exch_cleanup[&#39;collectMsgsLargerThan&#39;] = kwargs.get(&#39;cleanup_msg_larger_than&#39;, 0)
            exch_cleanup[&#39;skipUnreadMsgs&#39;] = kwargs.get(&#39;skip_unread_msgs&#39;, False)
            exch_cleanup[&#39;collectMsgWithAttach&#39;] = kwargs.get(&#39;collect_msg_with_attach&#39;, False)
            exch_cleanup[&#39;createStubs&#39;] = kwargs.get(&#39;create_stubs&#39;, True)
            exch_cleanup[&#39;pruneStubs&#39;] = kwargs.get(&#39;prune_stubs&#39;, False)
            exch_cleanup[&#39;pruneMsgs&#39;] = kwargs.get(&#39;prune_msgs&#39;, False)
            exch_cleanup[&#39;numOfDaysForSourcePruning&#39;] = kwargs.get(&#39;number_of_days_src_pruning&#39;, 0)
            exch_arch[&#39;backupDeletedItemRetention&#39;] = kwargs.get(&#39;backup_deleted_item_retention&#39;, False)
            if &#39;includeDiscoveryHoldsFolder&#39; in kwargs:
                exch_arch[&#39;includeDiscoveryHoldsFolder&#39;] = kwargs.get(&#39;include_discovery_holds_folder&#39;)
            if &#39;includePurgesFolder&#39; in kwargs:
                exch_arch[&#39;includePurgesFolder&#39;] = kwargs.get(&#39;include_purges_folder&#39;)
            if &#39;includeVersionsFolder&#39; in kwargs:
                exch_arch[&#39;includeVersionsFolder&#39;] = kwargs.get(&#39;include_versions_folder&#39;)
            exch_arch[&#39;includeOnlyMsgsWithAttachemts&#39;] = kwargs.get(&#39;include_only_msgs_with_attachemts&#39;, False)
            exch_arch[&#39;includeMsgsOlderThan&#39;] = kwargs.get(&#39;include_msgs_older_than&#39;, 0)
            exch_arch[&#39;includeMsgsLargerThan&#39;] = kwargs.get(&#39;include_msgs_larger_than&#39;, 0)
            exch_arch[&#39;archiveMailbox&#39;] = kwargs.get(&#39;enable_archive_on_archive_mailbox&#39;, False)
            if &#39;retain_msgs_deletion_time&#39; in kwargs and kwargs.get(&#39;retain_msgs_deletion_time&#39;) &gt; 0:
                exch_retention[&#39;type&#39;] = 1
                exch_retention[&#39;numOfDaysForMediaPruning&#39;] = kwargs.get(&#39;retain_msgs_deletion_time&#39;, 0)
        else:
            exch_arch = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbJournal&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;journalPolicy&#39;]
        exch_arch[&#39;contentIndexProps&#39;][&#39;enableContentIndex&#39;] = kwargs.get(&#39;enable_content_search&#39;, False)

        headers = self._commcell_object._headers.copy()
        headers[&#39;LookupNames&#39;] = &#39;False&#39;

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._PLANS, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = None

                if &#39;errors&#39; in response_value:
                    error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                if error_code &gt; 1:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                    self.refresh()
                    self._commcell_object.storage_policies.refresh()
                    return self.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def create_server_plan(
        self, plan_name: str, backup_destinations: Union[List[dict], dict], schedules: Union[List[dict], dict]=None, **additional_params
    ) -&gt; object:
        &#34;&#34;&#34;
            Method to create a server plan using V4 API

            Args:
                plan_name (str)             --  Name of the plan to create

                backup_destinations (list/dict)  --  List of dictionaries representing backup destinations.
                Each dictionary should contain the following keys:
                    - &#39;storage_name&#39; (str): Name of the storage.
                    - &#39;retentionPeriodDays&#39; (int): Retention days for the copy (Default: 30 days)
                    - &#39;backupDestinationName&#39; (str): Name of the copy (Default: &#39;Primary&#39;)
                    - &#39;region_name&#39; (str, optional): Name of the region
                    To create elastic plans, region_name should be specified for all the copies

                Examples:
                # specify just storage and rest use default values
                {&#34;storage_name&#34;: &#34;Backup Storage&#34;}

                # specify storage name and retention period 
                {&#34;storage_name&#34;: &#34;Backup Storage&#34;, &#34;retentionPeriodDays&#34;: 30}

                # create plan with aux copies
                [
                    {&#34;storage_name&#34;: &#34;Backup Storage 1&#34;},
                    {&#34;storage_name&#34;: &#34;Backup Storage 2&#34;, &#34;backupDestinationName&#34;: &#34;Aux Copy 1&#34;},
                ]

                # create elastic plan
                {&#34;storage_name&#34;: &#34;Backup Storage&#34;, &#34;region_name&#34;: &#34;asia&#34;}

                # create elastic plan with multiple regions and multiple copies in each region
                [
                    {&#34;storage_name&#34;: &#34;Backup Storage 1&#34;, &#34;region_name&#34;: &#34;asia&#34;},
                    {&#34;storage_name&#34;: &#34;Backup Storage 2&#34;, &#34;region_name&#34;: &#34;asia&#34;, &#34;backupDestinationName&#34;: &#34;Aux Copy Name&#34;},
                    {&#34;storage_name&#34;: &#34;Backup Storage 3&#34;, &#34;region_name&#34;: &#34;africa&#34;},
                    {&#34;storage_name&#34;: &#34;Backup Storage 4&#34;, &#34;region_name&#34;: &#34;africa&#34;, &#34;backupDestinationName&#34;: &#34;Aux Copy Name&#34;}
                ]

                Note: Additional properties can be sent in the input to update the payload with the same exact key names. Refer API documentation for more details or use Command Center equivalent API.
                    
                schedules (list or dict, optional)  --  List of dictionaries representing backup schedules.
                Each dictionary should contain the following keys:
                    - backupType (str): Type of backup schedule
                    - forDatabasesOnly (bool): Indicates if the schedule is for databases only (Default: False)
                    - Additional properties to update the default schedule details.

                Examples:

                # create plan with default schedules
                None

                # create plan with no schedules
                []

                # create plan with schedules based on backup type and rest use default values
                {&#34;backupType&#34;: &#34;INCREMENTAL&#34;}
                {&#34;backupType&#34;: &#34;FULL&#34;}
                {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;}

                # specify agents for schedules
                {&#34;backupType&#34;: &#34;INCREMENTAL&#34;, &#34;forDatabasesOnly&#34;: False}
                {&#34;backupType&#34;: &#34;FULL&#34;, &#34;forDatabasesOnly&#34;: True}

                # create plan with multiple schedules
                [
                    {&#34;backupType&#34;: &#34;INCREMENTAL&#34;},
                    {&#34;backupType&#34;: &#34;FULL&#34;, &#34;forDatabasesOnly&#34;: True},
                    {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;}
                ]

                # advance properties for schedules
                {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;, &#34;scheduleOption&#34;: {&#34;useDiskCacheForLogBackups&#34;: True}}

                # specify pattern and start time for schedule
                {
                    &#34;backupType&#34;: &#34;INCREMENTAL&#34;,
                    &#34;schedulePattern&#34;: {
                        &#34;scheduleFrequencyType&#34;: &#34;DAILY&#34;,
                        &#34;startTime&#34;: 75600,
                        &#34;frequency&#34;: 1
                    }
                }

                Note: Additional properties can be sent in the input to update the payload with the same exact key names. Refer API documentation for more details or use Command Center equivalent API.
                    
                additional_params (dict)    --  Additional parameters for creating a plan
                    Accepted Values:
                        rpo_backup_window (list, optional): Backup window for RPO schedules.
                        full_backup_window (list, optional): Backup window for full backup schedules.
                        enable_backup_copy (bool, optional): Enable backup copy.
                        backup_copy_rpo_mins (int, optional): RPO for backup copy in minutes.
                        snap_retention_days (int, optional): Retention period in days.
                        snap_recovery_points (int, optional): Snap recovery point.
                        gcm_options (dict, optional): Global Configuration Manager options
                            commcells (list): List of commcell IDs to apply the plan (If not specified, applies to all commcells)

                        For Global Plans, backup_destinations input should be in the following format:

                        Example #1: For Single Copy
                            backup_destinations = {
                                &#34;storageTemplateTags&#34;: [
                                    {
                                        &#34;name&#34;: &#34;Tag Name&#34;,
                                        &#34;value&#34;: &#34;Tag Value&#34;
                                    }
                                ]
                            }

                        Example #2: For Multiple Copies
                        backup_destinations = [
                            {
                                &#39;storageTemplateTags&#39;: [
                                    {
                                        &#39;name&#39;: &#39;Tag Name 1&#39;, 
                                        &#39;value&#39;: &#39;Tag Value 1&#39;
                                    }
                                ]
                            }, 
                            {
                                &#39;backupDestinationName&#39;: &#39;Aux Copy Name&#39;, 
                                &#39;storageTemplateTags&#39;: [
                                    {
                                        &#39;name&#39;: &#39;Tag Name 2&#39;, 
                                        &#39;value&#39;: &#39;Tag Value 2&#39;
                                    }
                                ]
                            }
                        ]

        &#34;&#34;&#34;
        if schedules is None:
            schedules = [
                {&#39;backupType&#39;: &#39;INCREMENTAL&#39;},
                {&#39;backupType&#39;: &#39;TRANSACTIONLOG&#39;},
            ] # default schedules

        if isinstance(backup_destinations, dict):
            backup_destinations = [backup_destinations]

        if isinstance(schedules, dict):
            schedules = [schedules]

        request_json = _PayloadGeneratorPlanV4(self._commcell_object).get_create_server_plan_payload(
            plan_name, backup_destinations, schedules, **additional_params
        )

        if gcm_options := additional_params.get(&#39;gcm_options&#39;):
            service_commcell_ids = gcm_options.get(&#39;commcells&#39;, [])  # [{&#39;id&#39;: 1}, {&#39;id&#39;: 2}]
            apply_on_all_commcells = False if service_commcell_ids else True
            request_json = {
            &#34;globalConfigInfo&#34;: {
                &#34;commcells&#34;: service_commcell_ids,
                &#34;scope&#34;: &#34;&#34;,
                &#34;scopeFilterQuery&#34;: &#34;&#34;,
                &#34;applyOnAllCommCells&#34;: apply_on_all_commcells
            },
            &#34;plan&#34;: request_json
            }

        endpoint = self._V4_GLOBAL_PLANS if gcm_options else self._V4_PLANS
        flag, response = self._cvpysdk_object.make_request(&#39;POST&#39;, endpoint, request_json)

        if flag:
            if response.json():
                response_value = response.json()
                if &#39;errors&#39; in response_value:
                    error_message = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorMessage&#39;)
                    error_code = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorCode&#39;, 0)
                else:
                    error_message = response_value.get(&#39;errorMessage&#39;)
                    error_code = response_value.get(&#39;errorCode&#39;, 0)

                # corner case condition
                if error_code == 587207454:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Successfully created plan {response_value[&#34;plan&#34;][&#34;name&#34;]} &#39;
                                                      f&#39;with error: {error_message}&#39;)
                if error_code != 0:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Failed to create new V4 Server Plan\nError: &#34;{error_message}&#34;&#39;)
                
                plan_name = response_value[&#39;plan&#39;][&#39;name&#39;]

                self.refresh()
                self._commcell_object.policies.refresh()

                # refresh storage policies and schedule policies, if refreshing policies is not enough
                # self._commcell_object.storage_policies.refresh()
                # self._commcell_object.schedule_policies.refresh()

                return self.get(plan_name)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def add(self,
            plan_name,
            plan_sub_type,
            storage_pool_name=None,
            sla_in_minutes=1440,
            override_entities=None):
        &#34;&#34;&#34;Adds a new Plan to the CommCell.

        Args:
            plan_name           (str)   --  name of the new plan to add

            plan_sub_type       (str)   --  Type of plan to add

                &#34;Server&#34;    -   Server Plans

                &#34;FSServer&#34;  -   File System Plans

                &#34;Laptop&#34;    -   Laptop Plans

                &#34;ExchangeUser&#34;  -   Exchange Mailbox Plan


            storage_pool_name   (str)   --  name of the storage pool to be used for the plan

            sla_in_minutes      (int)   --  Backup SLA in hours

                default: 1440

            override_entities   (dict)  --  Specify the entities with respective
                                            inheritance values.

                default: None

                    {
                        &#39;privateEntities&#39;: [1, 4],

                        &#39;enforcedEntities&#39;: [256, 512, 1024]
                    }
                    - where,
                            privateEntities are set when respective entity overriding is required
                            enforcedEntities are set when respective entity overriding is not
                            allowed
                            left blank if overriding is optional

                    - entity IDs,
                            1    - Storage
                            4    - RPO/Schedules
                            256  - Windows content
                            512  - Unix content
                            1024 - Mac content

        Returns:
            object  -   instance of the Plan class created by this method

        Raises:
            SDKException:
                if input parameters are incorrect

                if Plan already exists

        &#34;&#34;&#34;
        if not (isinstance(plan_name, str) and
                isinstance(plan_sub_type, str)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            if self.has_plan(plan_name):
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(plan_name)
                )
        storage_pool_obj = self._commcell_object.storage_pools.get(
            storage_pool_name)
        is_dedupe = True
        if &#39;dedupDBDetailsList&#39; not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
            is_dedupe = False

        request_json = self._get_plan_template(plan_sub_type, &#34;MSP&#34;)
        if plan_sub_type == &#34;Laptop&#34;:
            del request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;accessPolicies&#39;]
            
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;rpoInMinutes&#39;] = sla_in_minutes
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name

        template_schedules = [schedule[&#39;subTask&#39;][&#39;subTaskName&#39;] for schedule in request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;]]
        if &#39;Synthetic Fulls&#39; in template_schedules:
            synth_full_index = template_schedules.index(&#39;Synthetic Fulls&#39;)
            request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][synth_full_index][&#39;options&#39;][&#39;commonOpts&#39;][
                &#39;automaticSchedulePattern&#39;].update({
                    &#39;minBackupInterval&#39;: 0,
                    &#39;maxBackupIntervalMinutes&#39;: 0,
                    &#39;minSyncInterval&#39;: 0,
                    &#39;minSyncIntervalMinutes&#39;: 0
                })
            request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][synth_full_index][&#39;options&#39;][&#39;commonOpts&#39;][
                &#39;automaticSchedulePattern&#39;][&#39;ignoreOpWindowPastMaxInterval&#39;] = True
        del request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;]
        request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
            &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
        }
        if is_dedupe:
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalDedupStore&#39;] = 1
        else:
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;enableDeduplication&#39;]
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;enableClientSideDedup&#39;]
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                &#39;useGlobalStoragePolicy&#39;: 1
                }

        # Configurations for database and snap addons
        if plan_sub_type == &#34;Server&#34; and &#39;database&#39; in request_json[&#39;plan&#39;]:
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalDedupStore&#39;] = 1
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0].pop(
                &#39;DDBPartitionInfo&#39;, None
            )
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalPolicy&#39;] = {
                    &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
                }
            
            # From SP36, snap copy wont be created by default during plan creation or present in the template
            if len(request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;]) &gt; 1:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                    &#39;useGlobalStoragePolicy&#39;: 1
                }
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                    &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
                }

        # Enable full backup schedule
        if plan_sub_type != &#34;Laptop&#34;:
            for subtask in request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;]:
                if &#39;flags&#39; in subtask[&#39;subTask&#39;] and subtask[&#39;subTask&#39;][&#39;flags&#39;] == 65536:
                    import copy
                    full_schedule = copy.deepcopy(subtask)
                    del copy
                    full_schedule[&#39;subTask&#39;].update({
                        &#39;subTaskName&#39;: &#39;Full backup schedule&#39;,
                        &#39;flags&#39;: 4194304
                    })
                    full_schedule[&#39;pattern&#39;].update({
                        &#39;freq_type&#39;: 4,
                        &#39;freq_interval&#39;: 1,
                        &#39;name&#39;: &#39;Full backup schedule&#39;,
                        &#39;active_end_time&#39;: 0
                    })
                    full_schedule[&#39;options&#39;][&#39;backupOpts&#39;][&#39;backupLevel&#39;] = &#39;FULL&#39;
                    request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;].append(full_schedule)
                    break

        if isinstance(override_entities, dict):
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: False
            }

            if &#39;enforcedEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = override_entities[
                    &#39;enforcedEntities&#39;]

            if &#39;privateEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = override_entities[
                    &#39;privateEntities&#39;]
        else:
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: True
            }

        headers = self._commcell_object._headers.copy()
        headers[&#39;LookupNames&#39;] = &#39;False&#39;

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._PLANS, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = None

                if &#39;errors&#39; in response_value:
                    error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                if error_code &gt; 1:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                    # initialize the plans again
                    # so that the plans object has all the plans
                    self.refresh()
                    # with plan delete storage policy associated might be deleted
                    # initialize storage policy again
                    self._commcell_object.storage_policies.refresh()

                    return self.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def get_eligible_plans(self, entities):
        &#34;&#34;&#34;Returns dict of plans that are eligible for the specified entities

            Args:
                entities    (dict)  - dictionary containing entities as keys and
                                        their respective IDs as values
                    {
                        &#39;clientId&#39;: id,
                        &#39;appId&#39;: id,
                        &#39;backupsetId&#39;: id
                    }

            Returns:
                dict                - dict of eligible plans

            Raises:
                SDKException:
                    if there is an error in the response
        &#34;&#34;&#34;
        query = &#39;&#39;
        for i in entities:
            query += &#39;{0}={1}&amp;&#39;.format(i, entities[i])
        requset_url = self._services[&#39;ELIGIBLE_PLANS&#39;] % query[0:-1]
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, requset_url)
        del query

        if flag:
            plans = {}

            if response.json() and &#39;plans&#39; in response.json():
                response_value = response.json()[&#39;plans&#39;]

                for temp in response_value:
                    temp_name = temp[&#39;plan&#39;][&#39;planName&#39;].lower()
                    temp_id = str(temp[&#39;plan&#39;][&#39;planId&#39;]).lower()
                    plans[temp_name] = temp_id

            return plans
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def get_supported_solutions(self):
        &#34;&#34;&#34;Method to get supported solutions for plans&#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(
            &#39;GET&#39;,
            self._services[&#39;PLAN_SUPPORTED_SOLUTIONS&#39;]
        )

        if not flag:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, self._update_response_(response.text))
        
        if response.json() and &#39;id&#39; in response.json():
            return {solution[&#39;name&#39;]: solution[&#39;id&#39;] for solution in response.json()[&#39;id&#39;]}
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        
    def refresh(self, **kwargs):
        &#34;&#34;&#34;
        Refresh the list of plans on this commcell.

            Args:
                **kwargs (dict):
                    mongodb (bool)  -- Flag to fetch plans cache from MongoDB (default: False).
                    hard (bool)     -- Flag to hard refresh MongoDB cache for this entity (default: False).
        &#34;&#34;&#34;
        mongodb = kwargs.get(&#39;mongodb&#39;, False)
        hard = kwargs.get(&#39;hard&#39;, False)

        self._plans = self._get_plans()
        if mongodb:
            self._plans_cache = self.get_plans_cache(hard=hard)

    def add_data_classification_plan(self, plan_name, index_server, target_app=TargetApps.FSO, **kwargs):
        &#34;&#34;&#34;Adds data classification plan to the commcell

            Args:

                plan_name           (str)       --  Name of plan

                index_server        (str)       --  Index server name


                target_app          (enum)      --  Target app for this plan
                                                        cvpysdk.activateapps.constants.TargetApps

                **kwargs

                    index_content       (bool)      --  Speifies whether to index content or not to index server

                    content_analyzer    (list)      --  list of Content analyzer client name

                    entity_list         (list)      --  list of entities which needs to be extracted

                    classifier_list     (list)      --  list of classifier which needs to be classified

                    enable_ocr          (bool)      --  specifies whether OCR is enabled or not

                    ocr_language        (int)       --  Language to be used when doing OCR
                                                            Default : English (Value-1)

                     Supported Languages:

                                    ENGLISH = 1,
                                    HEBREW = 2,
                                    SPANISH = 3,
                                    FRENCH = 4,
                                    ITALIAN = 5,
                                    DANISH = 6

                    include_docs        (str)       --  Include documents type separated by comma

                    exclude_path        (list)      --  List of paths which needs to be excluded

                    min_doc_size        (int)       --  Minimum document size in MB

                    max_doc_size        (int)       --  Maximum document size in MB

            Returns:

                object  - Plan object

            Raises:

                SDKException:

                        if input is not valid

                        if failed to create plan

                        if failed to find entities/classifier details

        &#34;&#34;&#34;
        extraction_policy_list = []
        if not (isinstance(plan_name, str)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        request_json = self._get_plan_template(&#34;DataClassification&#34;, &#34;MSP&#34;)
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;DC Plan Created from CvPySDK.&#34;
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
        request_json[&#39;plan&#39;][&#39;options&#39;] = {
            &#34;enableThreatAnalysis&#34;: False,
            &#34;targetApps&#34;: [
                target_app.value
            ]
        }
        if index_server is not None:
            # change to support SaaS and unification project
            index_server_client_id = self._commcell_object.index_servers.get(index_server).index_server_client_id
            request_json[&#39;plan&#39;][&#39;eDiscoveryInfo&#39;][&#39;analyticsIndexServer&#39;] = {
                &#39;clientId&#39;: index_server_client_id
            }
        if target_app.value == TargetApps.FSO.value:
            del request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;]
            request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;opType&#39;] = PlanConstants.INDEXING_ONLY_METADATA
        elif target_app.value == TargetApps.SDG.value:
            if &#39;content_analyzer&#39; in kwargs:
                # change to support SaaS and unification project
                ca_list = []
                for ca in kwargs.get(&#39;content_analyzer&#39;, []):
                    ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                    ca_list.append({
                        &#39;clientId&#39;: ca_client_id
                    })
                request_json[&#39;plan&#39;][&#39;eDiscoveryInfo&#39;][&#39;contentAnalyzerClient&#39;] = ca_list
            if &#39;entity_list&#39; not in kwargs and &#39;classifier_list&#39; not in kwargs:
                raise SDKException(&#39;Plan&#39;, &#39;104&#39;)
            activate_obj = self._commcell_object.activate
            if &#39;entity_list&#39; in kwargs or &#39;classifier_list&#39; in kwargs:
                entity_mgr_obj = activate_obj.entity_manager()
                # classifier is also an activate entity with type alone different so append this to entity list itself
                entity_list = []
                for entity in kwargs.get(&#39;entity_list&#39;, []):
                    entity_list.append(entity)
                for entity in kwargs.get(&#39;classifier_list&#39;, []):
                    entity_list.append(entity)
                for entity in entity_list:
                    entity_obj = entity_mgr_obj.get(entity)
                    extraction_policy_list.append(entity_obj.container_details)

            request_json[&#39;plan&#39;][&#39;eePolicy&#39;][&#39;policyType&#39;] = 3
            request_json[&#39;plan&#39;][&#39;eePolicy&#39;][&#39;flags&#39;] = 8
            request_json[&#39;plan&#39;][&#39;eePolicy&#39;][&#39;detail&#39;] = {
                &#34;eePolicy&#34;: {
                    &#34;copyPrecedence&#34;: 0,
                    &#34;extractionPolicyType&#34;: 6,  # container entities
                    &#34;extractionPolicy&#34;: {
                        &#34;extractionPolicyList&#34;: extraction_policy_list
                    }

                }
            }
            request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;opType&#39;] = kwargs.get(
                &#39;index_content&#39;, PlanConstants.INDEXING_ONLY_METADATA)
            if &#39;enable_ocr&#39; in kwargs:
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;enableImageExtraction&#39;] = kwargs.get(
                    &#39;enable_ocr&#39;, False)
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;ocrLanguages&#39;] = [kwargs.get(&#39;ocr_language&#39;, 1)]
            if &#39;include_docs&#39; in kwargs:
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
                    &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
            if &#39;min_doc_size&#39; in kwargs:
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
                    &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
            if &#39;max_doc_size&#39; in kwargs:
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                    &#39;maxDocSize&#39;] = kwargs.get(&#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
            if &#39;exclude_path&#39; in kwargs:
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                    &#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, PlanConstants.DEFAULT_EXCLUDE_LIST)

        headers = self._commcell_object._headers.copy()
        headers[&#39;LookupNames&#39;] = &#39;False&#39;

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._PLANS, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = None

                if &#39;errors&#39; in response_value:
                    error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                if error_code &gt; 1:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]
                    # initialize the plans again
                    self.refresh()

                    return self.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def add_risk_analysis_dc_plan(self, plan_name, app_type=PlanConstants.RAPlanAppType.CLASSIFIED,
                                  content_analyzer=None, index_server=None, **kwargs):
        &#34;&#34;&#34;Adds Risk Analysis data classification plan to the commcell
            Args:
                plan_name         (str)             --  Name of plan
                app_type          (RAPlanAppType)   --  Application Type of the plan
                content_analyzer  (list)            --  list of Content analyzer client name
                index_server      (str)             --  Index server name
                **kwargs
                    entity_list     (list)          --  list of entities which needs to be extracted
                    classifier_list (list)          --  list of classifier which needs to be classified
                    index_content   (RAPlanType)    --  Specifies whether to index content or not to index server
                    enable_ocr      (bool)          --  specifies whether OCR is enabled or not
                    ocr_language    (int)           --  Language to be used when doing OCR
                                                                Default : English (Value-1)
                        Supported Languages:
                                    ENGLISH = 1,
                                    HEBREW = 2,
                                    SPANISH = 3,
                                    FRENCH = 4,
                                    ITALIAN = 5,
                                    DANISH = 6
                    include_docs        (str)       --  Include documents type separated by comma
                    exclude_path        (list)      --  List of paths which needs to be excluded
                    min_doc_size        (int)       --  Minimum document size in MB
                    max_doc_size        (int)       --  Maximum document size in MB
            Returns:
                object  - Plan object
            Raises:
                SDKException:
                        if input is not valid
                        if failed to create plan
                        if failed to find entities/classifier details
        &#34;&#34;&#34;
        if not (isinstance(plan_name, str)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        request_json = copy.deepcopy(PlanConstants.CREATE_V4_DC_PLAN_REQ)

        request_json[&#39;name&#39;] = plan_name
        request_json[&#39;application&#39;] = app_type.value
        request_json[&#39;threatAnalysis&#39;] = False

        if index_server is not None:
            # change to support SaaS and unification project
            index_server_client_id = self._commcell_object.index_servers.get(index_server).index_server_client_id
            request_json[&#39;indexServer&#39;] = {
                &#39;id&#39;: index_server_client_id
            }
        if content_analyzer is not None:
            # change to support SaaS and unification project
            ca_list = []
            for ca in content_analyzer:
                ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                ca_list.append({
                    &#39;id&#39;: ca_client_id
                })
            request_json[&#39;contentAnalyzer&#39;] = ca_list
        if &#39;entity_list&#39; not in kwargs and &#39;classifier_list&#39; not in kwargs:
            raise SDKException(&#39;Plan&#39;, &#39;104&#39;)
        activate_obj = self._commcell_object.activate
        if &#39;entity_list&#39; in kwargs or &#39;classifier_list&#39; in kwargs:
            entity_mgr_obj = activate_obj.entity_manager()
            entity_list = []
            classifier_list = []
            entity_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;entity_list&#39;, []))
            for entity_id in entity_ids:
                entity_list.append({&#34;id&#34;: entity_id})
            request_json[&#39;entityDetection&#39;][&#34;entities&#34;] = entity_list

            classifier_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;classifier_list&#39;, []))
            for classifier_id in classifier_ids:
                classifier_list.append({&#34;id&#34;: classifier_id})
            request_json[&#39;entityDetection&#39;][&#34;classifiers&#34;] = classifier_list
        request_json[&#39;contentIndexing&#39;][&#34;searchType&#34;] = kwargs.get(
            &#39;index_content&#39;, PlanConstants.RAPlanSearchType.SEARCH_TYPE_ONLY_METADATA).value
        request_json[&#39;contentIndexing&#39;][&#34;extractTextFromImage&#34;] = kwargs.get(&#39;enable_ocr&#39;, False)
        if &#39;enable_ocr&#39; in kwargs:
            request_json[&#39;contentIndexing&#39;][&#34;contentLanguage&#34;] = kwargs.get(&#39;ocr_language&#39;, 1)
        request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
            &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
        request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
            &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
        request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;maxDocSize&#39;] = kwargs.get(
            &#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
        request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, [])

        headers = self._commcell_object._headers.copy()

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._V4_DC_PLANS, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = 0

                if &#39;errors&#39; in response_value:
                    error_code = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorCode&#39;, 0)
                    error_message = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorMessage&#39;)

                if error_code &gt; 1:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;name&#39;]
                    # initialize the plans again
                    self.refresh()

                    return self.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def get_plans_summary(self) -&gt; dict:

        &#34;&#34;&#34;Returns plan summary in response

        Returns:
            list - plans summary

        **NOTE - THE FUNCTION WOULD BE DEPRECATED IN SP40 AS GET_PLANS_CACHE() WILL RETURN THE SIMILAR RESPONSE**
        &#34;&#34;&#34;
        params = &#34;fl=plans.missingEntities%2Cplans.numAssocEntities%2Cplans.numCopies%2Cplans.parent&#34; \
                 &#34;%2Cplans.permissions%2Cplans.plan.planId%2Cplans.plan.planName%2Cplans.planStatusFlag%2Cplans.restrictions%2C&#34; \
                 &#34;plans.rpoInMinutes%2Cplans.subtype%2Cplans.type%2Cplans.targetApps%2Cplans.storageResourcePoolMaps.resources.resourcePool&#34; \
                 &#34;&amp;hardRefresh=true&#34;
        request_url = self._services[&#39;PLAN_SUMMARY&#39;] % params

        flags,response = self._cvpysdk_object.make_request(&#39;GET&#39;,request_url)

        if flags:
            if response.json():
                plans_summary = {entry.get(&#34;plan&#34;, {}).get(&#34;name&#34;, None): entry.get(&#34;associatedEntities&#34;, None)
                                 for entry in response.json()[&#34;plans&#34;]}
                return plans_summary
            else:
                raise SDKException(&#34;Plan&#34;, &#34;102&#34;, &#34;Failed to get plans summary&#34;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def add_office365_plan(self, plan_name)-&gt;None:
        &#34;&#34;&#34;
        Creates Office 365 plan
        Args:
            plan_name (str) : name of the plan to be created
        &#34;&#34;&#34;
        if not isinstance(plan_name, str):
            raise SDKException(&#39;Plan&#39;,&#39;102&#39;,&#39;Plan name should be passed as String&#39;)
        plan_sub_type = &#34;Office365&#34;
        plan_type = &#34;EXCHANGE&#34;
        office365_plan_template = self._get_plan_template(plan_type=plan_type,plan_sub_type=plan_sub_type)
        office365_plan_template[&#34;plan&#34;][&#34;summary&#34;][&#34;plan&#34;][&#34;planName&#34;] = plan_name
        flag, response = self._cvpysdk_object.make_request(&#34;POST&#34;, self._PLANS ,office365_plan_template)
        if flag:
            if response:
                if response.status_code == 200:
                    self.refresh()
                elif response.status_code == 400:
                    raise SDKException(&#34;Plan&#34;,&#34;102&#34;,&#34;Bad request&#34;)
                elif response.status_code == 401:
                    raise SDKException(&#34;Plan&#34;, &#34;102&#34;, &#34;User is unauthorized to perform create operation&#34;)
            else:
                raise SDKException(&#34;Plan&#34;,&#34;102&#34;,&#34;Response received is empty&#34;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def all_plans_prop(self)-&gt;list[dict]:
        &#34;&#34;&#34;
        Returns complete GET API response
        &#34;&#34;&#34;
        self._all_plans_props = self._get_plans(full_response=True).get(&#34;plans&#34;,[])
        return self._all_plans_props


class Plan(object):
    &#34;&#34;&#34;Class for performing operations for a specific Plan.&#34;&#34;&#34;

    def __init__(self, commcell_object, plan_name, plan_id=None):
        &#34;&#34;&#34;Initialize the Plan class instance.

            Args:
                commcell_object     (object)  --  instance of the Commcell class

                plan_name           (str)     --  name of the plan

                plan_id             (str)     --  id of the plan
                    default: None

            Returns:
                object - instance of the Plan class

        &#34;&#34;&#34;
        self._commcell_object = commcell_object

        self._cvpysdk_object = commcell_object._cvpysdk_object
        self._services = commcell_object._services
        self._update_response_ = commcell_object._update_response_

        self._plan_name = plan_name.lower()
        self._plan_properties = None

        if plan_id:
            self._plan_id = str(plan_id)
        else:
            self._plan_id = self._get_plan_id()

        self._PLAN = self._services[&#39;PLAN&#39;] % (self.plan_id)
        self._V4_PLAN = self._services[&#39;V4_SERVER_PLAN&#39;] % (self.plan_id)
        self._V4_DC_PLAN = self._services[&#39;V4_DC_PLAN&#39;] % (self.plan_id)
        self._PLAN_RPO = self._services[&#39;SERVER_PLAN_RPO&#39;] % (self.plan_id)
        self._ADD_USERS_TO_PLAN = self._services[&#39;ADD_USERS_TO_PLAN&#39;] % (self.plan_id)
        self._API_SECURITY = self._services[&#39;SECURITY_ASSOCIATION&#39;]
        self._API_SECURITY_ENTITY = self._services[&#39;ENTITY_SECURITY_ASSOCIATION&#39;]
        self._SERVER_PLAN_BACKUP_DESTINATION = self._services[&#39;V4_SERVER_PLAN_BACKUP_DESTINATION&#39;] % (self.plan_id)

        self._properties = None
        self._sla_in_minutes = None
        self._operation_window = None
        self._full_operation_window = None
        self._plan_type = None
        self._subtype = None
        self._security_associations = {}
        self._provider_domain_name = None
        self._resources = None
        self._storage_pool = None
        self._child_policies = {
            &#39;storagePolicy&#39;: None,
            &#39;schedulePolicy&#39;: {},
            &#39;subclientPolicyIds&#39;: []
        }
        self._storage_copies = {}
        self._all_copies = None
        self._user_group = None
        self._client_group = None
        self._override_entities = None
        self._parent_plan_name = None
        self._addons = []
        self._associated_entities = {}
        self._dc_plan_props = {}
        self._plan_entity_type = 158
        self._region_id = []
        self._applicable_solutions = []
        self._v4_plan_properties = {}
        self.refresh()
        self.plan_v4_helper = _PayloadGeneratorPlanV4(commcell=self._commcell_object)
        self._data_schedule_policy = None
        self._log_schedule_policy = None
        self._snap_schedule_policy = None

    def __repr__(self):
        &#34;&#34;&#34;String representation of the instance of this class.&#34;&#34;&#34;
        representation_string = &#39;Plan class instance for plan: &#34;{0}&#34;, of Commcell: &#34;{1}&#34;&#39;

        return representation_string.format(
            self._plan_name, self._commcell_object.commserv_name
        )

    def _get_plan_id(self):
        &#34;&#34;&#34;Gets the plan id associated with this plan.

            Returns:
                str - id associated with this plan
        &#34;&#34;&#34;
        plans = Plans(self._commcell_object)
        return plans.get(self.plan_name).plan_id

    def _get_v4_plan_properties(self) -&gt; Dict:
        &#34;&#34;&#34;Gets the properties of this plan from V4 API

            Returns:
                dict - dictionary consisting of the properties of this plan

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, self._V4_PLAN)

        if flag:
            if response.json():
                self._v4_plan_properties = response.json()
                return self._v4_plan_properties
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_plan_properties(self):
        &#34;&#34;&#34;Gets the plan properties of this plan.

            Returns:
                dict - dictionary consisting of the properties of this plan

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        plan_properties_url = &#39;{0}?propertyLevel=30&#39;.format(self._PLAN)
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, plan_properties_url)

        if flag:
            if response.json() and &#39;plan&#39; in response.json():
                self._plan_properties = response.json()[&#39;plan&#39;]

                if &#39;planName&#39; in self._plan_properties[&#39;summary&#39;][&#39;plan&#39;]:
                    self._plan_name = self._plan_properties[&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;].lower()

                if &#39;slaInMinutes&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._sla_in_minutes = self._plan_properties[&#39;summary&#39;][&#39;slaInMinutes&#39;]

                if &#39;type&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._plan_type = self._plan_properties[&#39;summary&#39;][&#39;type&#39;]

                if &#39;subtype&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._subtype = self._plan_properties[&#39;summary&#39;][&#39;subtype&#39;]

                if &#39;storage&#39; in self._plan_properties:
                    if &#39;copy&#39; in self._plan_properties[&#39;storage&#39;]:
                        self._all_copies = self._plan_properties.get(&#39;storage&#39;,{}).get(&#39;copy&#39;,[])
                        for copy in self._plan_properties[&#39;storage&#39;][&#39;copy&#39;]:
                            if &#39;useGlobalPolicy&#39; in copy:
                                storage_pool_name = copy[&#39;useGlobalPolicy&#39;][&#39;storagePolicyName&#39;].lower()
                            else:
                                storage_pool_name = copy[&#39;library&#39;][&#39;libraryName&#39;].lower()
                            self._storage_copies[copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]] = {
                                &#39;storagePool&#39;: storage_pool_name,
                                &#39;retainBackupDataForDays&#39;: copy[
                                    &#39;retentionRules&#39;][&#39;retainBackupDataForDays&#39;],
                                &#39;isDefault&#39;: False,
                                &#39;isSnapCopy&#39;: False,
                            }
                            if &#39;extendedRetentionRuleOne&#39; in copy[&#39;retentionRules&#39;]:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;extendedRetention&#39;] = (
                                        1,
                                        True,
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;rule&#39;],
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;endDays&#39;],
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;graceDays&#39;]
                                    ) 
                            if copy[&#39;isDefault&#39;] == 1:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;isDefault&#39;] = True

                            if copy[&#39;isSnapCopy&#39;] == 1:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;isSnapCopy&#39;] = True

                if self._subtype == 33554439:
                    if &#39;clientGroup&#39; in self._plan_properties[&#39;autoCreatedEntities&#39;]:
                        self._commcell_object.client_groups.refresh()
                        self._client_group = self._commcell_object.client_groups.get(
                            self._plan_properties[&#39;autoCreatedEntities&#39;][&#39;clientGroup&#39;][
                                &#39;clientGroupName&#39;]
                        )

                    if &#39;localUserGroup&#39; in self._plan_properties[&#39;autoCreatedEntities&#39;]:
                        self._user_group = self._plan_properties[&#39;autoCreatedEntities&#39;][
                            &#39;localUserGroup&#39;][&#39;userGroupName&#39;]

                if self._plan_properties[&#39;operationWindow&#39;][&#39;ruleId&#39;] != 0:
                    self._operation_window = self._plan_properties[&#39;operationWindow&#39;]
                else:
                    self._operation_window = None

                if self._plan_properties[&#39;fullOperationWindow&#39;][&#39;ruleId&#39;] != 0:
                    self._full_operation_window = self._plan_properties[&#39;fullOperationWindow&#39;]
                else:
                    self._full_operation_window = None

                if &#39;laptop&#39; in self._plan_properties:
                    if &#39;backupContent&#39; in self._plan_properties[&#39;laptop&#39;][&#39;content&#39;]:
                        self._child_policies[&#39;subclientPolicyIds&#39;].clear()
                        for ida in self._plan_properties[&#39;laptop&#39;][&#39;content&#39;][&#39;backupContent&#39;]:
                            if ida[&#39;subClientPolicy&#39;].get(&#39;backupSetEntity&#39;):
                                self._child_policies[&#39;subclientPolicyIds&#39;].append(
                                    ida[&#39;subClientPolicy&#39;][&#39;backupSetEntity&#39;][&#39;backupsetId&#39;]
                                )

                if (&#39;inheritance&#39; in self._plan_properties and
                        not self._plan_properties[&#39;inheritance&#39;][&#39;isSealed&#39;]):
                    temp_dict = self._plan_properties[&#39;inheritance&#39;]
                    del temp_dict[&#39;isSealed&#39;]
                    if &#39;enforcedEntities&#39; not in temp_dict:
                        temp_dict[&#39;enforcedEntities&#39;] = []
                    if &#39;privateEntities&#39; not in temp_dict:
                        temp_dict[&#39;privateEntities&#39;] = []
                    self._override_entities = temp_dict

                if &#39;parent&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._parent_plan_name = self._plan_properties[&#39;summary&#39;][&#39;parent&#39;][&#39;planName&#39;]

                if &#39;eePolicy&#39; in self._plan_properties:
                    extraction_policy = self._plan_properties[&#39;eePolicy&#39;]
                    if &#39;policyEntity&#39; in extraction_policy:
                        self._dc_plan_props[&#39;eePolicyId&#39;] = extraction_policy[&#39;policyEntity&#39;][&#39;policyId&#39;]
                    if &#39;detail&#39; in extraction_policy:
                        self._dc_plan_props[&#39;eePolicy&#39;] = extraction_policy[&#39;detail&#39;][&#39;eePolicy&#39;]

                if &#39;ciPolicy&#39; in self._plan_properties:
                    ci_policy = self._plan_properties[&#39;ciPolicy&#39;]
                    if &#39;policyEntity&#39; in ci_policy:
                        self._dc_plan_props[&#39;ciPolicyId&#39;] = ci_policy[&#39;policyEntity&#39;][&#39;policyId&#39;]
                    if &#39;detail&#39; in ci_policy:
                        self._dc_plan_props[&#39;ciPolicy&#39;] = ci_policy[&#39;detail&#39;][&#39;ciPolicy&#39;]

                if &#39;eDiscoveryInfo&#39; in self._plan_properties:
                    if &#39;analyticsIndexServer&#39; in self._plan_properties[&#39;eDiscoveryInfo&#39;]:
                        self._dc_plan_props[&#39;analyticsIndexServer&#39;] = self._plan_properties[&#39;eDiscoveryInfo&#39;][&#39;analyticsIndexServer&#39;]

                if &#39;options&#39; in self._plan_properties:
                    plan_options = self._plan_properties[&#39;options&#39;]
                    if &#39;targetApps&#39; in plan_options:
                        self._dc_plan_props[&#39;targetApps&#39;] = plan_options[&#39;targetApps&#39;]

                    if &#39;supportedWorkloads&#39; in plan_options:
                        self._applicable_solutions = [soln[&#39;solutionName&#39;] for soln in plan_options[&#39;supportedWorkloads&#39;].get(&#39;solutions&#39;, [])]

                if &#39;securityAssociations&#39; in self._plan_properties:
                    self._security_associations = {}
                    for association in self._plan_properties[&#39;securityAssociations&#39;].get(&#39;associations&#39;, []):
                        temp_key = None
                        if &#39;externalGroupName&#39; in association[&#39;userOrGroup&#39;][0]:
                            temp_key = &#39;{0}\\{1}&#39;.format(
                                    association[&#39;userOrGroup&#39;][0][&#39;providerDomainName&#39;],
                                    association[&#39;userOrGroup&#39;][0][&#39;externalGroupName&#39;]
                                )
                        elif &#39;userGroupName&#39; in association[&#39;userOrGroup&#39;][0]:
                            temp_key = association[&#39;userOrGroup&#39;][0][&#39;userGroupName&#39;]
                        else:
                            temp_key = association[&#39;userOrGroup&#39;][0][&#39;userName&#39;]
                        if &#39;role&#39; in association[&#39;properties&#39;]:
                            if temp_key in self._security_associations:
                                self._security_associations[temp_key].append(
                                    association[&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;]
                                )
                            else:
                                self._security_associations[temp_key] = [association[&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;]]
                    if &#39;tagWithCompany&#39; in self._plan_properties.get(&#39;securityAssociations&#39;):
                        self._provider_domain_name = self._plan_properties.get(&#39;securityAssociations&#39;, {}).\
                            get(&#39;tagWithCompany&#39;, {}).get(&#39;providerDomainName&#39;)

                if &#34;storageRules&#34; in self._plan_properties:
                    self._region_id = [x[&#34;regions&#34;][&#34;region&#34;][0][&#34;regionId&#34;]
                                       for x in self._plan_properties[&#34;storageRules&#34;][&#34;rules&#34;]]

                if &#39;storageResourcePoolMap&#39; in self._plan_properties:
                    self._resources = self._plan_properties.get(&#39;storageResourcePoolMap&#39;, {})[0].get(&#39;resources&#39;)

                self._get_associated_entities()

                return self._plan_properties
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def derive_and_add(self,
                       plan_name,
                       storage_pool_name=None,
                       sla_in_minutes=None,
                       override_entities=None):
        &#34;&#34;&#34;Derives the base plan based on the the inheritance properties to created a derived plan

            Args:
                plan_name           (str)        --  name of the new plan to add

                storage_pool_name   (str)   --  name of the storage pool to be used for the plan
                    default: None   :   when the name is left to default, it inherits the base plan
                                        storage pool if overriding is optional/not allowed

                sla_in_minutes        (int)        --  Backup SLA in hours
                    default: None   :   when the SLA is left to default, it inherits the base plan
                                        SLA if overriding is optional/not allowed

                override_entities   (dict)  --  Specify the entities with respective overriding.

                    default: None

                        {
                            &#39;privateEntities&#39;: [1, 4],

                            &#39;enforcedEntities&#39;: [256, 512, 1024]
                        }
                        - where,
                                privateEntities are set when respective entity overriding is must
                                enforcedEntities are set when respective entity overriding is
                                not allowed
                                left blank if overriding is optional

                        - entity IDs,
                                1    - Storage
                                4    - SLA/Schedules
                                256  - Windows content
                                512  - Unix content
                                1024 - Mac content


        Returns:
            object - instance of the Plan class created by this method

        Raises:
            SDKException:
                if plan name is in incorrect format

                if plan already exists

                if neccessary arguments are not passed

                if inheritance rules are not followed

        &#34;&#34;&#34;
        if not isinstance(plan_name, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;, &#39;Plan name must be string value&#39;)
        else:
            if self._commcell_object.plans.has_plan(plan_name):
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(
                        plan_name)
                )
        if self._override_entities is not None:
            request_json = self._commcell_object.plans._get_plan_template(
                str(self._subtype), &#34;MSP&#34;)

            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;parent&#39;] = {
                &#39;planId&#39;: int(self._plan_id)
            }

            is_dedupe = True
            if storage_pool_name is not None:
                storage_pool_obj = self._commcell_object.storage_pools.get(
                    storage_pool_name
                )
                if &#39;dedupDBDetailsList&#39; \
                        not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
                    is_dedupe = False
                storage_pool_id = int(storage_pool_obj.storage_pool_id)
                if is_dedupe:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;useGlobalDedupStore&#39;] = 1
                else:
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;enableDeduplication&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;enableClientSideDedup&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                        &#39;useGlobalStoragePolicy&#39;: 1
                    }
            else:
                storage_pool_id = None

            if 1 in self._override_entities[&#39;enforcedEntities&#39;]:
                if storage_pool_id is None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                        &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                    }
                    snap_copy_id = self.storage_policy.storage_policy_id
                else:
                    raise SDKException(
                        &#39;Plan&#39;, &#39;102&#39;, &#39;Storage is enforced by base plan, cannot be overridden&#39;)
            elif 1 in self._override_entities[&#39;privateEntities&#39;]:
                if storage_pool_id is not None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                        &#34;storagePolicyId&#34;: storage_pool_id
                    }
                    snap_copy_id = storage_pool_id
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Storage must be input&#39;)
            else:
                if storage_pool_id is not None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                        &#34;storagePolicyId&#34;: storage_pool_id
                    }
                    snap_copy_id = storage_pool_id
                else:
                    request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                        &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                    }
                    snap_copy_id = self.storage_policy.storage_policy_id

            if 4 in self._override_entities[&#39;enforcedEntities&#39;]:
                if sla_in_minutes is None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes
                else:
                    raise SDKException(
                        &#39;Plan&#39;, &#39;102&#39;, &#39;SLA is enforced by base plan, cannot be overridden&#39;)
            elif 4 in self._override_entities[&#39;privateEntities&#39;]:
                if sla_in_minutes is not None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;SLA must be input&#39;)
            else:
                if sla_in_minutes is not None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
                else:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes

            if isinstance(override_entities, dict):
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
                request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                    &#39;isSealed&#39;: False
                }
                for entity in self._override_entities[&#39;enforcedEntities&#39;]:
                    from functools import reduce
                    if override_entities and entity in reduce(
                            lambda i, j: i + j, override_entities.values()):
                        raise SDKException(
                            &#39;Plan&#39;, &#39;102&#39;, &#39;Override not allowed&#39;)
                if &#39;enforcedEntities&#39; in override_entities:
                    request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = (
                        override_entities[&#39;enforcedEntities&#39;]
                    )
                if &#39;privateEntities&#39; in override_entities:
                    request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = (
                        override_entities[&#39;privateEntities&#39;]
                    )
            else:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
                request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                    &#39;isSealed&#39;: True
                }

            if sla_in_minutes is not None:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                    &#39;definesEntity&#39;: True
                }
            else:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                    &#39;definesEntity&#39;: False
                }

            if isinstance(self._override_entities, dict):
                if (4 not in
                        self._override_entities[&#39;enforcedEntities&#39;] +
                        self._override_entities[&#39;privateEntities&#39;]):
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 0
                elif 4 in self._override_entities[&#39;enforcedEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 2
                elif 4 in self._override_entities[&#39;privateEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 1

            if storage_pool_id is not None:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                    &#39;definesEntity&#39;: True
                }
            else:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                    &#39;definesEntity&#39;: False
                }

            if isinstance(self._override_entities, dict):
                if (1 not in
                        self._override_entities[&#39;enforcedEntities&#39;] +
                        self._override_entities[&#39;privateEntities&#39;]):
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 0
                elif 1 in self._override_entities[&#39;enforcedEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 2
                elif 1 in self._override_entities[&#39;privateEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 1

            if self._subtype != 33554437:
                temp_defines_key = {
                    &#39;definesEntity&#39;: False
                }
                if isinstance(self._override_entities, dict):
                    if (not all(entity in
                                self._override_entities[&#39;enforcedEntities&#39;] +
                                self._override_entities[&#39;privateEntities&#39;]
                                for entity in [256, 512, 1024])):
                        temp_defines_key[&#39;overrideEntity&#39;] = 0
                    elif all(entity in self._override_entities[&#39;enforcedEntities&#39;]
                             for entity in [256, 512, 1024]):
                        temp_defines_key[&#39;overrideEntity&#39;] = 2
                    elif all(entity in self._override_entities[&#39;privateEntities&#39;]
                             for entity in [256, 512, 1024]):
                        temp_defines_key[&#39;overrideEntity&#39;] = 1
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientLin&#39;] = temp_defines_key
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientMac&#39;] = temp_defines_key
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientWin&#39;] = temp_defines_key

            if self._subtype == 33554437 and &#39;snap&#39; in self.addons and &#39;copy&#39; \
                    in request_json[&#39;plan&#39;][&#39;storage&#39;]:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                    &#39;storagePolicyId&#39;: snap_copy_id
                }
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                    &#39;useGlobalStoragePolicy&#39;: 1
                }

            add_plan_service = self._commcell_object.plans._PLANS
            headers = self._commcell_object._headers.copy()
            headers[&#39;LookupNames&#39;] = &#39;False&#39;

            flag, response = self._cvpysdk_object.make_request(
                &#39;POST&#39;, add_plan_service, request_json, headers=headers
            )

            if flag:
                if response.json():
                    response_value = response.json()
                    error_message = None
                    error_code = None

                    if &#39;errors&#39; in response_value:
                        error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                        error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                    # error_codes 0 - OK, 1 - plan without storage, 84 - restricted plan
                    if error_code not in [0, 1, 84]:
                        o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                            error_message
                        )
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                    if &#39;plan&#39; in response_value:
                        plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                        # initialize the plans again
                        # so that the plans object has all the plans
                        self._commcell_object.plans.refresh()

                        return self._commcell_object.plans.get(plan_name)
                    else:
                        o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                                 &#39;Please check the documentation for &#39;
                                 &#39;more details on the error&#39;).format(error_code)

                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
                else:
                    raise SDKException(&#39;Response&#39;, 102)
            else:
                response_string = self._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        else:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Inheritance disabled for plan&#39;)

    def modify_schedule(self, schedule_json, is_full_schedule=False):
        &#34;&#34;&#34;Modifies the incremental RPO schedule pattern of the plan with the given schedule json

            Args:
            schedule_json (dict) -- {
                    pattern : {}, -- Please refer SchedulePattern.create_schedule in schedules.py for the types of
                                     pattern to be sent

                                     eg: {
                                            &#34;freq_type&#34;: &#39;daily&#39;,
                                            &#34;active_start_time&#34;: time_in_%H/%S (str),
                                            &#34;repeat_days&#34;: days_to_repeat (int)
                                         }

                    options: {} -- Please refer ScheduleOptions.py classes for respective schedule options

                                    eg:  {
                                        &#34;maxNumberOfStreams&#34;: 0,
                                        &#34;useMaximumStreams&#34;: True,
                                        &#34;useScallableResourceManagement&#34;: True,
                                        &#34;totalJobsToProcess&#34;: 1000,
                                        &#34;allCopies&#34;: True,
                                        &#34;mediaAgent&#34;: {
                                            &#34;mediaAgentName&#34;: &#34;&lt;ANY MEDIAAGENT&gt;&#34;
                                        }
                                    }
                    }
            is_full_schedule (bool) --  Pass True if he schedule to be modified is the full backup schedule
        &#34;&#34;&#34;
        if is_full_schedule:
            try:
                schedule_id = list(filter(
                    lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
                ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
            except IndexError:
                raise IndexError(&#39;Full backup schedule not enabled&#39;)
        else:
            schedule_id = list(filter(
                lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 65536, self.schedule_policies[&#39;data&#39;]._subtasks
            ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
        self.schedule_policies[&#39;data&#39;].modify_schedule(
            schedule_json,
            schedule_id=schedule_id
        )
        self.refresh()

    def __handle_response(self, flag: bool, response: object, custom_error_message: str=None):
        &#34;&#34;&#34;Handles the response received from the server

        Args:
            flag (bool)                 --  boolean specifying whether the request was successful or not

            response (Response Object)  --  response received from the server

            custom_error_message (str)  --  custom error message to be used in case of failure

        Raises:
            SDKException:
                if response is empty

                if response is not success
        &#34;&#34;&#34;
        if flag:
            if response.json():
                response_value = response.json()
                error_info = response_value.get(&#39;error&#39;, response_value)
                error_message = error_info.get(&#39;errorMessage&#39;, &#39;&#39;)
                error_code = error_info.get(&#39;errorCode&#39;, 0)

                if error_code != 0:
                    if custom_error_message:
                        error_message = custom_error_message + &#39;\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, error_message)
                
                self.refresh()

            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def get_plan_properties(self) -&gt; Dict:
        &#34;&#34;&#34;
        Method to get the properties of this plan fetched from v4 API.
        
        Returns:
            Dict: A dictionary containing the properties of the plan fetched from the v4 API.
        &#34;&#34;&#34;
        return self._v4_plan_properties

    def get_storage_copy_details(self, copy_name: str, region_name: str = None) -&gt; Dict:
        &#34;&#34;&#34;Method to get the storage copy details of the given copy name and region name

        Args:
            copy_name (str): Name of the copy
            region_name (str, optional): Name of the region

        Returns:
            dict: Dictionary consisting of the properties of the given copy name
        &#34;&#34;&#34;
        backup_destinations = self._v4_plan_properties.get(&#39;backupDestinations&#39;, [])

        # Filter by region name
        if region_name:
            backup_destinations = list(filter(lambda item: item.get(&#39;region&#39;, {}).get(&#34;name&#34;) == region_name, backup_destinations))

        # Filter by copy name
        if copy_name:
            backup_destinations = list(filter(lambda item: item.get(&#39;planBackupDestination&#39;, {}).get(&#34;name&#34;) == copy_name, backup_destinations))

        if not backup_destinations:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;No copy found with name: [{copy_name}] and region: [{region_name}]&#39;)

        if len(backup_destinations) &gt; 1:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Multiple copies found with name: [{copy_name}] and region: [{region_name}]&#39;)
        
        copy_details = next(iter(backup_destinations), None)
        
        return copy.deepcopy(copy_details) # return a deep copy to avoid modifying the original properties

    def get_storage_copy_id(self, copy_name: str, region_name: str = None) -&gt; int:
        &#34;&#34;&#34;Gets the storage copy id of the given copy name

        Args:
            copy_name (str): Name of the copy
            region_name (str, optional): Name of the region

        Returns:
            int: Storage copy id of the given copy name
        &#34;&#34;&#34;
        copy_details = self.get_storage_copy_details(copy_name, region_name)
        return copy_details.get(&#39;planBackupDestination&#39;, {}).get(&#39;id&#39;, 0) if copy_details else 0

    def add_copy(self, copy_name: str, storage_pool: str, retention: int=30, extended_retention: dict=None, region: str=None) -&gt; None:
        &#34;&#34;&#34;
            Method to add an aux copy to the plan

            Args:
                copy_name   (str)   -   name of the copy that is being added
                storage_pool (str)  -   name of the storage pool that is to be used for the copy
                retention   (int)   -   retention period in days for the copy
                extended_retention (dict)  -   extended retention rules of a copy
                region      (str)   -   region name to which copy needs to be added

            Returns:
                None

            Raises:
                SDKException:
                -   if failed to add new copy to the plan
        &#34;&#34;&#34;
        copy_details = {
            &#34;backupDestinationName&#34;: copy_name,
            &#34;storage_name&#34;: storage_pool,
            &#34;retentionPeriodDays&#34;: retention
        }

        if extended_retention:
            copy_details[&#39;useExtendedRetentionRules&#39;] = True
            copy_details[&#34;extendedRetentionRules&#34;] = extended_retention

        request_json = {
            &#39;destinations&#39;: [self.plan_v4_helper.get_copy_payload(copy_details, is_aux_copy=True)]
        }
        # during add copy, region should be specified as the separate blob
        if region:
            request_json[&#39;region&#39;] = {&#34;id&#34;: int(self._commcell_object.regions.get(region).region_id)}

        flag, response = self._cvpysdk_object.make_request(&#39;POST&#39;, self._SERVER_PLAN_BACKUP_DESTINATION, request_json)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to add new copy to the plan : [{self.plan_name}]&#39;)

    def edit_copy(self, copy_name: str, new_retention_days: int = None, new_recovery_points: int = None, new_extended_retention: dict = None, current_region_name: str = None) -&gt; None:
        &#34;&#34;&#34;
        Method to edit a copy settings

        Args:
            copy_name (str): name of the copy that is being edited
            new_retention_days (int): new retention period in days for the copy
            new_recovery_points (int): new recovery points for the snap copy
            new_extended_retention (dict): new extended retention rules of a copy
            current_region_name (str): name of the region from which the copy needs to be edited

            Example:
                new_extended_retention =  {
                &#34;firstExtendedRetentionRule&#34;: {
                    &#34;isInfiniteRetention&#34;: False,
                    &#34;type&#34;: &#34;WEEKLY_FULLS&#34;,
                    &#34;retentionPeriodDays&#34;: 90
                }
        }
        &#34;&#34;&#34;
        copy_details = self.get_storage_copy_details(copy_name, current_region_name)
        copy_id = self.get_storage_copy_id(copy_name, current_region_name)
        is_snap_copy = copy_details.get(&#39;isSnapCopy&#39;, False)

        # input validation
        if new_retention_days is not None and new_recovery_points is not None:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Both retention days and recovery points cannot be set at the same time&#39;)

        if new_recovery_points and not is_snap_copy:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Recovery points can be set only for snap copy&#39;)

        # copy the old details to the required payload first
        required_props = [&#39;retentionPeriodDays&#39;, &#39;retentionRuleType&#39;, &#39;useExtendedRetentionRules&#39;, &#39;extendedRetentionRules&#39;]
        new_retention_rules = {key: copy_details[key] for key in required_props if key in copy_details}

        # update the payload based on the input
        if new_retention_days is not None:
            new_retention_rules.update({&#39;retentionPeriodDays&#39;: new_retention_days, &#39;retentionRuleType&#39;: &#34;RETENTION_PERIOD&#34;})

        if new_recovery_points is not None:
            new_retention_rules.update({&#39;retentionPeriodDays&#39;: new_recovery_points, &#39;retentionRuleType&#39;: &#34;SNAP_RECOVERY_POINTS&#34;})

        if new_extended_retention:
            new_retention_rules.update({&#39;useExtendedRetentionRules&#39;: True, &#39;extendedRetentionRules&#39;: new_extended_retention})

        # special property that needs to be sent during edit
        new_retention_rules[&#39;fullBackupTypesToBeRetained&#39;] = &#39;FIRST&#39;

        request_json = {&#39;retentionRules&#39;: new_retention_rules}

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._services[&#39;V5_SERVER_PLAN_COPY&#39;] % (self.plan_id, copy_id), request_json)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to edit copy settings for the plan : [{self.plan_name}] Copy: [{copy_name}] Region: [{current_region_name}]&#39;)

    def delete_copy(self, copy_name: str, region_name: str=None) -&gt; None:
        &#34;&#34;&#34;
        Method to remove a copy from the plan

        Args:
            copy_name (str)   -   name of the copy to be removed
            region_name (str) -   name of the region from which the copy needs to be removed

        Returns:
            None

        Raises:
            SDKException:
                -   if failed to remove the copy from the plan
        &#34;&#34;&#34;
        copy_id = self.get_storage_copy_id(copy_name, region_name)

        flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, self._services[&#39;V4_SERVER_PLAN_COPY&#39;] % (self.plan_id, copy_id))

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to remove copy from the plan: [{self.plan_name}]&#39;)

    def add_region(self, region_name: str) -&gt; None:
        &#34;&#34;&#34;
        Method to add a region to the plan

        Args:
            region_name (str)   -   name of the region that is being added

        Returns:
            None

        Raises:
            SDKException:
                -   if failed to add new region to the plan
        &#34;&#34;&#34;
        region_id = self._commcell_object.regions.get(region_name).region_id

        request_json = {
            &#34;regionToConfigure&#34;: {
                &#34;id&#34;: int(region_id)
            }
        }

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_PLAN, request_json)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to add new region to the plan : [{self.plan_name}]&#39;)

    def remove_region(self, region_name: str) -&gt; None:
        &#34;&#34;&#34;
        Method to remove a region from the plan

        Args:
            region_name (str)   -   name of the region that is being removed

        Returns:
            None

        Raises:
            SDKException:
                -   if failed to remove the region from the plan
        &#34;&#34;&#34;
        region_id = self._commcell_object.regions.get(region_name).region_id

        flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, self._services[&#39;SERVER_PLAN_REGIONS&#39;] % (self.plan_id, region_id))

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to remove region from the plan: [{self.plan_name}]&#39;)

    def get_schedule_properties(self, schedule_filter: dict) -&gt; dict:
        &#34;&#34;&#34;
        Method to get the schedule properties of the plan

        Args:
            schedule_filter (dict) - dictionary containing the filter criteria for the schedule

            Example for schedule filter:

            # select the full backup schedule
                {&#34;backupType&#34;: &#34;FULL&#34;}

            # select the schedule where backup type is incremental and schedule is applicable to all agents
            {&#34;backupType&#34;: &#34;INCREMENTAL&#34;, &#34;forDatabasesOnly&#34;: False}

        Returns:
            dict - schedule properties of the plan

        Raises:
            SDKException:
                - if no schedule is found with the provided filter
                - if multiple schedules are found with the provided filter
        &#34;&#34;&#34;
        schedules = self._v4_plan_properties[&#39;rpo&#39;][&#39;backupFrequency&#39;][&#39;schedules&#39;]
        filtered_schedules = [schedule for schedule in schedules if all(schedule.get(key) == value for key, value in schedule_filter.items())]

        if not filtered_schedules:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;No schedule found with the provided filter: {schedule_filter} for plan: [{self.plan_name}]&#39;)
        
        if len(filtered_schedules) &gt; 1:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Multiple schedules found with the provided filter: {schedule_filter} for plan: [{self.plan_name}]&#39;)

        return copy.deepcopy(filtered_schedules[0]) # return a deep copy to avoid modifying the original schedule properties

    def add_schedule(self, schedule_options: dict) -&gt; None:
        &#34;&#34;&#34;
        Method to add a new schedule to the plan

        Args:
            schedule_options (dict) - schedule options to be added (backupType is mandatory)

            Note: To prepare advanced schedule options, refer to the API documentation or Command Center equivalent API

            Example:

            # create schedule based on backup type and rest use default values
            {&#34;backupType&#34;: &#34;INCREMENTAL&#34;}
            {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;}

            # create schedule with advanced properties
            {
                &#34;backupType&#34;: &#34;FULL&#34;, 
                &#34;schedulePattern&#34;: {
                    &#34;scheduleFrequencyType&#34;: &#34;DAILY&#34;,
                    &#34;startTime&#34;: 75600,
                    &#34;frequency&#34;: 1
                    }
            }

            # specify agents for schedules
            {&#34;backupType&#34;: &#34;INCREMENTAL&#34;, &#34;forDatabasesOnly&#34;: False}
            {&#34;backupType&#34;: &#34;FULL&#34;, &#34;forDatabasesOnly&#34;: True}

            # advance properties for schedules
            {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;, &#34;scheduleOption&#34;: {&#34;useDiskCacheForLogBackups&#34;: True}}

        Returns:
            None

        Raises:
            SDKException:
                - if failed to add the schedule to the plan
        &#34;&#34;&#34;
        schedule_payload = self.plan_v4_helper.get_schedule_payload(schedule_options)
        
        payload = {
            &#34;backupFrequency&#34;: {
                &#34;schedules&#34;: [schedule_payload]
            }
        }
        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._PLAN_RPO, payload)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to add new schedule to the plan: [{self.plan_name}]&#39;)    

    def edit_schedule(self, schedule_options: dict, schedule_filter: dict) -&gt; None:
        &#34;&#34;&#34;
        Method to edit the schedule options of the plan

        Args:
            schedule_options (dict) - schedule options to be edited
            schedule_filter (dict)  - schedule for which the options are to be edited

            Refer to the add_schedule method for the format of the schedule options

            Refer to the get_schedule_properties method for the format of the schedule filter

        Returns:
            None

        Raises:
            SDKException:
                - if failed to edit the schedule options of the plan
        &#34;&#34;&#34;
        schedule_payload = self.get_schedule_properties(schedule_filter)

        schedule_payload[&#39;scheduleOperation&#39;] = &#39;MODIFY&#39;
        # update the payload with the new provided options
        schedule_payload = self.plan_v4_helper.update_payload(schedule_payload, schedule_options)

        payload = {
            &#34;backupFrequency&#34;: {
                &#34;schedules&#34;: [schedule_payload]
            }
        }

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._PLAN_RPO, payload)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to edit schedule options for the plan: [{self.plan_name}]&#39;)

    def delete_schedule(self, schedule_filter: dict) -&gt; None:
        &#34;&#34;&#34;
        Method to delete the schedule from the plan

        Args:
            schedule_filter (dict)  - schedule to be deleted

            Refer to the get_schedule_properties method for the format of the schedule filter

        Returns:
            None

        Raises:
            SDKException:
                - if failed to edit the schedule options of the plan
        &#34;&#34;&#34;
        schedule_payload = self.get_schedule_properties(schedule_filter)
        schedule_payload[&#39;scheduleOperation&#39;] = &#39;DELETE&#39;

        payload = {
            &#34;backupFrequency&#34;: {
                &#34;schedules&#34;: [schedule_payload]
            }
        }

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._PLAN_RPO, payload)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to delete schedule from the plan: [{self.plan_name}]&#39;)

    def edit_snapshot_options(self, enable_backup_copy:bool=True, backup_copy_rpo: int=None) -&gt; None:
        &#34;&#34;&#34;
        Method to edit the snapshot options of the plan

        Args:
            enable_backup_copy (bool)   -   enable backup copy for the plan

            backup_copy_rpo (int)       -   backup copy RPO for the plan

        Returns:
            None

        Raises:
            SDKException:
                -   if failed to edit the snapshot options of the plan
        &#34;&#34;&#34;
        request_json = {
            &#34;snapshotOptions&#34;: {
                &#34;enableBackupCopy&#34;: enable_backup_copy
            }
        }

        if backup_copy_rpo:
            request_json[&#34;snapshotOptions&#34;][&#34;backupCopyRPOMins&#34;] = backup_copy_rpo

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_PLAN, request_json)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to edit snapshot settings for the plan : [{self.plan_name}]&#39;)

    def add_storage_copy(self, copy_name, storage_pool, retention=30, extended_retention=None):
        &#34;&#34;&#34;Add a storage copy as backup destination to this plan
            Args:
                copy_name   (str)   -   name of the copy that is being added

                storage_pool (str)  -   name of the storage pool for the copy to be added

                retention   (int)   -   retention period in days for the copy

                extended_retention (tuple)  -   extended retention rules of a copy
                                                Example: [1, True, &#34;EXTENDED_ALLFULL&#34;, 0, 0]
            Returns:
                dict    -   dictionary of all copies of this plan
        &#34;&#34;&#34;
        if isinstance(copy_name, str) and isinstance(storage_pool, str):
            if not self.storage_policy.has_copy(copy_name):
                self.storage_policy.create_secondary_copy(
                    copy_name,
                    global_policy=storage_pool
                )
                self.storage_policy.get_copy(copy_name).copy_retention = (retention, 0, 0)
                if extended_retention:
                    self.storage_policy.get_copy(
                        copy_name).extended_retention_rules = extended_retention
                self.refresh()
                return self.storage_copies
            else:
                err_msg = f&#39;Storage Policy copy &#34;{copy_name}&#34; already exists.&#39;
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Copy name and storage pool name must be a string.&#39;
            )

    def disable_full_schedule(self):
        &#34;&#34;&#34;Disable the full backup schedule of the plan&#34;&#34;&#34;
        try:
            self.schedule_policies[&#39;data&#39;].delete_schedule(schedule_id=list(filter(
                lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
            ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;])
        except IndexError:
            raise IndexError(&#39;Full backup schedule not enabled&#39;)

    def edit_association(self, entities, new_plan=None):
        &#34;&#34;&#34;Reassociates or dissociates the entities from this plan
            Args:
                entities    (list)  --  list containing entity objects whose plan association must be edited
                                        Eg: [
                                            {
                                                &#34;clientName&#34;: &#34;client&#34;,
                                                &#34;subclientName&#34;: &#34;subclient&#34;,
                                                &#34;backupsetName&#34;: &#34;backupset&#34;,
                                                &#34;appName&#34;: &#34;app&#34;
                                            }
                                        ]

                new_plan    (str)   --  new plan to which the associated entities must be reassociated with

            Raises:
                SDKException
                    if plan not found
        &#34;&#34;&#34;
        req_json = {
            &#39;plan&#39;: {
                &#39;planName&#39;: self.plan_name
            },
            &#39;entities&#39;: entities
        }
        if new_plan is not None:
            if self._commcell_object.plans.has_plan(new_plan):
                req_json.update({
                    &#39;planOperationType&#39;: &#39;OVERWRITE&#39;,
                    &#39;newPlan&#39;: {
                        &#39;planName&#39;: new_plan
                    }
                })
            else:
                SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                    new_plan)
                )
        else:
            req_json.update({
                &#39;planOperationType&#39;: &#39;DELETE&#39;
            })
        req_url = self._services[&#39;ASSOCIATED_ENTITIES&#39;] % (self._plan_id)
        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, req_url, req_json
        )

        if flag:
            if &#39;response&#39; in response.json():
                error_code = str(response.json()[&#34;response&#34;][0][&#34;errorCode&#34;])

                if error_code == &#34;0&#34;:
                    self.refresh()
                    return
            else:
                error_message = str(response.json()[&#34;errorMessage&#34;])
                o_str = &#39;Failed to edit plan associated entities\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_message))
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _update_plan_props(self, props):
        &#34;&#34;&#34;Updates the properties of the plan

            Args:
                props   (dict)  --  dictionary containing the properties to be updated
                                    {
                                        &#39;planName&#39;: &#39;NewName&#39;
                                    }

            Raises:
                SDKException
                    if there is failure in updating the plan
        &#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, self._PLAN, props
        )
        if flag:
            if response.json():
                error_code = str(response.json()[&#34;errors&#34;][0][&#34;status&#34;][&#34;errorCode&#34;])
                error_message = str(response.json()[&#34;errors&#34;][0][&#34;status&#34;][&#34;errorMessage&#34;])

                if error_code == &#34;0&#34;:
                    self.refresh()
                    return (True, error_code)
                else:
                    return (False, error_code, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_associated_entities(self):
        &#34;&#34;&#34;Gets all the backup entities associated with the plan.

            Returns:
                dict - dictionary containing list of entities that are
                       associated with the plan.

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        request_url = self._services[&#39;ASSOCIATED_ENTITIES&#39;] % (self._plan_id)
        flag, response = self._cvpysdk_object.make_request(
            &#39;GET&#39;, request_url
        )

        if flag:
            if response.json() and &#39;entities&#39; in response.json():
                self._associated_entities = response.json()[&#39;entities&#39;]
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def plan_id(self):
        &#34;&#34;&#34;Treats the plan id as a read-only attribute.&#34;&#34;&#34;
        return self._plan_id

    @property
    def plan_name(self):
        &#34;&#34;&#34;Treats the plan name as a read-only attribute.&#34;&#34;&#34;
        return self._plan_name

    @plan_name.setter
    def plan_name(self, value: str):
        &#34;&#34;&#34;modifies the plan name&#34;&#34;&#34;
        # use v4 API for server plans
        if self.subtype == 33554437:
            req_json = {
                &#34;newName&#34;: value
            }

            flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_PLAN, req_json)

            self.__handle_response(flag, response, custom_error_message=f&#39;Failed to update the plan name: [{self._plan_name}]&#39;)
            return

        if isinstance(value, str):
            req_json = {
                &#39;summary&#39;: {
                    &#39;plan&#39;: {
                        &#39;planName&#39;: value
                    }
                }
            }
            resp = self._update_plan_props(req_json)

            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan name\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan name must be a string value&#39;
            )

    @property
    def sla_in_minutes(self):
        &#34;&#34;&#34;Treats the plan SLA/RPO as a read-only attribute.&#34;&#34;&#34;
        return self._sla_in_minutes

    @sla_in_minutes.setter
    def sla_in_minutes(self, value):
        &#34;&#34;&#34;Modifies the plan SLA/RPO&#34;&#34;&#34;
        if isinstance(value, int):
            req_json = {
                &#39;summary&#39;: {
                    &#39;slaInMinutes&#39;: value
                }
            }
            resp = self._update_plan_props(req_json)

            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan SLA\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan SLA must be an int value&#39;
            )

    @property
    def operation_window(self):
        &#34;&#34;&#34;Treats the plan incremental operation window as a read-only attribute&#34;&#34;&#34;
        return self._operation_window

    @operation_window.setter
    def operation_window(self, value):
        &#34;&#34;&#34;Modifies the incremental operation window of the plan

            Args:
                value   (list)    --  list of time slots for setting the backup window

                value   (None)      --  set value to None to clear the operation window

            Raises:
                SDKException:
                    if the input is incorrect

                    if the operation window configuration fails
        &#34;&#34;&#34;
        if isinstance(value, list):
            req_json = {
                &#34;operationWindow&#34;: {
                    &#34;operations&#34;: [
                        2,
                        4
                    ],
                    &#34;dayTime&#34;: value
                }
            }
            resp = self._update_plan_props(req_json)
            if resp[0]:
                self.refresh()
                return
            else:
                o_str = &#39;Failed to update the operation window\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        elif value is None:
            self._commcell_object.operation_window.delete_operation_window(
                rule_id=self._operation_window[&#39;ruleId&#39;]
            )
            self.refresh()
            return
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan operation window must be a list value or None&#39;
            )

    @property
    def full_operation_window(self):
        &#34;&#34;&#34;Treats the plan full backup operation window as a read-only attribute&#34;&#34;&#34;
        return self._full_operation_window

    @full_operation_window.setter
    def full_operation_window(self, value):
        &#34;&#34;&#34;Modifies the full backup operation window of the plan

            Args:
                value   (list)    --  list of time slots for setting the backup window

                value   (None)      --  set value to None to clear the operation window

            Raises:
                SDKException:
                    if the input is incorrect

                    if the operation window configuration fails
        &#34;&#34;&#34;
        if isinstance(value, list):
            req_json = {
                &#34;operationWindow&#34;: {
                    &#34;operations&#34;: [
                        1,
                    ],
                    &#34;dayTime&#34;: value
                }
            }
            resp = self._update_plan_props(req_json)
            if resp[0]:
                self.refresh()
                return
            else:
                o_str = &#39;Failed to update the full operation window\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        elif value is None:
            self._commcell_object.operation_window.delete_operation_window(
                rule_id=self._full_operation_window[&#39;ruleId&#39;]
            )
            self.refresh()
            return
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan full operation window must be a list value or None&#39;
            )

    @property
    def plan_type(self):
        &#34;&#34;&#34;Treats the plan type as a read-only attribute.&#34;&#34;&#34;
        return self._plan_type

    @property
    def subtype(self):
        &#34;&#34;&#34;Treats the plan subtype as a read-only attribute.&#34;&#34;&#34;
        return self._subtype

    @property
    def override_entities(self):
        &#34;&#34;&#34;Treats the plan override_entities as a read-only attribute.&#34;&#34;&#34;
        return self._override_entities

    @override_entities.setter
    def override_entities(self, value):
        &#34;&#34;&#34;Sets the override restrictions for the plan&#34;&#34;&#34;
        req_json = {
            &#34;inheritance&#34;: {
                &#34;isSealed&#34;: False,
                &#34;enforcedEntitiesOperationType&#34;: 1,
                &#34;privateEntitiesOperationType&#34;: 1
            }
        }
        if isinstance(value, dict):
            req_json[&#39;inheritance&#39;].update(value)
            resp = self._update_plan_props(req_json)
            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan override restrictions\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Override restrictions must be defined in a dict&#39;
            )

    def __set_storage_policy(self):
        &#34;&#34;&#34;Method to set the storage policy of the plan&#34;&#34;&#34;
        self._commcell_object.storage_policies.refresh()
        storage_policy_name = self._plan_properties.get(&#39;storage&#39;, {}).get(&#39;storagePolicy&#39;, {}).get(&#39;storagePolicyName&#39;)
        if storage_policy_name and self._commcell_object.storage_policies.has_policy(storage_policy_name):
            self._child_policies[&#39;storagePolicy&#39;] = self._commcell_object.storage_policies.get(storage_policy_name)
        else:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Failed to fetch storage policy: {storage_policy_name}&#39;)

    @property
    def storage_policy(self):
        &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
        if not self._child_policies.get(&#39;storagePolicy&#39;):
            self.__set_storage_policy()

        return self._child_policies.get(&#39;storagePolicy&#39;)

    @property
    def all_copies(self) -&gt; list:
        &#34;&#34;&#34;
        Treats the plan&#39;s all storage copies as a read-only attribute

        Returns:
            list -- list of all the copies
        &#34;&#34;&#34;
        return self._all_copies

    @property
    def storage_copies(self):
        &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
        return self._storage_copies

    def __set_schedule_policies(self):
        &#34;&#34;&#34;Sets the schedule policies for the plan&#34;&#34;&#34;
        self._commcell_object.schedule_policies.refresh()
        data_schedule_policy_exists = self._plan_properties.get(&#39;schedule&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;)
        log_schedule_policy_exists = self._plan_properties.get(&#39;database&#39;, {}).get(&#39;scheduleLog&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;)
        snap_schedule_policy_exists = self._plan_properties.get(&#39;snapInfo&#39;, {}).get(&#39;snapTask&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;)

        if data_schedule_policy_exists:
            self._child_policies[&#39;schedulePolicy&#39;][&#39;data&#39;] = self.data_schedule_policy

        if log_schedule_policy_exists:
            self._child_policies[&#39;schedulePolicy&#39;][&#39;log&#39;] = self.log_schedule_policy

        if snap_schedule_policy_exists:
            self._child_policies[&#39;schedulePolicy&#39;][&#39;snap&#39;] = self.snap_schedule_policy

    @property
    def schedule_policies(self):
        &#34;&#34;&#34;Treats the plan schedule policies as read-only attribute&#34;&#34;&#34;
        if not self._child_policies.get(&#39;schedulePolicy&#39;):
            self.__set_schedule_policies()

        return self._child_policies.get(&#39;schedulePolicy&#39;)

    def __get_schedule_policy(self, policy_type: str) -&gt; object:
        &#34;&#34;&#34;
        Returns the schedule policy object of the given policy type

        Args:
            policy_type (str)  --  type of schedule policy to be fetched
                            Eg: &#39;data&#39;, &#39;log&#39;, &#39;snap&#39;

        Returns:
            object  --  schedule policy object
        &#34;&#34;&#34;
        policy_name = &#39;&#39;
        policy_type = policy_type.lower()

        if policy_type == &#39;data&#39;:
            policy_name = self._plan_properties.get(&#39;schedule&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;, &#39;&#39;)
        elif policy_type == &#39;log&#39;:
            policy_name = self._plan_properties.get(&#39;database&#39;, {}).get(&#39;scheduleLog&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;, &#39;&#39;)
        elif policy_type == &#39;snap&#39;:
            policy_name = self._plan_properties.get(&#39;snapInfo&#39;, {}).get(&#39;snapTask&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;, &#39;&#39;)
        else:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid schedule policy type&#39;)

        schedule_policies = self._commcell_object.schedule_policies

        if not schedule_policies.has_policy(policy_name):
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Failed to fetch schedule policies&#39;)

        return schedule_policies.get(policy_name)

    @property
    def data_schedule_policy(self) -&gt; object:
        &#34;&#34;&#34;
            Treats the plan data scheduler policy as read-only attribute

            Returns:
                object  -   data schedule policy object
        &#34;&#34;&#34;
        if not self._data_schedule_policy:
            self._data_schedule_policy = self.__get_schedule_policy(&#39;data&#39;)
        return self._data_schedule_policy

    @property
    def log_schedule_policy(self) -&gt; object:
        &#34;&#34;&#34;
            Treats the plan log schedule policy as read-only attribute

            Returns:
                object  -   log schedule policy object
        &#34;&#34;&#34;
        if not self._log_schedule_policy:
            self._log_schedule_policy = self.__get_schedule_policy(&#39;log&#39;)
        return self._log_schedule_policy

    @property
    def snap_schedule_policy(self) -&gt; object:
        &#34;&#34;&#34;
            Treats the plan snap schedule policy as read-only attribute

            Returns:
                object  -   snap schedule policy object
        &#34;&#34;&#34;
        if not self._snap_schedule_policy:
            self._snap_schedule_policy = self.__get_schedule_policy(&#39;snap&#39;)
        return self._snap_schedule_policy

    @property
    def addons(self):
        &#34;&#34;&#34;Treats the plan addons as read-only attribute&#34;&#34;&#34;
        for addon in self._plan_properties.get(&#39;summary&#39;, {}).get(&#39;addons&#39;, []):
            self._addons.append(
                addon
            )
        return self._addons

    def __set_subclient_policy_ids(self):
        &#34;&#34;&#34;Sets the subclient policy ids for the plan&#34;&#34;&#34;
        backup_content = self._plan_properties.get(&#39;laptop&#39;, {}).get(&#39;content&#39;, {}).get(&#39;backupContent&#39;, [])

        self._child_policies[&#39;subclientPolicyIds&#39;] = [
            ida[&#39;subClientPolicy&#39;][&#39;backupSetEntity&#39;][&#39;backupsetId&#39;]
            for ida in backup_content
            if ida.get(&#39;subClientPolicy&#39;, {}).get(&#39;backupSetEntity&#39;, {}).get(&#39;backupsetId&#39;)
        ]

    @property
    def subclient_policy(self):
        &#34;&#34;&#34;Treats the plan subclient policy as a read-only attribute&#34;&#34;&#34;
        if not self._child_policies.get(&#39;subclientPolicyIds&#39;):
            self.__set_subclient_policy_ids()

        return self._child_policies.get(&#39;subclientPolicyIds&#39;)

    @property
    def associated_entities(self):
        &#34;&#34;&#34;getter for the backup entities associated with the plan&#34;&#34;&#34;
        return self._associated_entities

    @property
    def parent_plan(self):
        &#34;&#34;&#34;getter for the parent plan of a derived plan&#34;&#34;&#34;
        return self._commcell_object.plans.get(self._parent_plan_name)

    @property
    def security_associations(self):
        &#34;&#34;&#34;getter for the plan&#39;s security associations
            Eg:
                {
                    &#39;sample_user_group_name&#39;: &#39;role_name&#39;
                }
        &#34;&#34;&#34;
        return self._security_associations

    def update_security_associations(self, associations_list, is_user = True, request_type = None, external_group = False):
        &#34;&#34;&#34;
        Adds the security association on the plan object

        Args:
            associations_list   (list)  --  list of users to be associated
                Example:
                    associations_list = [
                        {
                            &#39;user_name&#39;: user1,
                            &#39;role_name&#39;: role1
                        },
                        {
                            &#39;user_name&#39;: user2,
                            &#39;role_name&#39;: role2
                        }
                    ]
 
            is_user (bool)           --    True or False. set is_user = False, If associations_list made up of user groups
            request_type (str)      --    eg : &#39;OVERWRITE&#39; or &#39;UPDATE&#39; or &#39;DELETE&#39;, Default will be OVERWRITE operation
            external_group (bool)    --    True or False, set external_group = True. If Security associations is being done on External User Groups

        Raises:
            SDKException:
                if association is not of List type
        &#34;&#34;&#34;
        if not isinstance(associations_list, list):
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;)

        SecurityAssociation(self._commcell_object, self)._add_security_association(associations_list, 
                                        is_user, request_type, external_group)

    @property
    def content_indexing_props(self):
        &#34;&#34;&#34;returns the DC plan related CI properties from Plan&#34;&#34;&#34;
        return self._dc_plan_props

    @property
    def content_indexing(self):
        &#34;&#34;&#34;Returns the Content Indexing status of O365 plan&#34;&#34;&#34;
        try:
            ci_status = (self.properties.get(&#34;office365Info&#34;,{})
                         .get(&#34;o365Exchange&#34;,{})
                         .get(&#34;mbArchiving&#34;, {})
                         .get(&#34;detail&#34;, {})
                         .get(&#34;emailPolicy&#34;, {})
                         .get(&#34;archivePolicy&#34;, {})
                         .get(&#34;contentIndexProps&#34;, {})
                         .get(&#34;enableContentIndex&#34;, {}))
        except:
            ci_status= None
        return ci_status

    @content_indexing.setter
    def content_indexing(self, value: bool):
        &#34;&#34;&#34;Sets content indexing value for O365 plan&#34;&#34;&#34;
        self._enable_content_indexing_o365_plan(value)


    @property
    def properties(self):
        &#34;&#34;&#34;Returns the configured properties for the Plan&#34;&#34;&#34;
        return self._plan_properties

    @property
    def region_id(self):
        &#34;&#34;&#34;Returns the Backup destination region id&#34;&#34;&#34;
        return self._region_id

    @property
    def company(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the company of the plan

        return:
            str --  company&#39;s domain name
        &#34;&#34;&#34;
        return self._provider_domain_name

    @property
    def resources(self) -&gt; list:
        &#34;&#34;&#34;
        Returns the resources stored in storage resource pool

        return:
            list --  plan&#39;s resources
        &#34;&#34;&#34;
        return self._resources

    def refresh(self):
        &#34;&#34;&#34;Refresh the properties of the Plan.&#34;&#34;&#34;
        self._properties = self._get_plan_properties()

        # fetch v4 properties for server plans
        if self.subtype == 33554437:
            self._v4_plan_properties = self._get_v4_plan_properties()

        # lazy loading of properties
        self._data_schedule_policy = None
        self._log_schedule_policy = None
        self._snap_schedule_policy = None
        self._child_policies = {
            &#39;storagePolicy&#39;: None,
            &#39;schedulePolicy&#39;: {},
            &#39;subclientPolicyIds&#39;: []
        } # reset to constructor state

    def associate_user(self, userlist, send_invite=True):
        &#34;&#34;&#34;associates the users to the plan.
            # TODO: Need to handle user groups.

           Arguments:
                userlist(list) - list of users to be associated to the plans.

            Raises:
                SDKException:
                    if response is empty

                    if response is not success

        &#34;&#34;&#34;
        users_list = []

        for user in userlist:
            if self._commcell_object.users.has_user(user):
                temp = self._commcell_object.users.get(user)

                temp_dict = {
                    &#39;sendInvite&#39;: send_invite,
                    &#39;user&#39;: {
                        &#39;userName&#39;: temp.user_name,
                        &#39;userId&#39;: int(temp.user_id)
                    }
                }

                users_list.append(temp_dict)

        request_json = {
            &#34;userOperationType&#34;: 1,
            &#34;users&#34;: users_list
        }

        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, self._ADD_USERS_TO_PLAN, request_json
        )

        if flag:
            if response.json() and &#39;errors&#39; in response.json():
                for error in response.json()[&#34;errors&#34;]:
                    error_code = error[&#34;status&#34;][&#34;errorCode&#34;]

                    if error_code == 0:
                        pass
                    else:
                        o_str = &#39;Failed to add users with error code: &#34;{0}&#34;&#39;
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_code))
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def share(self, user_or_group_name, role_name, is_user=True, ops_type=1):
        &#34;&#34;&#34;Shares plan with given user or group by associating with given role

                Args:

                    user_or_group_name      (str)       --  User or Group name to which we are sharing

                    role_name               (str)       --  Role name which needs to associated with

                    ops_type                (int)       --  Operation type

                                                            Default : 1 (Add)

                                                            Supported : 1 (Add)
                                                                        3 (Delete)

                Returns:

                    None

                Raises:

                    SDKException:

                            if input is not valid

                            if failed to do sharing

                            if user/group/role not exists on commcell

                            if failed to get exisitng association details

        &#34;&#34;&#34;
        if not isinstance(user_or_group_name, str) or not isinstance(role_name, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        if ops_type not in [1, 3]:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Sharing operation type provided is not supported&#34;)
        if is_user:
            if not self._commcell_object.users.has_user(user_or_group_name):
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;User doesn&#39;t exists in the commcell&#34;)
        if not self._commcell_object.roles.has_role(role_name=role_name):
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Role doesn&#39;t exists in the commcell&#34;)
        request_json = copy.deepcopy(PlanConstants.PLAN_SHARE_REQUEST_JSON)
        association_response = None
        if ops_type == 1 and len(self.security_associations) &gt; 1:
            association_request_json = copy.deepcopy(PlanConstants.PLAN_SHARE_REQUEST_JSON)
            del association_request_json[&#39;securityAssociations&#39;]
            association_request_json[&#39;entityAssociated&#39;][&#39;entity&#39;][0][&#39;entityId&#39;] = int(self._plan_id)
            flag, response = self._cvpysdk_object.make_request(
                &#39;GET&#39;, self._API_SECURITY_ENTITY %
                (self._plan_entity_type, int(
                    self._plan_id)), association_request_json)
            if flag:
                if response.json() and &#39;securityAssociations&#39; in response.json():
                    association_response = response.json(
                    )[&#39;securityAssociations&#39;][0][&#39;securityAssociations&#39;][&#39;associations&#39;]
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Failed to get existing security associations&#39;)
            else:
                response_string = self._commcell_object._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        external_user = False
        if &#39;\\&#39; in user_or_group_name:
            external_user = True
        if is_user:
            user_obj = self._commcell_object.users.get(user_or_group_name)
            user_id = user_obj.user_id
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;userId&#39;] = int(user_id)
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;_type_&#39;] = 13
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;userName&#39;] = user_or_group_name
        elif external_user:
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;groupId&#39;] = 0
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;_type_&#39;] = 62
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][
                &#39;externalGroupName&#39;] = user_or_group_name
        else:
            grp_obj = self._commcell_object.user_groups.get(user_or_group_name)
            grp_id = grp_obj.user_group_id
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;userGroupId&#39;] = int(grp_id)
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;_type_&#39;] = 15
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][
                &#39;userGroupName&#39;] = user_or_group_name

        request_json[&#39;entityAssociated&#39;][&#39;entity&#39;][0][&#39;entityId&#39;] = int(self._plan_id)
        request_json[&#39;securityAssociations&#39;][&#39;associationsOperationType&#39;] = ops_type
        role_obj = self._commcell_object.roles.get(role_name)
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;properties&#39;][&#39;role&#39;][&#39;roleId&#39;] = role_obj.role_id
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;] = role_obj.role_name

        # Associate existing associations to the request
        if ops_type == 1 and len(self.security_associations) &gt; 1:
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;].extend(association_response)

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._API_SECURITY, request_json
        )
        if flag:
            if response.json() and &#39;response&#39; in response.json():
                response_json = response.json()[&#39;response&#39;][0]
                error_code = response_json[&#39;errorCode&#39;]
                if error_code != 0:
                    error_message = response_json[&#39;errorString&#39;]
                    raise SDKException(
                        &#39;Plan&#39;,
                        &#39;102&#39;, error_message)
                self.refresh()
            else:
                raise SDKException(&#39;Plan&#39;, &#39;105&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def schedule(self, schedule_name, pattern_json, ops_type=2):
        &#34;&#34;&#34;Creates or modifies the schedule associated with plan

                Args:

                    schedule_name       (str)       --  Schedule name

                    pattern_json        (dict)      --  Schedule pattern dict (Refer to Create_schedule_pattern in schedule.py)

                    ops_type            (int)       --  Operation type

                                                            Default : 2 (Add)

                                                            Supported : 2 (Add/Modify)

                Raises:

                      SDKException:

                            if input is not valid

                            if failed to create/modify schedule

                            if plan is not of type Data classification plan

        &#34;&#34;&#34;
        if not isinstance(schedule_name, str) or not isinstance(pattern_json, dict):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        if self.plan_type not in [PlanTypes.DC.value]:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Add/Modify Schedule is supported only for DC Plan via CvpySDK&#34;)
        if ops_type not in [2]:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Schedule operation type provided is not supported&#34;)
        request_json = copy.deepcopy(PlanConstants.PLAN_SCHEDULE_REQUEST_JSON[self.plan_type])
        request_json[&#39;summary&#39;][&#39;plan&#39;][&#39;planId&#39;] = int(self.plan_id)
        request_json[&#39;schedule&#39;][&#39;associations&#39;][0][&#39;entityId&#39;] = int(self.plan_id)
        request_json[&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;] = f&#34;Cvpysdk created Schedule policy for plan - {self.plan_name}&#34;
        request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;subTask&#39;][
            &#39;subTaskName&#39;] = schedule_name
        request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;pattern&#39;] = pattern_json
        request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;adminOpts&#39;][&#39;contentIndexingOption&#39;][&#39;operationType&#39;] = ops_type
        if self._dc_plan_props[&#39;targetApps&#39;][0] == TargetApps.FS.value:
            request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;subTask&#39;][&#39;operationType&#39;] = 5022
        self._update_plan_props(request_json)

    def edit_plan(self, **kwargs):
        &#34;&#34;&#34;Edit plan options

                Args:

                    **kwargs for Data Classification Plan

                    index_content       (bool)      --  Speifies whether to index content or not to index server

                    content_analyzer    (list)      --  list of Content analyzer client name

                    entity_list         (list)      --  list of entities which needs to be extracted

                    classifier_list     (list)      --  list of classifier which needs to be classified

                    enable_ocr          (bool)      --  specifies whether OCR is enabled or not

                    ocr_language        (int)       --  Language to be used when doing OCR
                                                            Default : English (Value-1)

                     Supported Languages:

                                    ENGLISH = 1,
                                    HEBREW = 2,
                                    SPANISH = 3,
                                    FRENCH = 4,
                                    ITALIAN = 5,
                                    DANISH = 6

                    include_docs        (str)       --  Include documents type separated by comma

                    exclude_path        (list)      --  List of paths which needs to be excluded

                    min_doc_size        (int)       --  Minimum document size in MB

                    max_doc_size        (int)       --  Maximum document size in MB
        &#34;&#34;&#34;
        if self.plan_type != PlanTypes.DC.value:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Function Not supported for this plan type&#34;)
        extraction_policy_list = []
        request_json = None
        if self.plan_type == PlanTypes.DC.value:
            request_json = copy.deepcopy(PlanConstants.PLAN_UPDATE_REQUEST_JSON[self.plan_type])
            request_json[&#39;summary&#39;][&#39;plan&#39;][&#39;planId&#39;] = int(self.plan_id)
            if TargetApps.SDG.value in self.content_indexing_props[&#39;targetApps&#39;]:
                request_json[&#39;eePolicyInfo&#39;][&#39;eePolicy&#39;][&#39;detail&#39;][&#39;eePolicy&#39;] = self.content_indexing_props[&#39;eePolicy&#39;]
                request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;] = self.content_indexing_props[&#39;ciPolicy&#39;]
                activate_obj = self._commcell_object.activate
                if &#39;content_analyzer&#39; in kwargs:
                    ca_list = []
                    for ca in kwargs.get(&#39;content_analyzer&#39;, []):
                        ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                        ca_list.append({
                            &#39;clientId&#39;: ca_client_id
                        })
                    request_json[&#39;eDiscoveryInfo&#39;] = {
                        &#39;contentAnalyzerClient&#39;: ca_list}
                if &#39;entity_list&#39; in kwargs or &#39;classifier_list&#39; in kwargs:
                    entity_mgr_obj = activate_obj.entity_manager()
                    # classifier is also an activate entity with type alone different so
                    # append this to entity list itself
                    entity_list = []
                    for entity in kwargs.get(&#39;entity_list&#39;, []):
                        entity_list.append(entity)
                    for entity in kwargs.get(&#39;classifier_list&#39;, []):
                        entity_list.append(entity)
                    for entity in entity_list:
                        entity_obj = entity_mgr_obj.get(entity)
                        extraction_policy_list.append(entity_obj.container_details)
                    request_json[&#39;eePolicyInfo&#39;][&#39;eePolicy&#39;][&#39;detail&#39;][&#39;eePolicy&#39;][&#39;extractionPolicy&#39;][&#39;extractionPolicyList&#39;] = extraction_policy_list

                if &#39;enable_ocr&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;enableImageExtraction&#39;] = kwargs.get(
                        &#39;enable_ocr&#39;, False)
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;ocrLanguages&#39;] = [
                        kwargs.get(&#39;ocr_language&#39;, 1)]
                if &#39;include_docs&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
                        &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
                if &#39;min_doc_size&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
                        &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
                if &#39;max_doc_size&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                        &#39;maxDocSize&#39;] = kwargs.get(&#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
                if &#39;exclude_path&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                        &#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, PlanConstants.DEFAULT_EXCLUDE_LIST)
                if &#39;index_content&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;opType&#39;] = kwargs.get(
                        &#39;index_content&#39;, PlanConstants.INDEXING_ONLY_METADATA)
            elif TargetApps.FSO.value in self.content_indexing_props[&#39;targetApps&#39;]:
                # currently we dont have any thing to update in DC plan for FSO app so throw exception
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;No attributes to Edit for DC Plan with TargetApps as : FSO&#39;)
        self._update_plan_props(request_json)

    def edit_risk_analysis_dc_plan(self, **kwargs):
        &#34;&#34;&#34;
        Edit Risk Analysis Data Classification Plan options
            Args:
            **kwargs for risk analysis Data Classification Plan
            index_content       (bool)      --  Specifies whether to index content or not to index server
            content_analyzer    (list)      --  list of Content analyzer client name
            entity_list         (list)      --  list of entities which needs to be extracted
            classifier_list     (list)      --  list of classifier which needs to be classified
            enable_ocr          (bool)      --  specifies whether OCR is enabled or not
            ocr_language        (int)       --  Language to be used when doing OCR
                                                Default : English (Value-1)
                Supported Languages:
                            ENGLISH = 1,
                            HEBREW = 2,
                            SPANISH = 3,
                            FRENCH = 4,
                            ITALIAN = 5,
                            DANISH = 6
            include_docs        (str)       --  Include documents type separated by comma
            exclude_path        (list)      --  List of paths which needs to be excluded
            min_doc_size        (int)       --  Minimum document size in MB
            max_doc_size        (int)       --  Maximum document size in MB
        &#34;&#34;&#34;
        if self.plan_type != PlanTypes.DC.value:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Function Not supported for this plan type&#34;)
        request_json = {}
        if self.plan_type == PlanTypes.DC.value:
            if &#39;content_analyzer&#39; in kwargs:
                # change to support SaaS and unification project
                ca_list = []
                for ca in kwargs.get(&#39;content_analyzer&#39;, []):
                    ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                    ca_list.append({
                        &#39;id&#39;: ca_client_id
                    })
                request_json[&#39;contentAnalyzer&#39;] = ca_list

            request_json[&#39;entityDetection&#39;] = {}
            activate_obj = self._commcell_object.activate
            entity_mgr_obj = activate_obj.entity_manager()
            if &#39;entity_list&#39; in kwargs:
                entity_list = []
                entity_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;entity_list&#39;, []))
                for entity_id in entity_ids:
                    entity_list.append({&#34;id&#34;: entity_id})
                request_json[&#39;entityDetection&#39;][&#34;entities&#34;] = entity_list
            if &#39;classifier_list&#39; in kwargs:
                classifier_list = []
                classifier_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;classifier_list&#39;, []))
                for classifier_id in classifier_ids:
                    classifier_list.append({&#34;id&#34;: classifier_id})
                request_json[&#39;entityDetection&#39;][&#34;classifiers&#34;] = classifier_list

            request_json[&#39;contentIndexing&#39;] = {}
            if &#39;index_content&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#34;searchType&#34;] = kwargs.get(
                    &#39;index_content&#39;, PlanConstants.RAPlanSearchType.SEARCH_TYPE_ONLY_METADATA).value
            if &#39;enable_ocr&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#34;extractTextFromImage&#34;] = kwargs.get(&#39;enable_ocr&#39;, False)
                request_json[&#39;contentIndexing&#39;][&#34;contentLanguage&#34;] = kwargs.get(&#39;ocr_language&#39;, 1)

            request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;] = {}
            if &#39;include_docs&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
                    &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
            if &#39;min_doc_size&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
                    &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
            if &#39;max_doc_size&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;maxDocSize&#39;] = kwargs.get(
                    &#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
            if &#39;exclude_path&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, [])

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_DC_PLAN, request_json)
        self.__handle_response(flag, response, custom_error_message=&#39;Failed to edit risk analysis DC plan : &#39;
                                                                    f&#39;[{self.plan_name}]&#39;)

    def _enable_content_indexing_o365_plan(self, value):
        &#34;&#34;&#34;Enable CI for O365 plan

            Args:
                value (bool)  --- specifies whether to content index or not

            Returns:
                None
        &#34;&#34;&#34;
        request_json = copy.deepcopy(PlanConstants.PLAN_UPDATE_REQUEST_JSON[self.plan_type])

        request_json[&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = self.plan_name
        request_json[&#39;summary&#39;][&#39;plan&#39;][&#39;planId&#39;] = int(self.plan_id)
        o365_arch = request_json[&#39;office365Info&#39;][&#39;o365Exchange&#39;][&#39;mbArchiving&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;]
        o365_arch[&#39;archivePolicy&#39;][&#39;contentIndexProps&#39;][&#39;enableContentIndex&#39;] = value

        o365_cloud = request_json[&#39;office365Info&#39;][&#39;o365CloudOffice&#39;][&#39;caBackup&#39;][&#39;detail&#39;][&#39;cloudAppPolicy&#39;][
            &#39;backupPolicy&#39;]
        o365_cloud[&#39;onedrivebackupPolicy&#39;][&#39;enableContentIndex&#39;] = value
        o365_cloud[&#39;spbackupPolicy&#39;][&#39;enableContentIndex&#39;] = value
        o365_cloud[&#39;teamsbackupPolicy&#39;][&#39;enableContentIndex&#39;] = value

        request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
            &#39;includeDocTypes&#39;] = PlanConstants.DEFAULT_INCLUDE_DOC_TYPES
        request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
            &#39;minDocSize&#39;] = PlanConstants.DEFAULT_MIN_DOC_SIZE

        request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
            &#39;maxDocSize&#39;] = PlanConstants.DEFAULT_MAX_DOC_SIZE
        request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][
            &#39;opType&#39;] = PlanConstants.INDEXING_METADATA_AND_CONTENT
        request_json[&#39;ciPolicy&#39;] = request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;]

        self._update_plan_props(request_json)

    def policy_subclient_ids(self):
        &#34;&#34;&#34;Returns Policy subclient IDs of the plan
        
        Returns:
            dict : OS and its associated subclient ID
        
        example:
            {
                &#39;Windows&#39; : windows_subclient_policy_subclient_id,
                &#39;Linux&#39; : linux_subclient_policy_subclient_id,
                &#39;Mac&#39; : mac_subclient_policy_subclient_id
            }
        
        &#34;&#34;&#34;
        result = dict()
        for backupset_id in self.subclient_policy:
            url = self._commcell_object._services[&#39;ADD_SUBCLIENT&#39;] + &#39;?clientId=2&amp;applicationId=1030&amp;backupsetid=&#39; + str(backupset_id)

            flag, response = self._commcell_object._cvpysdk_object.make_request(&#39;GET&#39;, url)
            if flag:
                if response.json() and &#39;subClientProperties&#39; in response.json():
                    subclient_id = response.json()[&#39;subClientProperties&#39;][0][&#39;subClientEntity&#39;][&#39;subclientId&#39;]
                    backupset_name = response.json()[&#39;subClientProperties&#39;][0][&#39;subClientEntity&#39;][&#39;backupsetName&#39;]
                    os = backupset_name.split()[-3]
                    result[os] = subclient_id
                else:
                    raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to get subclient Ids.&#39;)
            else:
                raise SDKException(&#39;Plan&#39;, 102, response.text)
            
        return result
    
    def __update_content_policy(self, content):
        &#34;&#34;&#34;
        Args:
            content (dict)  :  dictionary with backup content details. 
            
            example:
                content = {
                    &#34;windowsIncludedPaths&#34;: [&#34;Desktop&#34;],
                    &#34;windowsExcludedPaths&#34;: [&#34;Music&#34;],
                    &#34;windowsFilterToExcludePaths&#34;: [&#34;Videos&#34;],
                    &#34;unixIncludedPaths&#34;: [&#34;Desktop&#34;],
                    &#34;unixExcludedPaths&#34;: [&#34;Music&#34;],
                    &#34;unixFilterToExcludePaths&#34;: [&#34;Videos&#34;],
                    &#34;macIncludedPaths&#34;: [&#34;Desktop&#34;],
                    &#34;macExcludedPaths&#34;: [&#34;Music&#34;],
                    &#34;macFilterToExcludePaths&#34;: [&#34;Videos&#34;],
                    &#34;backupSystemState&#34;: True,
                    &#34;useVSSForSystemState&#34;: True,
                    &#34;backupSystemStateOnlyWithFullBackup&#34;: False
                }

            For unix and mac, replace key name with respective os name, **IncludedPaths, **ExcludedPaths, **FilterToExcludePaths

        &#34;&#34;&#34;
        
        request_json = {
            &#39;backupContent&#39; : content
        }

        request_url = self._commcell_object._services[&#39;V4_SERVER_PLAN&#39;] % self.plan_id

        flag, response = self._commcell_object._cvpysdk_object.make_request(&#39;PUT&#39;, request_url, request_json)

        self.__handle_response(flag, response, f&#39;Failed to update backup content for Plan: {self.plan_name}&#39;)

    def __map_content_to_new_format(self, content):
        &#34;&#34;&#34;
            Method to map old content format to new format (if we need to update the content policy of plan)
            
            Note: We cannot remove the old format as it is still can be used to modify the content of plans created before SP32. So mapping old content to new ones as needed.
        &#34;&#34;&#34;
        result = {
            &#34;windowsIncludedPaths&#34;: [],
            &#34;windowsExcludedPaths&#34;: [],
            &#34;windowsFilterToExcludePaths&#34;: [],
            &#34;unixIncludedPaths&#34;: [],
            &#34;unixExcludedPaths&#34;: [],
            &#34;unixFilterToExcludePaths&#34;: [],
            &#34;macIncludedPaths&#34;: [],
            &#34;macExcludedPaths&#34;: [],
            &#34;macFilterToExcludePaths&#34;: [],
            &#34;backupSystemState&#34;: True,
            &#34;useVSSForSystemState&#34;: True,
            &#34;backupSystemStateOnlyWithFullBackup&#34;: False
        }

        if &#39;Linux&#39; in content:
            content[&#39;Unix&#39;] = content.pop(&#39;Linux&#39;)

        for os, data in content.items():
            included_paths_key = f&#34;{os.lower()}IncludedPaths&#34;
            excluded_paths_key = f&#34;{os.lower()}ExcludedPaths&#34;
            filter_to_exclude_paths_key = f&#34;{os.lower()}FilterToExcludePaths&#34;

            if &#39;Content&#39; in data:
                result[included_paths_key] = [path.split(&#39;%&#39;)[-2] for path in data[&#39;Content&#39;]]

            if &#39;Exclude&#39; in data:
                result[excluded_paths_key] = [path.split(&#39;%&#39;)[-2] for path in data[&#39;Exclude&#39;]]

            if &#39;Except&#39; in data:
                result[filter_to_exclude_paths_key] = [path.split(&#39;%&#39;)[-2] for path in data[&#39;Except&#39;]]

            if os == &#39;Windows&#39;:
                result[&#39;backupSystemState&#39;] = data.get(&#39;Backup System State&#39;, True)
                result[&#39;useVSSForSystemState&#39;] = data.get(&#39;useVSSForSystemState&#39;, True)
                result[&#39;backupSystemStateOnlyWithFullBackup&#39;] = data.get(&#39;backupSystemStateOnlyWithFullBackup&#39;, False)

        return result
    
    def update_backup_content(self, content, request_type = &#39;OVERWRITE&#39;):
        &#34;&#34;&#34;
        Args:
            content (dict)  :  dictionary with backup content details. 
            
            example: 
                content = {
                    &#39;Windows&#39; : {
                        &#39;Content&#39; : [&#39;\\%Pictures%&#39;, &#39;\\%Desktop%&#39;],
                        &#39;Exclude&#39; : [&#39;\\%Documents%&#39;],
                        &#39;Except&#39; : [&#39;\\%Documents%&#39;],
                        &#39;Backup System State&#39; : True
                    },
                    &#39;Linux&#39; : {
                        &#39;Content&#39; : [&#39;/%Pictures%&#39;],
                        &#39;Exclude&#39; : [&#39;/%Documents%&#39;]
                    },
                    &#39;Mac&#39; : {
                        &#39;Content&#39; : [&#39;/%Pictures%&#39;],
                        &#39;Exclude&#39; : [&#39;/%Documents%&#39;]
                    }
                }
                    
            request_type (str)      :  Supported values &#39;OVERWRITE&#39; (default), &#39;UPDATE&#39;, &#39;DELETE&#39;. 

            For plans created from SP32, Please use below format of content
            example:
                content = {
                    &#34;windowsIncludedPaths&#34;: [&#34;Desktop&#34;],
                    &#34;windowsExcludedPaths&#34;: [&#34;Music&#34;],
                    &#34;windowsFilterToExcludePaths&#34;: [&#34;Videos&#34;],
                    &#34;backupSystemState&#34;: True,
                    &#34;useVSSForSystemState&#34;: True,
                    &#34;backupSystemStateOnlyWithFullBackup&#34;: False
                }

            For unix and mac, replace key name with respective os name, **IncludedPaths, **ExcludedPaths, **FilterToExcludePaths
        &#34;&#34;&#34;
        
        update_request_type = {
            &#34;OVERWRITE&#34;: 1,
            &#34;UPDATE&#34;: 2,
            &#34;DELETE&#34;: 3
        }
        
        subclients = self.policy_subclient_ids()

        if not subclients:
            if &#39;Windows&#39; in content or &#39;Linux&#39; in content or &#39;Mac&#39; in content:
                content = self.__map_content_to_new_format(content)
            self.__update_content_policy(content)
            return
        
        for os, value in content.items():
            request_json = {
                &#34;subClientProperties&#34;: {
                    &#34;fsExcludeFilterOperationType&#34;: update_request_type.get(request_type, 1),
                    &#34;fsContentOperationType&#34; : update_request_type.get(request_type, 1)
                }
            }
            
            request_url = self._commcell_object._services[&#39;SUBCLIENT&#39;] % subclients[os]
            
            contents = list()
            for key, val in value.items():
                if key.lower() == &#39;content&#39;:
                    for path in val: contents.append({&#34;path&#34; : path})
                if key.lower() == &#39;exclude&#39;:
                    for path in val: contents.append({&#34;excludePath&#34; : path})
                if os == &#39;Windows&#39; and key == &#39;Backup System State&#39;:
                    request_json[&#39;subClientProperties&#39;][&#39;fsSubClientProp&#39;] = {&#39;backupSystemState&#39; : val}
                    
            if contents:
                request_json[&#39;subClientProperties&#39;][&#39;content&#39;] = contents
            
            flag, response = self._commcell_object._cvpysdk_object.make_request(&#39;POST&#39;, request_url, request_json)
                
            if flag:
                if response.json() and &#39;response&#39; in response.json():
                    errorCode = response.json()[&#39;response&#39;][0].get(&#39;errorCode&#39;)
                    if errorCode:
                        raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to Change Content of Plan.&#39;)
                else:
                    raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to get subclient Ids.&#39;)
            else:
                raise SDKException(&#39;Plan&#39;, 102, response.text)

    def enable_data_aging(self, plan_copy_id: int, is_enable=True):

        &#34;&#34;&#34;Method is used to enable/disable the data aging for the plan copy

            Args:
                plan_copy_id(int)      :   copy_id of the plan

                is_enable(bool)       :   value whether to be unable or disable the data aging

                                      example: true = enable
                                               false = disable
            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        payload = {
            &#34;retentionRules&#34;: {
                &#34;enableDataAging&#34;: is_enable
            }
        }

        api_url = self._services[&#39;ENABLE_DATA_AGING&#39;] % (self._plan_id, plan_copy_id)
        flag, response = self._cvpysdk_object.make_request(method=&#39;PUT&#39;,
                                                           url=api_url, payload=payload)
        if not flag:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;,
                               self._commcell_object._update_response_(response.text))
        if not response:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;,
                               self._commcell_object._update_response_(response.text))

    @property
    def applicable_solutions(self):
        &#34;&#34;&#34;Method to read applicable solutions&#34;&#34;&#34;
        return self._applicable_solutions

    @applicable_solutions.setter
    def applicable_solutions(self, solutions: list = list()):
        &#34;&#34;&#34;Method to update applicable solutions of plan
        
        Args:
            solutions (list) : List of Applicable Solutions
            
            example: 
                [&#34;File Servers&#34;, &#34;Databases&#34;] : FS and DB will be set as a applicable solutions
                [] : Passing empty list will reset applicable solutions to ALL
            
        &#34;&#34;&#34;
        request_url  = self._commcell_object._services[&#39;APPLICABLE_SOLNS_ENABLE&#39; if solutions else &#39;APPLICABLE_SOLNS_DISABLE&#39;] % self.plan_id
        
        if solutions:
            supported_solutions =  self._commcell_object.plans.get_supported_solutions()
            request_json = {&#34;solutions&#34;: [{&#34;id&#34;: supported_solutions[soln_name], &#34;name&#34;: soln_name} for soln_name in solutions]}
        else:
            request_json = None
                    
        flag, response = self._commcell_object._cvpysdk_object.make_request(&#39;PUT&#39;, request_url, request_json)
        
        if not flag:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, self._update_response_(response.text))
        
        if not response.json() or response.json()[&#39;errorCode&#39;]:
            raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to update Applicable Solutions for Plan&#39;)
                
        self.refresh()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cvpysdk.plan.Plan"><code class="flex name class">
<span>class <span class="ident">Plan</span></span>
<span>(</span><span>commcell_object, plan_name, plan_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for performing operations for a specific Plan.</p>
<p>Initialize the Plan class instance.</p>
<h2 id="args">Args</h2>
<p>commcell_object
(object)
&ndash;
instance of the Commcell class</p>
<p>plan_name
(str)
&ndash;
name of the plan</p>
<p>plan_id
(str)
&ndash;
id of the plan
default: None</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Plan class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2046-L4416" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Plan(object):
    &#34;&#34;&#34;Class for performing operations for a specific Plan.&#34;&#34;&#34;

    def __init__(self, commcell_object, plan_name, plan_id=None):
        &#34;&#34;&#34;Initialize the Plan class instance.

            Args:
                commcell_object     (object)  --  instance of the Commcell class

                plan_name           (str)     --  name of the plan

                plan_id             (str)     --  id of the plan
                    default: None

            Returns:
                object - instance of the Plan class

        &#34;&#34;&#34;
        self._commcell_object = commcell_object

        self._cvpysdk_object = commcell_object._cvpysdk_object
        self._services = commcell_object._services
        self._update_response_ = commcell_object._update_response_

        self._plan_name = plan_name.lower()
        self._plan_properties = None

        if plan_id:
            self._plan_id = str(plan_id)
        else:
            self._plan_id = self._get_plan_id()

        self._PLAN = self._services[&#39;PLAN&#39;] % (self.plan_id)
        self._V4_PLAN = self._services[&#39;V4_SERVER_PLAN&#39;] % (self.plan_id)
        self._V4_DC_PLAN = self._services[&#39;V4_DC_PLAN&#39;] % (self.plan_id)
        self._PLAN_RPO = self._services[&#39;SERVER_PLAN_RPO&#39;] % (self.plan_id)
        self._ADD_USERS_TO_PLAN = self._services[&#39;ADD_USERS_TO_PLAN&#39;] % (self.plan_id)
        self._API_SECURITY = self._services[&#39;SECURITY_ASSOCIATION&#39;]
        self._API_SECURITY_ENTITY = self._services[&#39;ENTITY_SECURITY_ASSOCIATION&#39;]
        self._SERVER_PLAN_BACKUP_DESTINATION = self._services[&#39;V4_SERVER_PLAN_BACKUP_DESTINATION&#39;] % (self.plan_id)

        self._properties = None
        self._sla_in_minutes = None
        self._operation_window = None
        self._full_operation_window = None
        self._plan_type = None
        self._subtype = None
        self._security_associations = {}
        self._provider_domain_name = None
        self._resources = None
        self._storage_pool = None
        self._child_policies = {
            &#39;storagePolicy&#39;: None,
            &#39;schedulePolicy&#39;: {},
            &#39;subclientPolicyIds&#39;: []
        }
        self._storage_copies = {}
        self._all_copies = None
        self._user_group = None
        self._client_group = None
        self._override_entities = None
        self._parent_plan_name = None
        self._addons = []
        self._associated_entities = {}
        self._dc_plan_props = {}
        self._plan_entity_type = 158
        self._region_id = []
        self._applicable_solutions = []
        self._v4_plan_properties = {}
        self.refresh()
        self.plan_v4_helper = _PayloadGeneratorPlanV4(commcell=self._commcell_object)
        self._data_schedule_policy = None
        self._log_schedule_policy = None
        self._snap_schedule_policy = None

    def __repr__(self):
        &#34;&#34;&#34;String representation of the instance of this class.&#34;&#34;&#34;
        representation_string = &#39;Plan class instance for plan: &#34;{0}&#34;, of Commcell: &#34;{1}&#34;&#39;

        return representation_string.format(
            self._plan_name, self._commcell_object.commserv_name
        )

    def _get_plan_id(self):
        &#34;&#34;&#34;Gets the plan id associated with this plan.

            Returns:
                str - id associated with this plan
        &#34;&#34;&#34;
        plans = Plans(self._commcell_object)
        return plans.get(self.plan_name).plan_id

    def _get_v4_plan_properties(self) -&gt; Dict:
        &#34;&#34;&#34;Gets the properties of this plan from V4 API

            Returns:
                dict - dictionary consisting of the properties of this plan

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, self._V4_PLAN)

        if flag:
            if response.json():
                self._v4_plan_properties = response.json()
                return self._v4_plan_properties
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_plan_properties(self):
        &#34;&#34;&#34;Gets the plan properties of this plan.

            Returns:
                dict - dictionary consisting of the properties of this plan

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        plan_properties_url = &#39;{0}?propertyLevel=30&#39;.format(self._PLAN)
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, plan_properties_url)

        if flag:
            if response.json() and &#39;plan&#39; in response.json():
                self._plan_properties = response.json()[&#39;plan&#39;]

                if &#39;planName&#39; in self._plan_properties[&#39;summary&#39;][&#39;plan&#39;]:
                    self._plan_name = self._plan_properties[&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;].lower()

                if &#39;slaInMinutes&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._sla_in_minutes = self._plan_properties[&#39;summary&#39;][&#39;slaInMinutes&#39;]

                if &#39;type&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._plan_type = self._plan_properties[&#39;summary&#39;][&#39;type&#39;]

                if &#39;subtype&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._subtype = self._plan_properties[&#39;summary&#39;][&#39;subtype&#39;]

                if &#39;storage&#39; in self._plan_properties:
                    if &#39;copy&#39; in self._plan_properties[&#39;storage&#39;]:
                        self._all_copies = self._plan_properties.get(&#39;storage&#39;,{}).get(&#39;copy&#39;,[])
                        for copy in self._plan_properties[&#39;storage&#39;][&#39;copy&#39;]:
                            if &#39;useGlobalPolicy&#39; in copy:
                                storage_pool_name = copy[&#39;useGlobalPolicy&#39;][&#39;storagePolicyName&#39;].lower()
                            else:
                                storage_pool_name = copy[&#39;library&#39;][&#39;libraryName&#39;].lower()
                            self._storage_copies[copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]] = {
                                &#39;storagePool&#39;: storage_pool_name,
                                &#39;retainBackupDataForDays&#39;: copy[
                                    &#39;retentionRules&#39;][&#39;retainBackupDataForDays&#39;],
                                &#39;isDefault&#39;: False,
                                &#39;isSnapCopy&#39;: False,
                            }
                            if &#39;extendedRetentionRuleOne&#39; in copy[&#39;retentionRules&#39;]:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;extendedRetention&#39;] = (
                                        1,
                                        True,
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;rule&#39;],
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;endDays&#39;],
                                        copy[&#39;retentionRules&#39;][&#39;extendedRetentionRuleOne&#39;][&#39;graceDays&#39;]
                                    ) 
                            if copy[&#39;isDefault&#39;] == 1:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;isDefault&#39;] = True

                            if copy[&#39;isSnapCopy&#39;] == 1:
                                self._storage_copies[
                                    copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;]][&#39;isSnapCopy&#39;] = True

                if self._subtype == 33554439:
                    if &#39;clientGroup&#39; in self._plan_properties[&#39;autoCreatedEntities&#39;]:
                        self._commcell_object.client_groups.refresh()
                        self._client_group = self._commcell_object.client_groups.get(
                            self._plan_properties[&#39;autoCreatedEntities&#39;][&#39;clientGroup&#39;][
                                &#39;clientGroupName&#39;]
                        )

                    if &#39;localUserGroup&#39; in self._plan_properties[&#39;autoCreatedEntities&#39;]:
                        self._user_group = self._plan_properties[&#39;autoCreatedEntities&#39;][
                            &#39;localUserGroup&#39;][&#39;userGroupName&#39;]

                if self._plan_properties[&#39;operationWindow&#39;][&#39;ruleId&#39;] != 0:
                    self._operation_window = self._plan_properties[&#39;operationWindow&#39;]
                else:
                    self._operation_window = None

                if self._plan_properties[&#39;fullOperationWindow&#39;][&#39;ruleId&#39;] != 0:
                    self._full_operation_window = self._plan_properties[&#39;fullOperationWindow&#39;]
                else:
                    self._full_operation_window = None

                if &#39;laptop&#39; in self._plan_properties:
                    if &#39;backupContent&#39; in self._plan_properties[&#39;laptop&#39;][&#39;content&#39;]:
                        self._child_policies[&#39;subclientPolicyIds&#39;].clear()
                        for ida in self._plan_properties[&#39;laptop&#39;][&#39;content&#39;][&#39;backupContent&#39;]:
                            if ida[&#39;subClientPolicy&#39;].get(&#39;backupSetEntity&#39;):
                                self._child_policies[&#39;subclientPolicyIds&#39;].append(
                                    ida[&#39;subClientPolicy&#39;][&#39;backupSetEntity&#39;][&#39;backupsetId&#39;]
                                )

                if (&#39;inheritance&#39; in self._plan_properties and
                        not self._plan_properties[&#39;inheritance&#39;][&#39;isSealed&#39;]):
                    temp_dict = self._plan_properties[&#39;inheritance&#39;]
                    del temp_dict[&#39;isSealed&#39;]
                    if &#39;enforcedEntities&#39; not in temp_dict:
                        temp_dict[&#39;enforcedEntities&#39;] = []
                    if &#39;privateEntities&#39; not in temp_dict:
                        temp_dict[&#39;privateEntities&#39;] = []
                    self._override_entities = temp_dict

                if &#39;parent&#39; in self._plan_properties[&#39;summary&#39;]:
                    self._parent_plan_name = self._plan_properties[&#39;summary&#39;][&#39;parent&#39;][&#39;planName&#39;]

                if &#39;eePolicy&#39; in self._plan_properties:
                    extraction_policy = self._plan_properties[&#39;eePolicy&#39;]
                    if &#39;policyEntity&#39; in extraction_policy:
                        self._dc_plan_props[&#39;eePolicyId&#39;] = extraction_policy[&#39;policyEntity&#39;][&#39;policyId&#39;]
                    if &#39;detail&#39; in extraction_policy:
                        self._dc_plan_props[&#39;eePolicy&#39;] = extraction_policy[&#39;detail&#39;][&#39;eePolicy&#39;]

                if &#39;ciPolicy&#39; in self._plan_properties:
                    ci_policy = self._plan_properties[&#39;ciPolicy&#39;]
                    if &#39;policyEntity&#39; in ci_policy:
                        self._dc_plan_props[&#39;ciPolicyId&#39;] = ci_policy[&#39;policyEntity&#39;][&#39;policyId&#39;]
                    if &#39;detail&#39; in ci_policy:
                        self._dc_plan_props[&#39;ciPolicy&#39;] = ci_policy[&#39;detail&#39;][&#39;ciPolicy&#39;]

                if &#39;eDiscoveryInfo&#39; in self._plan_properties:
                    if &#39;analyticsIndexServer&#39; in self._plan_properties[&#39;eDiscoveryInfo&#39;]:
                        self._dc_plan_props[&#39;analyticsIndexServer&#39;] = self._plan_properties[&#39;eDiscoveryInfo&#39;][&#39;analyticsIndexServer&#39;]

                if &#39;options&#39; in self._plan_properties:
                    plan_options = self._plan_properties[&#39;options&#39;]
                    if &#39;targetApps&#39; in plan_options:
                        self._dc_plan_props[&#39;targetApps&#39;] = plan_options[&#39;targetApps&#39;]

                    if &#39;supportedWorkloads&#39; in plan_options:
                        self._applicable_solutions = [soln[&#39;solutionName&#39;] for soln in plan_options[&#39;supportedWorkloads&#39;].get(&#39;solutions&#39;, [])]

                if &#39;securityAssociations&#39; in self._plan_properties:
                    self._security_associations = {}
                    for association in self._plan_properties[&#39;securityAssociations&#39;].get(&#39;associations&#39;, []):
                        temp_key = None
                        if &#39;externalGroupName&#39; in association[&#39;userOrGroup&#39;][0]:
                            temp_key = &#39;{0}\\{1}&#39;.format(
                                    association[&#39;userOrGroup&#39;][0][&#39;providerDomainName&#39;],
                                    association[&#39;userOrGroup&#39;][0][&#39;externalGroupName&#39;]
                                )
                        elif &#39;userGroupName&#39; in association[&#39;userOrGroup&#39;][0]:
                            temp_key = association[&#39;userOrGroup&#39;][0][&#39;userGroupName&#39;]
                        else:
                            temp_key = association[&#39;userOrGroup&#39;][0][&#39;userName&#39;]
                        if &#39;role&#39; in association[&#39;properties&#39;]:
                            if temp_key in self._security_associations:
                                self._security_associations[temp_key].append(
                                    association[&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;]
                                )
                            else:
                                self._security_associations[temp_key] = [association[&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;]]
                    if &#39;tagWithCompany&#39; in self._plan_properties.get(&#39;securityAssociations&#39;):
                        self._provider_domain_name = self._plan_properties.get(&#39;securityAssociations&#39;, {}).\
                            get(&#39;tagWithCompany&#39;, {}).get(&#39;providerDomainName&#39;)

                if &#34;storageRules&#34; in self._plan_properties:
                    self._region_id = [x[&#34;regions&#34;][&#34;region&#34;][0][&#34;regionId&#34;]
                                       for x in self._plan_properties[&#34;storageRules&#34;][&#34;rules&#34;]]

                if &#39;storageResourcePoolMap&#39; in self._plan_properties:
                    self._resources = self._plan_properties.get(&#39;storageResourcePoolMap&#39;, {})[0].get(&#39;resources&#39;)

                self._get_associated_entities()

                return self._plan_properties
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def derive_and_add(self,
                       plan_name,
                       storage_pool_name=None,
                       sla_in_minutes=None,
                       override_entities=None):
        &#34;&#34;&#34;Derives the base plan based on the the inheritance properties to created a derived plan

            Args:
                plan_name           (str)        --  name of the new plan to add

                storage_pool_name   (str)   --  name of the storage pool to be used for the plan
                    default: None   :   when the name is left to default, it inherits the base plan
                                        storage pool if overriding is optional/not allowed

                sla_in_minutes        (int)        --  Backup SLA in hours
                    default: None   :   when the SLA is left to default, it inherits the base plan
                                        SLA if overriding is optional/not allowed

                override_entities   (dict)  --  Specify the entities with respective overriding.

                    default: None

                        {
                            &#39;privateEntities&#39;: [1, 4],

                            &#39;enforcedEntities&#39;: [256, 512, 1024]
                        }
                        - where,
                                privateEntities are set when respective entity overriding is must
                                enforcedEntities are set when respective entity overriding is
                                not allowed
                                left blank if overriding is optional

                        - entity IDs,
                                1    - Storage
                                4    - SLA/Schedules
                                256  - Windows content
                                512  - Unix content
                                1024 - Mac content


        Returns:
            object - instance of the Plan class created by this method

        Raises:
            SDKException:
                if plan name is in incorrect format

                if plan already exists

                if neccessary arguments are not passed

                if inheritance rules are not followed

        &#34;&#34;&#34;
        if not isinstance(plan_name, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;, &#39;Plan name must be string value&#39;)
        else:
            if self._commcell_object.plans.has_plan(plan_name):
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(
                        plan_name)
                )
        if self._override_entities is not None:
            request_json = self._commcell_object.plans._get_plan_template(
                str(self._subtype), &#34;MSP&#34;)

            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;parent&#39;] = {
                &#39;planId&#39;: int(self._plan_id)
            }

            is_dedupe = True
            if storage_pool_name is not None:
                storage_pool_obj = self._commcell_object.storage_pools.get(
                    storage_pool_name
                )
                if &#39;dedupDBDetailsList&#39; \
                        not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
                    is_dedupe = False
                storage_pool_id = int(storage_pool_obj.storage_pool_id)
                if is_dedupe:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;useGlobalDedupStore&#39;] = 1
                else:
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;enableDeduplication&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                        &#39;enableClientSideDedup&#39;]
                    del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                        &#39;useGlobalStoragePolicy&#39;: 1
                    }
            else:
                storage_pool_id = None

            if 1 in self._override_entities[&#39;enforcedEntities&#39;]:
                if storage_pool_id is None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                        &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                    }
                    snap_copy_id = self.storage_policy.storage_policy_id
                else:
                    raise SDKException(
                        &#39;Plan&#39;, &#39;102&#39;, &#39;Storage is enforced by base plan, cannot be overridden&#39;)
            elif 1 in self._override_entities[&#39;privateEntities&#39;]:
                if storage_pool_id is not None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                        &#34;storagePolicyId&#34;: storage_pool_id
                    }
                    snap_copy_id = storage_pool_id
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Storage must be input&#39;)
            else:
                if storage_pool_id is not None:
                    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                        &#34;storagePolicyId&#34;: storage_pool_id
                    }
                    snap_copy_id = storage_pool_id
                else:
                    request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                        &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                    }
                    snap_copy_id = self.storage_policy.storage_policy_id

            if 4 in self._override_entities[&#39;enforcedEntities&#39;]:
                if sla_in_minutes is None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes
                else:
                    raise SDKException(
                        &#39;Plan&#39;, &#39;102&#39;, &#39;SLA is enforced by base plan, cannot be overridden&#39;)
            elif 4 in self._override_entities[&#39;privateEntities&#39;]:
                if sla_in_minutes is not None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;SLA must be input&#39;)
            else:
                if sla_in_minutes is not None:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
                else:
                    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes

            if isinstance(override_entities, dict):
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
                request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                    &#39;isSealed&#39;: False
                }
                for entity in self._override_entities[&#39;enforcedEntities&#39;]:
                    from functools import reduce
                    if override_entities and entity in reduce(
                            lambda i, j: i + j, override_entities.values()):
                        raise SDKException(
                            &#39;Plan&#39;, &#39;102&#39;, &#39;Override not allowed&#39;)
                if &#39;enforcedEntities&#39; in override_entities:
                    request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = (
                        override_entities[&#39;enforcedEntities&#39;]
                    )
                if &#39;privateEntities&#39; in override_entities:
                    request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = (
                        override_entities[&#39;privateEntities&#39;]
                    )
            else:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
                request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                    &#39;isSealed&#39;: True
                }

            if sla_in_minutes is not None:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                    &#39;definesEntity&#39;: True
                }
            else:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                    &#39;definesEntity&#39;: False
                }

            if isinstance(self._override_entities, dict):
                if (4 not in
                        self._override_entities[&#39;enforcedEntities&#39;] +
                        self._override_entities[&#39;privateEntities&#39;]):
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 0
                elif 4 in self._override_entities[&#39;enforcedEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 2
                elif 4 in self._override_entities[&#39;privateEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 1

            if storage_pool_id is not None:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                    &#39;definesEntity&#39;: True
                }
            else:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                    &#39;definesEntity&#39;: False
                }

            if isinstance(self._override_entities, dict):
                if (1 not in
                        self._override_entities[&#39;enforcedEntities&#39;] +
                        self._override_entities[&#39;privateEntities&#39;]):
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 0
                elif 1 in self._override_entities[&#39;enforcedEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 2
                elif 1 in self._override_entities[&#39;privateEntities&#39;]:
                    request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 1

            if self._subtype != 33554437:
                temp_defines_key = {
                    &#39;definesEntity&#39;: False
                }
                if isinstance(self._override_entities, dict):
                    if (not all(entity in
                                self._override_entities[&#39;enforcedEntities&#39;] +
                                self._override_entities[&#39;privateEntities&#39;]
                                for entity in [256, 512, 1024])):
                        temp_defines_key[&#39;overrideEntity&#39;] = 0
                    elif all(entity in self._override_entities[&#39;enforcedEntities&#39;]
                             for entity in [256, 512, 1024]):
                        temp_defines_key[&#39;overrideEntity&#39;] = 2
                    elif all(entity in self._override_entities[&#39;privateEntities&#39;]
                             for entity in [256, 512, 1024]):
                        temp_defines_key[&#39;overrideEntity&#39;] = 1
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientLin&#39;] = temp_defines_key
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientMac&#39;] = temp_defines_key
                request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientWin&#39;] = temp_defines_key

            if self._subtype == 33554437 and &#39;snap&#39; in self.addons and &#39;copy&#39; \
                    in request_json[&#39;plan&#39;][&#39;storage&#39;]:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                    &#39;storagePolicyId&#39;: snap_copy_id
                }
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                    &#39;useGlobalStoragePolicy&#39;: 1
                }

            add_plan_service = self._commcell_object.plans._PLANS
            headers = self._commcell_object._headers.copy()
            headers[&#39;LookupNames&#39;] = &#39;False&#39;

            flag, response = self._cvpysdk_object.make_request(
                &#39;POST&#39;, add_plan_service, request_json, headers=headers
            )

            if flag:
                if response.json():
                    response_value = response.json()
                    error_message = None
                    error_code = None

                    if &#39;errors&#39; in response_value:
                        error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                        error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                    # error_codes 0 - OK, 1 - plan without storage, 84 - restricted plan
                    if error_code not in [0, 1, 84]:
                        o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                            error_message
                        )
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                    if &#39;plan&#39; in response_value:
                        plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                        # initialize the plans again
                        # so that the plans object has all the plans
                        self._commcell_object.plans.refresh()

                        return self._commcell_object.plans.get(plan_name)
                    else:
                        o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                                 &#39;Please check the documentation for &#39;
                                 &#39;more details on the error&#39;).format(error_code)

                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
                else:
                    raise SDKException(&#39;Response&#39;, 102)
            else:
                response_string = self._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        else:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Inheritance disabled for plan&#39;)

    def modify_schedule(self, schedule_json, is_full_schedule=False):
        &#34;&#34;&#34;Modifies the incremental RPO schedule pattern of the plan with the given schedule json

            Args:
            schedule_json (dict) -- {
                    pattern : {}, -- Please refer SchedulePattern.create_schedule in schedules.py for the types of
                                     pattern to be sent

                                     eg: {
                                            &#34;freq_type&#34;: &#39;daily&#39;,
                                            &#34;active_start_time&#34;: time_in_%H/%S (str),
                                            &#34;repeat_days&#34;: days_to_repeat (int)
                                         }

                    options: {} -- Please refer ScheduleOptions.py classes for respective schedule options

                                    eg:  {
                                        &#34;maxNumberOfStreams&#34;: 0,
                                        &#34;useMaximumStreams&#34;: True,
                                        &#34;useScallableResourceManagement&#34;: True,
                                        &#34;totalJobsToProcess&#34;: 1000,
                                        &#34;allCopies&#34;: True,
                                        &#34;mediaAgent&#34;: {
                                            &#34;mediaAgentName&#34;: &#34;&lt;ANY MEDIAAGENT&gt;&#34;
                                        }
                                    }
                    }
            is_full_schedule (bool) --  Pass True if he schedule to be modified is the full backup schedule
        &#34;&#34;&#34;
        if is_full_schedule:
            try:
                schedule_id = list(filter(
                    lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
                ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
            except IndexError:
                raise IndexError(&#39;Full backup schedule not enabled&#39;)
        else:
            schedule_id = list(filter(
                lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 65536, self.schedule_policies[&#39;data&#39;]._subtasks
            ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
        self.schedule_policies[&#39;data&#39;].modify_schedule(
            schedule_json,
            schedule_id=schedule_id
        )
        self.refresh()

    def __handle_response(self, flag: bool, response: object, custom_error_message: str=None):
        &#34;&#34;&#34;Handles the response received from the server

        Args:
            flag (bool)                 --  boolean specifying whether the request was successful or not

            response (Response Object)  --  response received from the server

            custom_error_message (str)  --  custom error message to be used in case of failure

        Raises:
            SDKException:
                if response is empty

                if response is not success
        &#34;&#34;&#34;
        if flag:
            if response.json():
                response_value = response.json()
                error_info = response_value.get(&#39;error&#39;, response_value)
                error_message = error_info.get(&#39;errorMessage&#39;, &#39;&#39;)
                error_code = error_info.get(&#39;errorCode&#39;, 0)

                if error_code != 0:
                    if custom_error_message:
                        error_message = custom_error_message + &#39;\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, error_message)
                
                self.refresh()

            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def get_plan_properties(self) -&gt; Dict:
        &#34;&#34;&#34;
        Method to get the properties of this plan fetched from v4 API.
        
        Returns:
            Dict: A dictionary containing the properties of the plan fetched from the v4 API.
        &#34;&#34;&#34;
        return self._v4_plan_properties

    def get_storage_copy_details(self, copy_name: str, region_name: str = None) -&gt; Dict:
        &#34;&#34;&#34;Method to get the storage copy details of the given copy name and region name

        Args:
            copy_name (str): Name of the copy
            region_name (str, optional): Name of the region

        Returns:
            dict: Dictionary consisting of the properties of the given copy name
        &#34;&#34;&#34;
        backup_destinations = self._v4_plan_properties.get(&#39;backupDestinations&#39;, [])

        # Filter by region name
        if region_name:
            backup_destinations = list(filter(lambda item: item.get(&#39;region&#39;, {}).get(&#34;name&#34;) == region_name, backup_destinations))

        # Filter by copy name
        if copy_name:
            backup_destinations = list(filter(lambda item: item.get(&#39;planBackupDestination&#39;, {}).get(&#34;name&#34;) == copy_name, backup_destinations))

        if not backup_destinations:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;No copy found with name: [{copy_name}] and region: [{region_name}]&#39;)

        if len(backup_destinations) &gt; 1:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Multiple copies found with name: [{copy_name}] and region: [{region_name}]&#39;)
        
        copy_details = next(iter(backup_destinations), None)
        
        return copy.deepcopy(copy_details) # return a deep copy to avoid modifying the original properties

    def get_storage_copy_id(self, copy_name: str, region_name: str = None) -&gt; int:
        &#34;&#34;&#34;Gets the storage copy id of the given copy name

        Args:
            copy_name (str): Name of the copy
            region_name (str, optional): Name of the region

        Returns:
            int: Storage copy id of the given copy name
        &#34;&#34;&#34;
        copy_details = self.get_storage_copy_details(copy_name, region_name)
        return copy_details.get(&#39;planBackupDestination&#39;, {}).get(&#39;id&#39;, 0) if copy_details else 0

    def add_copy(self, copy_name: str, storage_pool: str, retention: int=30, extended_retention: dict=None, region: str=None) -&gt; None:
        &#34;&#34;&#34;
            Method to add an aux copy to the plan

            Args:
                copy_name   (str)   -   name of the copy that is being added
                storage_pool (str)  -   name of the storage pool that is to be used for the copy
                retention   (int)   -   retention period in days for the copy
                extended_retention (dict)  -   extended retention rules of a copy
                region      (str)   -   region name to which copy needs to be added

            Returns:
                None

            Raises:
                SDKException:
                -   if failed to add new copy to the plan
        &#34;&#34;&#34;
        copy_details = {
            &#34;backupDestinationName&#34;: copy_name,
            &#34;storage_name&#34;: storage_pool,
            &#34;retentionPeriodDays&#34;: retention
        }

        if extended_retention:
            copy_details[&#39;useExtendedRetentionRules&#39;] = True
            copy_details[&#34;extendedRetentionRules&#34;] = extended_retention

        request_json = {
            &#39;destinations&#39;: [self.plan_v4_helper.get_copy_payload(copy_details, is_aux_copy=True)]
        }
        # during add copy, region should be specified as the separate blob
        if region:
            request_json[&#39;region&#39;] = {&#34;id&#34;: int(self._commcell_object.regions.get(region).region_id)}

        flag, response = self._cvpysdk_object.make_request(&#39;POST&#39;, self._SERVER_PLAN_BACKUP_DESTINATION, request_json)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to add new copy to the plan : [{self.plan_name}]&#39;)

    def edit_copy(self, copy_name: str, new_retention_days: int = None, new_recovery_points: int = None, new_extended_retention: dict = None, current_region_name: str = None) -&gt; None:
        &#34;&#34;&#34;
        Method to edit a copy settings

        Args:
            copy_name (str): name of the copy that is being edited
            new_retention_days (int): new retention period in days for the copy
            new_recovery_points (int): new recovery points for the snap copy
            new_extended_retention (dict): new extended retention rules of a copy
            current_region_name (str): name of the region from which the copy needs to be edited

            Example:
                new_extended_retention =  {
                &#34;firstExtendedRetentionRule&#34;: {
                    &#34;isInfiniteRetention&#34;: False,
                    &#34;type&#34;: &#34;WEEKLY_FULLS&#34;,
                    &#34;retentionPeriodDays&#34;: 90
                }
        }
        &#34;&#34;&#34;
        copy_details = self.get_storage_copy_details(copy_name, current_region_name)
        copy_id = self.get_storage_copy_id(copy_name, current_region_name)
        is_snap_copy = copy_details.get(&#39;isSnapCopy&#39;, False)

        # input validation
        if new_retention_days is not None and new_recovery_points is not None:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Both retention days and recovery points cannot be set at the same time&#39;)

        if new_recovery_points and not is_snap_copy:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Recovery points can be set only for snap copy&#39;)

        # copy the old details to the required payload first
        required_props = [&#39;retentionPeriodDays&#39;, &#39;retentionRuleType&#39;, &#39;useExtendedRetentionRules&#39;, &#39;extendedRetentionRules&#39;]
        new_retention_rules = {key: copy_details[key] for key in required_props if key in copy_details}

        # update the payload based on the input
        if new_retention_days is not None:
            new_retention_rules.update({&#39;retentionPeriodDays&#39;: new_retention_days, &#39;retentionRuleType&#39;: &#34;RETENTION_PERIOD&#34;})

        if new_recovery_points is not None:
            new_retention_rules.update({&#39;retentionPeriodDays&#39;: new_recovery_points, &#39;retentionRuleType&#39;: &#34;SNAP_RECOVERY_POINTS&#34;})

        if new_extended_retention:
            new_retention_rules.update({&#39;useExtendedRetentionRules&#39;: True, &#39;extendedRetentionRules&#39;: new_extended_retention})

        # special property that needs to be sent during edit
        new_retention_rules[&#39;fullBackupTypesToBeRetained&#39;] = &#39;FIRST&#39;

        request_json = {&#39;retentionRules&#39;: new_retention_rules}

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._services[&#39;V5_SERVER_PLAN_COPY&#39;] % (self.plan_id, copy_id), request_json)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to edit copy settings for the plan : [{self.plan_name}] Copy: [{copy_name}] Region: [{current_region_name}]&#39;)

    def delete_copy(self, copy_name: str, region_name: str=None) -&gt; None:
        &#34;&#34;&#34;
        Method to remove a copy from the plan

        Args:
            copy_name (str)   -   name of the copy to be removed
            region_name (str) -   name of the region from which the copy needs to be removed

        Returns:
            None

        Raises:
            SDKException:
                -   if failed to remove the copy from the plan
        &#34;&#34;&#34;
        copy_id = self.get_storage_copy_id(copy_name, region_name)

        flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, self._services[&#39;V4_SERVER_PLAN_COPY&#39;] % (self.plan_id, copy_id))

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to remove copy from the plan: [{self.plan_name}]&#39;)

    def add_region(self, region_name: str) -&gt; None:
        &#34;&#34;&#34;
        Method to add a region to the plan

        Args:
            region_name (str)   -   name of the region that is being added

        Returns:
            None

        Raises:
            SDKException:
                -   if failed to add new region to the plan
        &#34;&#34;&#34;
        region_id = self._commcell_object.regions.get(region_name).region_id

        request_json = {
            &#34;regionToConfigure&#34;: {
                &#34;id&#34;: int(region_id)
            }
        }

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_PLAN, request_json)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to add new region to the plan : [{self.plan_name}]&#39;)

    def remove_region(self, region_name: str) -&gt; None:
        &#34;&#34;&#34;
        Method to remove a region from the plan

        Args:
            region_name (str)   -   name of the region that is being removed

        Returns:
            None

        Raises:
            SDKException:
                -   if failed to remove the region from the plan
        &#34;&#34;&#34;
        region_id = self._commcell_object.regions.get(region_name).region_id

        flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, self._services[&#39;SERVER_PLAN_REGIONS&#39;] % (self.plan_id, region_id))

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to remove region from the plan: [{self.plan_name}]&#39;)

    def get_schedule_properties(self, schedule_filter: dict) -&gt; dict:
        &#34;&#34;&#34;
        Method to get the schedule properties of the plan

        Args:
            schedule_filter (dict) - dictionary containing the filter criteria for the schedule

            Example for schedule filter:

            # select the full backup schedule
                {&#34;backupType&#34;: &#34;FULL&#34;}

            # select the schedule where backup type is incremental and schedule is applicable to all agents
            {&#34;backupType&#34;: &#34;INCREMENTAL&#34;, &#34;forDatabasesOnly&#34;: False}

        Returns:
            dict - schedule properties of the plan

        Raises:
            SDKException:
                - if no schedule is found with the provided filter
                - if multiple schedules are found with the provided filter
        &#34;&#34;&#34;
        schedules = self._v4_plan_properties[&#39;rpo&#39;][&#39;backupFrequency&#39;][&#39;schedules&#39;]
        filtered_schedules = [schedule for schedule in schedules if all(schedule.get(key) == value for key, value in schedule_filter.items())]

        if not filtered_schedules:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;No schedule found with the provided filter: {schedule_filter} for plan: [{self.plan_name}]&#39;)
        
        if len(filtered_schedules) &gt; 1:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Multiple schedules found with the provided filter: {schedule_filter} for plan: [{self.plan_name}]&#39;)

        return copy.deepcopy(filtered_schedules[0]) # return a deep copy to avoid modifying the original schedule properties

    def add_schedule(self, schedule_options: dict) -&gt; None:
        &#34;&#34;&#34;
        Method to add a new schedule to the plan

        Args:
            schedule_options (dict) - schedule options to be added (backupType is mandatory)

            Note: To prepare advanced schedule options, refer to the API documentation or Command Center equivalent API

            Example:

            # create schedule based on backup type and rest use default values
            {&#34;backupType&#34;: &#34;INCREMENTAL&#34;}
            {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;}

            # create schedule with advanced properties
            {
                &#34;backupType&#34;: &#34;FULL&#34;, 
                &#34;schedulePattern&#34;: {
                    &#34;scheduleFrequencyType&#34;: &#34;DAILY&#34;,
                    &#34;startTime&#34;: 75600,
                    &#34;frequency&#34;: 1
                    }
            }

            # specify agents for schedules
            {&#34;backupType&#34;: &#34;INCREMENTAL&#34;, &#34;forDatabasesOnly&#34;: False}
            {&#34;backupType&#34;: &#34;FULL&#34;, &#34;forDatabasesOnly&#34;: True}

            # advance properties for schedules
            {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;, &#34;scheduleOption&#34;: {&#34;useDiskCacheForLogBackups&#34;: True}}

        Returns:
            None

        Raises:
            SDKException:
                - if failed to add the schedule to the plan
        &#34;&#34;&#34;
        schedule_payload = self.plan_v4_helper.get_schedule_payload(schedule_options)
        
        payload = {
            &#34;backupFrequency&#34;: {
                &#34;schedules&#34;: [schedule_payload]
            }
        }
        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._PLAN_RPO, payload)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to add new schedule to the plan: [{self.plan_name}]&#39;)    

    def edit_schedule(self, schedule_options: dict, schedule_filter: dict) -&gt; None:
        &#34;&#34;&#34;
        Method to edit the schedule options of the plan

        Args:
            schedule_options (dict) - schedule options to be edited
            schedule_filter (dict)  - schedule for which the options are to be edited

            Refer to the add_schedule method for the format of the schedule options

            Refer to the get_schedule_properties method for the format of the schedule filter

        Returns:
            None

        Raises:
            SDKException:
                - if failed to edit the schedule options of the plan
        &#34;&#34;&#34;
        schedule_payload = self.get_schedule_properties(schedule_filter)

        schedule_payload[&#39;scheduleOperation&#39;] = &#39;MODIFY&#39;
        # update the payload with the new provided options
        schedule_payload = self.plan_v4_helper.update_payload(schedule_payload, schedule_options)

        payload = {
            &#34;backupFrequency&#34;: {
                &#34;schedules&#34;: [schedule_payload]
            }
        }

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._PLAN_RPO, payload)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to edit schedule options for the plan: [{self.plan_name}]&#39;)

    def delete_schedule(self, schedule_filter: dict) -&gt; None:
        &#34;&#34;&#34;
        Method to delete the schedule from the plan

        Args:
            schedule_filter (dict)  - schedule to be deleted

            Refer to the get_schedule_properties method for the format of the schedule filter

        Returns:
            None

        Raises:
            SDKException:
                - if failed to edit the schedule options of the plan
        &#34;&#34;&#34;
        schedule_payload = self.get_schedule_properties(schedule_filter)
        schedule_payload[&#39;scheduleOperation&#39;] = &#39;DELETE&#39;

        payload = {
            &#34;backupFrequency&#34;: {
                &#34;schedules&#34;: [schedule_payload]
            }
        }

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._PLAN_RPO, payload)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to delete schedule from the plan: [{self.plan_name}]&#39;)

    def edit_snapshot_options(self, enable_backup_copy:bool=True, backup_copy_rpo: int=None) -&gt; None:
        &#34;&#34;&#34;
        Method to edit the snapshot options of the plan

        Args:
            enable_backup_copy (bool)   -   enable backup copy for the plan

            backup_copy_rpo (int)       -   backup copy RPO for the plan

        Returns:
            None

        Raises:
            SDKException:
                -   if failed to edit the snapshot options of the plan
        &#34;&#34;&#34;
        request_json = {
            &#34;snapshotOptions&#34;: {
                &#34;enableBackupCopy&#34;: enable_backup_copy
            }
        }

        if backup_copy_rpo:
            request_json[&#34;snapshotOptions&#34;][&#34;backupCopyRPOMins&#34;] = backup_copy_rpo

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_PLAN, request_json)

        self.__handle_response(flag, response, custom_error_message=f&#39;Failed to edit snapshot settings for the plan : [{self.plan_name}]&#39;)

    def add_storage_copy(self, copy_name, storage_pool, retention=30, extended_retention=None):
        &#34;&#34;&#34;Add a storage copy as backup destination to this plan
            Args:
                copy_name   (str)   -   name of the copy that is being added

                storage_pool (str)  -   name of the storage pool for the copy to be added

                retention   (int)   -   retention period in days for the copy

                extended_retention (tuple)  -   extended retention rules of a copy
                                                Example: [1, True, &#34;EXTENDED_ALLFULL&#34;, 0, 0]
            Returns:
                dict    -   dictionary of all copies of this plan
        &#34;&#34;&#34;
        if isinstance(copy_name, str) and isinstance(storage_pool, str):
            if not self.storage_policy.has_copy(copy_name):
                self.storage_policy.create_secondary_copy(
                    copy_name,
                    global_policy=storage_pool
                )
                self.storage_policy.get_copy(copy_name).copy_retention = (retention, 0, 0)
                if extended_retention:
                    self.storage_policy.get_copy(
                        copy_name).extended_retention_rules = extended_retention
                self.refresh()
                return self.storage_copies
            else:
                err_msg = f&#39;Storage Policy copy &#34;{copy_name}&#34; already exists.&#39;
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Copy name and storage pool name must be a string.&#39;
            )

    def disable_full_schedule(self):
        &#34;&#34;&#34;Disable the full backup schedule of the plan&#34;&#34;&#34;
        try:
            self.schedule_policies[&#39;data&#39;].delete_schedule(schedule_id=list(filter(
                lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
            ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;])
        except IndexError:
            raise IndexError(&#39;Full backup schedule not enabled&#39;)

    def edit_association(self, entities, new_plan=None):
        &#34;&#34;&#34;Reassociates or dissociates the entities from this plan
            Args:
                entities    (list)  --  list containing entity objects whose plan association must be edited
                                        Eg: [
                                            {
                                                &#34;clientName&#34;: &#34;client&#34;,
                                                &#34;subclientName&#34;: &#34;subclient&#34;,
                                                &#34;backupsetName&#34;: &#34;backupset&#34;,
                                                &#34;appName&#34;: &#34;app&#34;
                                            }
                                        ]

                new_plan    (str)   --  new plan to which the associated entities must be reassociated with

            Raises:
                SDKException
                    if plan not found
        &#34;&#34;&#34;
        req_json = {
            &#39;plan&#39;: {
                &#39;planName&#39;: self.plan_name
            },
            &#39;entities&#39;: entities
        }
        if new_plan is not None:
            if self._commcell_object.plans.has_plan(new_plan):
                req_json.update({
                    &#39;planOperationType&#39;: &#39;OVERWRITE&#39;,
                    &#39;newPlan&#39;: {
                        &#39;planName&#39;: new_plan
                    }
                })
            else:
                SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                    new_plan)
                )
        else:
            req_json.update({
                &#39;planOperationType&#39;: &#39;DELETE&#39;
            })
        req_url = self._services[&#39;ASSOCIATED_ENTITIES&#39;] % (self._plan_id)
        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, req_url, req_json
        )

        if flag:
            if &#39;response&#39; in response.json():
                error_code = str(response.json()[&#34;response&#34;][0][&#34;errorCode&#34;])

                if error_code == &#34;0&#34;:
                    self.refresh()
                    return
            else:
                error_message = str(response.json()[&#34;errorMessage&#34;])
                o_str = &#39;Failed to edit plan associated entities\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_message))
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _update_plan_props(self, props):
        &#34;&#34;&#34;Updates the properties of the plan

            Args:
                props   (dict)  --  dictionary containing the properties to be updated
                                    {
                                        &#39;planName&#39;: &#39;NewName&#39;
                                    }

            Raises:
                SDKException
                    if there is failure in updating the plan
        &#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, self._PLAN, props
        )
        if flag:
            if response.json():
                error_code = str(response.json()[&#34;errors&#34;][0][&#34;status&#34;][&#34;errorCode&#34;])
                error_message = str(response.json()[&#34;errors&#34;][0][&#34;status&#34;][&#34;errorMessage&#34;])

                if error_code == &#34;0&#34;:
                    self.refresh()
                    return (True, error_code)
                else:
                    return (False, error_code, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_associated_entities(self):
        &#34;&#34;&#34;Gets all the backup entities associated with the plan.

            Returns:
                dict - dictionary containing list of entities that are
                       associated with the plan.

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        request_url = self._services[&#39;ASSOCIATED_ENTITIES&#39;] % (self._plan_id)
        flag, response = self._cvpysdk_object.make_request(
            &#39;GET&#39;, request_url
        )

        if flag:
            if response.json() and &#39;entities&#39; in response.json():
                self._associated_entities = response.json()[&#39;entities&#39;]
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def plan_id(self):
        &#34;&#34;&#34;Treats the plan id as a read-only attribute.&#34;&#34;&#34;
        return self._plan_id

    @property
    def plan_name(self):
        &#34;&#34;&#34;Treats the plan name as a read-only attribute.&#34;&#34;&#34;
        return self._plan_name

    @plan_name.setter
    def plan_name(self, value: str):
        &#34;&#34;&#34;modifies the plan name&#34;&#34;&#34;
        # use v4 API for server plans
        if self.subtype == 33554437:
            req_json = {
                &#34;newName&#34;: value
            }

            flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_PLAN, req_json)

            self.__handle_response(flag, response, custom_error_message=f&#39;Failed to update the plan name: [{self._plan_name}]&#39;)
            return

        if isinstance(value, str):
            req_json = {
                &#39;summary&#39;: {
                    &#39;plan&#39;: {
                        &#39;planName&#39;: value
                    }
                }
            }
            resp = self._update_plan_props(req_json)

            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan name\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan name must be a string value&#39;
            )

    @property
    def sla_in_minutes(self):
        &#34;&#34;&#34;Treats the plan SLA/RPO as a read-only attribute.&#34;&#34;&#34;
        return self._sla_in_minutes

    @sla_in_minutes.setter
    def sla_in_minutes(self, value):
        &#34;&#34;&#34;Modifies the plan SLA/RPO&#34;&#34;&#34;
        if isinstance(value, int):
            req_json = {
                &#39;summary&#39;: {
                    &#39;slaInMinutes&#39;: value
                }
            }
            resp = self._update_plan_props(req_json)

            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan SLA\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan SLA must be an int value&#39;
            )

    @property
    def operation_window(self):
        &#34;&#34;&#34;Treats the plan incremental operation window as a read-only attribute&#34;&#34;&#34;
        return self._operation_window

    @operation_window.setter
    def operation_window(self, value):
        &#34;&#34;&#34;Modifies the incremental operation window of the plan

            Args:
                value   (list)    --  list of time slots for setting the backup window

                value   (None)      --  set value to None to clear the operation window

            Raises:
                SDKException:
                    if the input is incorrect

                    if the operation window configuration fails
        &#34;&#34;&#34;
        if isinstance(value, list):
            req_json = {
                &#34;operationWindow&#34;: {
                    &#34;operations&#34;: [
                        2,
                        4
                    ],
                    &#34;dayTime&#34;: value
                }
            }
            resp = self._update_plan_props(req_json)
            if resp[0]:
                self.refresh()
                return
            else:
                o_str = &#39;Failed to update the operation window\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        elif value is None:
            self._commcell_object.operation_window.delete_operation_window(
                rule_id=self._operation_window[&#39;ruleId&#39;]
            )
            self.refresh()
            return
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan operation window must be a list value or None&#39;
            )

    @property
    def full_operation_window(self):
        &#34;&#34;&#34;Treats the plan full backup operation window as a read-only attribute&#34;&#34;&#34;
        return self._full_operation_window

    @full_operation_window.setter
    def full_operation_window(self, value):
        &#34;&#34;&#34;Modifies the full backup operation window of the plan

            Args:
                value   (list)    --  list of time slots for setting the backup window

                value   (None)      --  set value to None to clear the operation window

            Raises:
                SDKException:
                    if the input is incorrect

                    if the operation window configuration fails
        &#34;&#34;&#34;
        if isinstance(value, list):
            req_json = {
                &#34;operationWindow&#34;: {
                    &#34;operations&#34;: [
                        1,
                    ],
                    &#34;dayTime&#34;: value
                }
            }
            resp = self._update_plan_props(req_json)
            if resp[0]:
                self.refresh()
                return
            else:
                o_str = &#39;Failed to update the full operation window\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        elif value is None:
            self._commcell_object.operation_window.delete_operation_window(
                rule_id=self._full_operation_window[&#39;ruleId&#39;]
            )
            self.refresh()
            return
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan full operation window must be a list value or None&#39;
            )

    @property
    def plan_type(self):
        &#34;&#34;&#34;Treats the plan type as a read-only attribute.&#34;&#34;&#34;
        return self._plan_type

    @property
    def subtype(self):
        &#34;&#34;&#34;Treats the plan subtype as a read-only attribute.&#34;&#34;&#34;
        return self._subtype

    @property
    def override_entities(self):
        &#34;&#34;&#34;Treats the plan override_entities as a read-only attribute.&#34;&#34;&#34;
        return self._override_entities

    @override_entities.setter
    def override_entities(self, value):
        &#34;&#34;&#34;Sets the override restrictions for the plan&#34;&#34;&#34;
        req_json = {
            &#34;inheritance&#34;: {
                &#34;isSealed&#34;: False,
                &#34;enforcedEntitiesOperationType&#34;: 1,
                &#34;privateEntitiesOperationType&#34;: 1
            }
        }
        if isinstance(value, dict):
            req_json[&#39;inheritance&#39;].update(value)
            resp = self._update_plan_props(req_json)
            if resp[0]:
                return
            else:
                o_str = &#39;Failed to update the plan override restrictions\nError: &#34;{0}&#34;&#39;
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(resp[2]))
        else:
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Override restrictions must be defined in a dict&#39;
            )

    def __set_storage_policy(self):
        &#34;&#34;&#34;Method to set the storage policy of the plan&#34;&#34;&#34;
        self._commcell_object.storage_policies.refresh()
        storage_policy_name = self._plan_properties.get(&#39;storage&#39;, {}).get(&#39;storagePolicy&#39;, {}).get(&#39;storagePolicyName&#39;)
        if storage_policy_name and self._commcell_object.storage_policies.has_policy(storage_policy_name):
            self._child_policies[&#39;storagePolicy&#39;] = self._commcell_object.storage_policies.get(storage_policy_name)
        else:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Failed to fetch storage policy: {storage_policy_name}&#39;)

    @property
    def storage_policy(self):
        &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
        if not self._child_policies.get(&#39;storagePolicy&#39;):
            self.__set_storage_policy()

        return self._child_policies.get(&#39;storagePolicy&#39;)

    @property
    def all_copies(self) -&gt; list:
        &#34;&#34;&#34;
        Treats the plan&#39;s all storage copies as a read-only attribute

        Returns:
            list -- list of all the copies
        &#34;&#34;&#34;
        return self._all_copies

    @property
    def storage_copies(self):
        &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
        return self._storage_copies

    def __set_schedule_policies(self):
        &#34;&#34;&#34;Sets the schedule policies for the plan&#34;&#34;&#34;
        self._commcell_object.schedule_policies.refresh()
        data_schedule_policy_exists = self._plan_properties.get(&#39;schedule&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;)
        log_schedule_policy_exists = self._plan_properties.get(&#39;database&#39;, {}).get(&#39;scheduleLog&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;)
        snap_schedule_policy_exists = self._plan_properties.get(&#39;snapInfo&#39;, {}).get(&#39;snapTask&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;)

        if data_schedule_policy_exists:
            self._child_policies[&#39;schedulePolicy&#39;][&#39;data&#39;] = self.data_schedule_policy

        if log_schedule_policy_exists:
            self._child_policies[&#39;schedulePolicy&#39;][&#39;log&#39;] = self.log_schedule_policy

        if snap_schedule_policy_exists:
            self._child_policies[&#39;schedulePolicy&#39;][&#39;snap&#39;] = self.snap_schedule_policy

    @property
    def schedule_policies(self):
        &#34;&#34;&#34;Treats the plan schedule policies as read-only attribute&#34;&#34;&#34;
        if not self._child_policies.get(&#39;schedulePolicy&#39;):
            self.__set_schedule_policies()

        return self._child_policies.get(&#39;schedulePolicy&#39;)

    def __get_schedule_policy(self, policy_type: str) -&gt; object:
        &#34;&#34;&#34;
        Returns the schedule policy object of the given policy type

        Args:
            policy_type (str)  --  type of schedule policy to be fetched
                            Eg: &#39;data&#39;, &#39;log&#39;, &#39;snap&#39;

        Returns:
            object  --  schedule policy object
        &#34;&#34;&#34;
        policy_name = &#39;&#39;
        policy_type = policy_type.lower()

        if policy_type == &#39;data&#39;:
            policy_name = self._plan_properties.get(&#39;schedule&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;, &#39;&#39;)
        elif policy_type == &#39;log&#39;:
            policy_name = self._plan_properties.get(&#39;database&#39;, {}).get(&#39;scheduleLog&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;, &#39;&#39;)
        elif policy_type == &#39;snap&#39;:
            policy_name = self._plan_properties.get(&#39;snapInfo&#39;, {}).get(&#39;snapTask&#39;, {}).get(&#39;task&#39;, {}).get(&#39;taskName&#39;, &#39;&#39;)
        else:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid schedule policy type&#39;)

        schedule_policies = self._commcell_object.schedule_policies

        if not schedule_policies.has_policy(policy_name):
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Failed to fetch schedule policies&#39;)

        return schedule_policies.get(policy_name)

    @property
    def data_schedule_policy(self) -&gt; object:
        &#34;&#34;&#34;
            Treats the plan data scheduler policy as read-only attribute

            Returns:
                object  -   data schedule policy object
        &#34;&#34;&#34;
        if not self._data_schedule_policy:
            self._data_schedule_policy = self.__get_schedule_policy(&#39;data&#39;)
        return self._data_schedule_policy

    @property
    def log_schedule_policy(self) -&gt; object:
        &#34;&#34;&#34;
            Treats the plan log schedule policy as read-only attribute

            Returns:
                object  -   log schedule policy object
        &#34;&#34;&#34;
        if not self._log_schedule_policy:
            self._log_schedule_policy = self.__get_schedule_policy(&#39;log&#39;)
        return self._log_schedule_policy

    @property
    def snap_schedule_policy(self) -&gt; object:
        &#34;&#34;&#34;
            Treats the plan snap schedule policy as read-only attribute

            Returns:
                object  -   snap schedule policy object
        &#34;&#34;&#34;
        if not self._snap_schedule_policy:
            self._snap_schedule_policy = self.__get_schedule_policy(&#39;snap&#39;)
        return self._snap_schedule_policy

    @property
    def addons(self):
        &#34;&#34;&#34;Treats the plan addons as read-only attribute&#34;&#34;&#34;
        for addon in self._plan_properties.get(&#39;summary&#39;, {}).get(&#39;addons&#39;, []):
            self._addons.append(
                addon
            )
        return self._addons

    def __set_subclient_policy_ids(self):
        &#34;&#34;&#34;Sets the subclient policy ids for the plan&#34;&#34;&#34;
        backup_content = self._plan_properties.get(&#39;laptop&#39;, {}).get(&#39;content&#39;, {}).get(&#39;backupContent&#39;, [])

        self._child_policies[&#39;subclientPolicyIds&#39;] = [
            ida[&#39;subClientPolicy&#39;][&#39;backupSetEntity&#39;][&#39;backupsetId&#39;]
            for ida in backup_content
            if ida.get(&#39;subClientPolicy&#39;, {}).get(&#39;backupSetEntity&#39;, {}).get(&#39;backupsetId&#39;)
        ]

    @property
    def subclient_policy(self):
        &#34;&#34;&#34;Treats the plan subclient policy as a read-only attribute&#34;&#34;&#34;
        if not self._child_policies.get(&#39;subclientPolicyIds&#39;):
            self.__set_subclient_policy_ids()

        return self._child_policies.get(&#39;subclientPolicyIds&#39;)

    @property
    def associated_entities(self):
        &#34;&#34;&#34;getter for the backup entities associated with the plan&#34;&#34;&#34;
        return self._associated_entities

    @property
    def parent_plan(self):
        &#34;&#34;&#34;getter for the parent plan of a derived plan&#34;&#34;&#34;
        return self._commcell_object.plans.get(self._parent_plan_name)

    @property
    def security_associations(self):
        &#34;&#34;&#34;getter for the plan&#39;s security associations
            Eg:
                {
                    &#39;sample_user_group_name&#39;: &#39;role_name&#39;
                }
        &#34;&#34;&#34;
        return self._security_associations

    def update_security_associations(self, associations_list, is_user = True, request_type = None, external_group = False):
        &#34;&#34;&#34;
        Adds the security association on the plan object

        Args:
            associations_list   (list)  --  list of users to be associated
                Example:
                    associations_list = [
                        {
                            &#39;user_name&#39;: user1,
                            &#39;role_name&#39;: role1
                        },
                        {
                            &#39;user_name&#39;: user2,
                            &#39;role_name&#39;: role2
                        }
                    ]
 
            is_user (bool)           --    True or False. set is_user = False, If associations_list made up of user groups
            request_type (str)      --    eg : &#39;OVERWRITE&#39; or &#39;UPDATE&#39; or &#39;DELETE&#39;, Default will be OVERWRITE operation
            external_group (bool)    --    True or False, set external_group = True. If Security associations is being done on External User Groups

        Raises:
            SDKException:
                if association is not of List type
        &#34;&#34;&#34;
        if not isinstance(associations_list, list):
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;)

        SecurityAssociation(self._commcell_object, self)._add_security_association(associations_list, 
                                        is_user, request_type, external_group)

    @property
    def content_indexing_props(self):
        &#34;&#34;&#34;returns the DC plan related CI properties from Plan&#34;&#34;&#34;
        return self._dc_plan_props

    @property
    def content_indexing(self):
        &#34;&#34;&#34;Returns the Content Indexing status of O365 plan&#34;&#34;&#34;
        try:
            ci_status = (self.properties.get(&#34;office365Info&#34;,{})
                         .get(&#34;o365Exchange&#34;,{})
                         .get(&#34;mbArchiving&#34;, {})
                         .get(&#34;detail&#34;, {})
                         .get(&#34;emailPolicy&#34;, {})
                         .get(&#34;archivePolicy&#34;, {})
                         .get(&#34;contentIndexProps&#34;, {})
                         .get(&#34;enableContentIndex&#34;, {}))
        except:
            ci_status= None
        return ci_status

    @content_indexing.setter
    def content_indexing(self, value: bool):
        &#34;&#34;&#34;Sets content indexing value for O365 plan&#34;&#34;&#34;
        self._enable_content_indexing_o365_plan(value)


    @property
    def properties(self):
        &#34;&#34;&#34;Returns the configured properties for the Plan&#34;&#34;&#34;
        return self._plan_properties

    @property
    def region_id(self):
        &#34;&#34;&#34;Returns the Backup destination region id&#34;&#34;&#34;
        return self._region_id

    @property
    def company(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the company of the plan

        return:
            str --  company&#39;s domain name
        &#34;&#34;&#34;
        return self._provider_domain_name

    @property
    def resources(self) -&gt; list:
        &#34;&#34;&#34;
        Returns the resources stored in storage resource pool

        return:
            list --  plan&#39;s resources
        &#34;&#34;&#34;
        return self._resources

    def refresh(self):
        &#34;&#34;&#34;Refresh the properties of the Plan.&#34;&#34;&#34;
        self._properties = self._get_plan_properties()

        # fetch v4 properties for server plans
        if self.subtype == 33554437:
            self._v4_plan_properties = self._get_v4_plan_properties()

        # lazy loading of properties
        self._data_schedule_policy = None
        self._log_schedule_policy = None
        self._snap_schedule_policy = None
        self._child_policies = {
            &#39;storagePolicy&#39;: None,
            &#39;schedulePolicy&#39;: {},
            &#39;subclientPolicyIds&#39;: []
        } # reset to constructor state

    def associate_user(self, userlist, send_invite=True):
        &#34;&#34;&#34;associates the users to the plan.
            # TODO: Need to handle user groups.

           Arguments:
                userlist(list) - list of users to be associated to the plans.

            Raises:
                SDKException:
                    if response is empty

                    if response is not success

        &#34;&#34;&#34;
        users_list = []

        for user in userlist:
            if self._commcell_object.users.has_user(user):
                temp = self._commcell_object.users.get(user)

                temp_dict = {
                    &#39;sendInvite&#39;: send_invite,
                    &#39;user&#39;: {
                        &#39;userName&#39;: temp.user_name,
                        &#39;userId&#39;: int(temp.user_id)
                    }
                }

                users_list.append(temp_dict)

        request_json = {
            &#34;userOperationType&#34;: 1,
            &#34;users&#34;: users_list
        }

        flag, response = self._cvpysdk_object.make_request(
            &#39;PUT&#39;, self._ADD_USERS_TO_PLAN, request_json
        )

        if flag:
            if response.json() and &#39;errors&#39; in response.json():
                for error in response.json()[&#34;errors&#34;]:
                    error_code = error[&#34;status&#34;][&#34;errorCode&#34;]

                    if error_code == 0:
                        pass
                    else:
                        o_str = &#39;Failed to add users with error code: &#34;{0}&#34;&#39;
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_code))
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def share(self, user_or_group_name, role_name, is_user=True, ops_type=1):
        &#34;&#34;&#34;Shares plan with given user or group by associating with given role

                Args:

                    user_or_group_name      (str)       --  User or Group name to which we are sharing

                    role_name               (str)       --  Role name which needs to associated with

                    ops_type                (int)       --  Operation type

                                                            Default : 1 (Add)

                                                            Supported : 1 (Add)
                                                                        3 (Delete)

                Returns:

                    None

                Raises:

                    SDKException:

                            if input is not valid

                            if failed to do sharing

                            if user/group/role not exists on commcell

                            if failed to get exisitng association details

        &#34;&#34;&#34;
        if not isinstance(user_or_group_name, str) or not isinstance(role_name, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        if ops_type not in [1, 3]:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Sharing operation type provided is not supported&#34;)
        if is_user:
            if not self._commcell_object.users.has_user(user_or_group_name):
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;User doesn&#39;t exists in the commcell&#34;)
        if not self._commcell_object.roles.has_role(role_name=role_name):
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Role doesn&#39;t exists in the commcell&#34;)
        request_json = copy.deepcopy(PlanConstants.PLAN_SHARE_REQUEST_JSON)
        association_response = None
        if ops_type == 1 and len(self.security_associations) &gt; 1:
            association_request_json = copy.deepcopy(PlanConstants.PLAN_SHARE_REQUEST_JSON)
            del association_request_json[&#39;securityAssociations&#39;]
            association_request_json[&#39;entityAssociated&#39;][&#39;entity&#39;][0][&#39;entityId&#39;] = int(self._plan_id)
            flag, response = self._cvpysdk_object.make_request(
                &#39;GET&#39;, self._API_SECURITY_ENTITY %
                (self._plan_entity_type, int(
                    self._plan_id)), association_request_json)
            if flag:
                if response.json() and &#39;securityAssociations&#39; in response.json():
                    association_response = response.json(
                    )[&#39;securityAssociations&#39;][0][&#39;securityAssociations&#39;][&#39;associations&#39;]
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Failed to get existing security associations&#39;)
            else:
                response_string = self._commcell_object._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        external_user = False
        if &#39;\\&#39; in user_or_group_name:
            external_user = True
        if is_user:
            user_obj = self._commcell_object.users.get(user_or_group_name)
            user_id = user_obj.user_id
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;userId&#39;] = int(user_id)
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;_type_&#39;] = 13
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;userName&#39;] = user_or_group_name
        elif external_user:
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;groupId&#39;] = 0
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;_type_&#39;] = 62
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][
                &#39;externalGroupName&#39;] = user_or_group_name
        else:
            grp_obj = self._commcell_object.user_groups.get(user_or_group_name)
            grp_id = grp_obj.user_group_id
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;userGroupId&#39;] = int(grp_id)
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;_type_&#39;] = 15
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][
                &#39;userGroupName&#39;] = user_or_group_name

        request_json[&#39;entityAssociated&#39;][&#39;entity&#39;][0][&#39;entityId&#39;] = int(self._plan_id)
        request_json[&#39;securityAssociations&#39;][&#39;associationsOperationType&#39;] = ops_type
        role_obj = self._commcell_object.roles.get(role_name)
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;properties&#39;][&#39;role&#39;][&#39;roleId&#39;] = role_obj.role_id
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;] = role_obj.role_name

        # Associate existing associations to the request
        if ops_type == 1 and len(self.security_associations) &gt; 1:
            request_json[&#39;securityAssociations&#39;][&#39;associations&#39;].extend(association_response)

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._API_SECURITY, request_json
        )
        if flag:
            if response.json() and &#39;response&#39; in response.json():
                response_json = response.json()[&#39;response&#39;][0]
                error_code = response_json[&#39;errorCode&#39;]
                if error_code != 0:
                    error_message = response_json[&#39;errorString&#39;]
                    raise SDKException(
                        &#39;Plan&#39;,
                        &#39;102&#39;, error_message)
                self.refresh()
            else:
                raise SDKException(&#39;Plan&#39;, &#39;105&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def schedule(self, schedule_name, pattern_json, ops_type=2):
        &#34;&#34;&#34;Creates or modifies the schedule associated with plan

                Args:

                    schedule_name       (str)       --  Schedule name

                    pattern_json        (dict)      --  Schedule pattern dict (Refer to Create_schedule_pattern in schedule.py)

                    ops_type            (int)       --  Operation type

                                                            Default : 2 (Add)

                                                            Supported : 2 (Add/Modify)

                Raises:

                      SDKException:

                            if input is not valid

                            if failed to create/modify schedule

                            if plan is not of type Data classification plan

        &#34;&#34;&#34;
        if not isinstance(schedule_name, str) or not isinstance(pattern_json, dict):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        if self.plan_type not in [PlanTypes.DC.value]:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Add/Modify Schedule is supported only for DC Plan via CvpySDK&#34;)
        if ops_type not in [2]:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Schedule operation type provided is not supported&#34;)
        request_json = copy.deepcopy(PlanConstants.PLAN_SCHEDULE_REQUEST_JSON[self.plan_type])
        request_json[&#39;summary&#39;][&#39;plan&#39;][&#39;planId&#39;] = int(self.plan_id)
        request_json[&#39;schedule&#39;][&#39;associations&#39;][0][&#39;entityId&#39;] = int(self.plan_id)
        request_json[&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;] = f&#34;Cvpysdk created Schedule policy for plan - {self.plan_name}&#34;
        request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;subTask&#39;][
            &#39;subTaskName&#39;] = schedule_name
        request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;pattern&#39;] = pattern_json
        request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;adminOpts&#39;][&#39;contentIndexingOption&#39;][&#39;operationType&#39;] = ops_type
        if self._dc_plan_props[&#39;targetApps&#39;][0] == TargetApps.FS.value:
            request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;subTask&#39;][&#39;operationType&#39;] = 5022
        self._update_plan_props(request_json)

    def edit_plan(self, **kwargs):
        &#34;&#34;&#34;Edit plan options

                Args:

                    **kwargs for Data Classification Plan

                    index_content       (bool)      --  Speifies whether to index content or not to index server

                    content_analyzer    (list)      --  list of Content analyzer client name

                    entity_list         (list)      --  list of entities which needs to be extracted

                    classifier_list     (list)      --  list of classifier which needs to be classified

                    enable_ocr          (bool)      --  specifies whether OCR is enabled or not

                    ocr_language        (int)       --  Language to be used when doing OCR
                                                            Default : English (Value-1)

                     Supported Languages:

                                    ENGLISH = 1,
                                    HEBREW = 2,
                                    SPANISH = 3,
                                    FRENCH = 4,
                                    ITALIAN = 5,
                                    DANISH = 6

                    include_docs        (str)       --  Include documents type separated by comma

                    exclude_path        (list)      --  List of paths which needs to be excluded

                    min_doc_size        (int)       --  Minimum document size in MB

                    max_doc_size        (int)       --  Maximum document size in MB
        &#34;&#34;&#34;
        if self.plan_type != PlanTypes.DC.value:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Function Not supported for this plan type&#34;)
        extraction_policy_list = []
        request_json = None
        if self.plan_type == PlanTypes.DC.value:
            request_json = copy.deepcopy(PlanConstants.PLAN_UPDATE_REQUEST_JSON[self.plan_type])
            request_json[&#39;summary&#39;][&#39;plan&#39;][&#39;planId&#39;] = int(self.plan_id)
            if TargetApps.SDG.value in self.content_indexing_props[&#39;targetApps&#39;]:
                request_json[&#39;eePolicyInfo&#39;][&#39;eePolicy&#39;][&#39;detail&#39;][&#39;eePolicy&#39;] = self.content_indexing_props[&#39;eePolicy&#39;]
                request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;] = self.content_indexing_props[&#39;ciPolicy&#39;]
                activate_obj = self._commcell_object.activate
                if &#39;content_analyzer&#39; in kwargs:
                    ca_list = []
                    for ca in kwargs.get(&#39;content_analyzer&#39;, []):
                        ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                        ca_list.append({
                            &#39;clientId&#39;: ca_client_id
                        })
                    request_json[&#39;eDiscoveryInfo&#39;] = {
                        &#39;contentAnalyzerClient&#39;: ca_list}
                if &#39;entity_list&#39; in kwargs or &#39;classifier_list&#39; in kwargs:
                    entity_mgr_obj = activate_obj.entity_manager()
                    # classifier is also an activate entity with type alone different so
                    # append this to entity list itself
                    entity_list = []
                    for entity in kwargs.get(&#39;entity_list&#39;, []):
                        entity_list.append(entity)
                    for entity in kwargs.get(&#39;classifier_list&#39;, []):
                        entity_list.append(entity)
                    for entity in entity_list:
                        entity_obj = entity_mgr_obj.get(entity)
                        extraction_policy_list.append(entity_obj.container_details)
                    request_json[&#39;eePolicyInfo&#39;][&#39;eePolicy&#39;][&#39;detail&#39;][&#39;eePolicy&#39;][&#39;extractionPolicy&#39;][&#39;extractionPolicyList&#39;] = extraction_policy_list

                if &#39;enable_ocr&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;enableImageExtraction&#39;] = kwargs.get(
                        &#39;enable_ocr&#39;, False)
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;ocrLanguages&#39;] = [
                        kwargs.get(&#39;ocr_language&#39;, 1)]
                if &#39;include_docs&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
                        &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
                if &#39;min_doc_size&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
                        &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
                if &#39;max_doc_size&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                        &#39;maxDocSize&#39;] = kwargs.get(&#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
                if &#39;exclude_path&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                        &#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, PlanConstants.DEFAULT_EXCLUDE_LIST)
                if &#39;index_content&#39; in kwargs:
                    request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;opType&#39;] = kwargs.get(
                        &#39;index_content&#39;, PlanConstants.INDEXING_ONLY_METADATA)
            elif TargetApps.FSO.value in self.content_indexing_props[&#39;targetApps&#39;]:
                # currently we dont have any thing to update in DC plan for FSO app so throw exception
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;No attributes to Edit for DC Plan with TargetApps as : FSO&#39;)
        self._update_plan_props(request_json)

    def edit_risk_analysis_dc_plan(self, **kwargs):
        &#34;&#34;&#34;
        Edit Risk Analysis Data Classification Plan options
            Args:
            **kwargs for risk analysis Data Classification Plan
            index_content       (bool)      --  Specifies whether to index content or not to index server
            content_analyzer    (list)      --  list of Content analyzer client name
            entity_list         (list)      --  list of entities which needs to be extracted
            classifier_list     (list)      --  list of classifier which needs to be classified
            enable_ocr          (bool)      --  specifies whether OCR is enabled or not
            ocr_language        (int)       --  Language to be used when doing OCR
                                                Default : English (Value-1)
                Supported Languages:
                            ENGLISH = 1,
                            HEBREW = 2,
                            SPANISH = 3,
                            FRENCH = 4,
                            ITALIAN = 5,
                            DANISH = 6
            include_docs        (str)       --  Include documents type separated by comma
            exclude_path        (list)      --  List of paths which needs to be excluded
            min_doc_size        (int)       --  Minimum document size in MB
            max_doc_size        (int)       --  Maximum document size in MB
        &#34;&#34;&#34;
        if self.plan_type != PlanTypes.DC.value:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Function Not supported for this plan type&#34;)
        request_json = {}
        if self.plan_type == PlanTypes.DC.value:
            if &#39;content_analyzer&#39; in kwargs:
                # change to support SaaS and unification project
                ca_list = []
                for ca in kwargs.get(&#39;content_analyzer&#39;, []):
                    ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                    ca_list.append({
                        &#39;id&#39;: ca_client_id
                    })
                request_json[&#39;contentAnalyzer&#39;] = ca_list

            request_json[&#39;entityDetection&#39;] = {}
            activate_obj = self._commcell_object.activate
            entity_mgr_obj = activate_obj.entity_manager()
            if &#39;entity_list&#39; in kwargs:
                entity_list = []
                entity_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;entity_list&#39;, []))
                for entity_id in entity_ids:
                    entity_list.append({&#34;id&#34;: entity_id})
                request_json[&#39;entityDetection&#39;][&#34;entities&#34;] = entity_list
            if &#39;classifier_list&#39; in kwargs:
                classifier_list = []
                classifier_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;classifier_list&#39;, []))
                for classifier_id in classifier_ids:
                    classifier_list.append({&#34;id&#34;: classifier_id})
                request_json[&#39;entityDetection&#39;][&#34;classifiers&#34;] = classifier_list

            request_json[&#39;contentIndexing&#39;] = {}
            if &#39;index_content&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#34;searchType&#34;] = kwargs.get(
                    &#39;index_content&#39;, PlanConstants.RAPlanSearchType.SEARCH_TYPE_ONLY_METADATA).value
            if &#39;enable_ocr&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#34;extractTextFromImage&#34;] = kwargs.get(&#39;enable_ocr&#39;, False)
                request_json[&#39;contentIndexing&#39;][&#34;contentLanguage&#34;] = kwargs.get(&#39;ocr_language&#39;, 1)

            request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;] = {}
            if &#39;include_docs&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
                    &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
            if &#39;min_doc_size&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
                    &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
            if &#39;max_doc_size&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;maxDocSize&#39;] = kwargs.get(
                    &#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
            if &#39;exclude_path&#39; in kwargs:
                request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, [])

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_DC_PLAN, request_json)
        self.__handle_response(flag, response, custom_error_message=&#39;Failed to edit risk analysis DC plan : &#39;
                                                                    f&#39;[{self.plan_name}]&#39;)

    def _enable_content_indexing_o365_plan(self, value):
        &#34;&#34;&#34;Enable CI for O365 plan

            Args:
                value (bool)  --- specifies whether to content index or not

            Returns:
                None
        &#34;&#34;&#34;
        request_json = copy.deepcopy(PlanConstants.PLAN_UPDATE_REQUEST_JSON[self.plan_type])

        request_json[&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = self.plan_name
        request_json[&#39;summary&#39;][&#39;plan&#39;][&#39;planId&#39;] = int(self.plan_id)
        o365_arch = request_json[&#39;office365Info&#39;][&#39;o365Exchange&#39;][&#39;mbArchiving&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;]
        o365_arch[&#39;archivePolicy&#39;][&#39;contentIndexProps&#39;][&#39;enableContentIndex&#39;] = value

        o365_cloud = request_json[&#39;office365Info&#39;][&#39;o365CloudOffice&#39;][&#39;caBackup&#39;][&#39;detail&#39;][&#39;cloudAppPolicy&#39;][
            &#39;backupPolicy&#39;]
        o365_cloud[&#39;onedrivebackupPolicy&#39;][&#39;enableContentIndex&#39;] = value
        o365_cloud[&#39;spbackupPolicy&#39;][&#39;enableContentIndex&#39;] = value
        o365_cloud[&#39;teamsbackupPolicy&#39;][&#39;enableContentIndex&#39;] = value

        request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
            &#39;includeDocTypes&#39;] = PlanConstants.DEFAULT_INCLUDE_DOC_TYPES
        request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
            &#39;minDocSize&#39;] = PlanConstants.DEFAULT_MIN_DOC_SIZE

        request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
            &#39;maxDocSize&#39;] = PlanConstants.DEFAULT_MAX_DOC_SIZE
        request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][
            &#39;opType&#39;] = PlanConstants.INDEXING_METADATA_AND_CONTENT
        request_json[&#39;ciPolicy&#39;] = request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;]

        self._update_plan_props(request_json)

    def policy_subclient_ids(self):
        &#34;&#34;&#34;Returns Policy subclient IDs of the plan
        
        Returns:
            dict : OS and its associated subclient ID
        
        example:
            {
                &#39;Windows&#39; : windows_subclient_policy_subclient_id,
                &#39;Linux&#39; : linux_subclient_policy_subclient_id,
                &#39;Mac&#39; : mac_subclient_policy_subclient_id
            }
        
        &#34;&#34;&#34;
        result = dict()
        for backupset_id in self.subclient_policy:
            url = self._commcell_object._services[&#39;ADD_SUBCLIENT&#39;] + &#39;?clientId=2&amp;applicationId=1030&amp;backupsetid=&#39; + str(backupset_id)

            flag, response = self._commcell_object._cvpysdk_object.make_request(&#39;GET&#39;, url)
            if flag:
                if response.json() and &#39;subClientProperties&#39; in response.json():
                    subclient_id = response.json()[&#39;subClientProperties&#39;][0][&#39;subClientEntity&#39;][&#39;subclientId&#39;]
                    backupset_name = response.json()[&#39;subClientProperties&#39;][0][&#39;subClientEntity&#39;][&#39;backupsetName&#39;]
                    os = backupset_name.split()[-3]
                    result[os] = subclient_id
                else:
                    raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to get subclient Ids.&#39;)
            else:
                raise SDKException(&#39;Plan&#39;, 102, response.text)
            
        return result
    
    def __update_content_policy(self, content):
        &#34;&#34;&#34;
        Args:
            content (dict)  :  dictionary with backup content details. 
            
            example:
                content = {
                    &#34;windowsIncludedPaths&#34;: [&#34;Desktop&#34;],
                    &#34;windowsExcludedPaths&#34;: [&#34;Music&#34;],
                    &#34;windowsFilterToExcludePaths&#34;: [&#34;Videos&#34;],
                    &#34;unixIncludedPaths&#34;: [&#34;Desktop&#34;],
                    &#34;unixExcludedPaths&#34;: [&#34;Music&#34;],
                    &#34;unixFilterToExcludePaths&#34;: [&#34;Videos&#34;],
                    &#34;macIncludedPaths&#34;: [&#34;Desktop&#34;],
                    &#34;macExcludedPaths&#34;: [&#34;Music&#34;],
                    &#34;macFilterToExcludePaths&#34;: [&#34;Videos&#34;],
                    &#34;backupSystemState&#34;: True,
                    &#34;useVSSForSystemState&#34;: True,
                    &#34;backupSystemStateOnlyWithFullBackup&#34;: False
                }

            For unix and mac, replace key name with respective os name, **IncludedPaths, **ExcludedPaths, **FilterToExcludePaths

        &#34;&#34;&#34;
        
        request_json = {
            &#39;backupContent&#39; : content
        }

        request_url = self._commcell_object._services[&#39;V4_SERVER_PLAN&#39;] % self.plan_id

        flag, response = self._commcell_object._cvpysdk_object.make_request(&#39;PUT&#39;, request_url, request_json)

        self.__handle_response(flag, response, f&#39;Failed to update backup content for Plan: {self.plan_name}&#39;)

    def __map_content_to_new_format(self, content):
        &#34;&#34;&#34;
            Method to map old content format to new format (if we need to update the content policy of plan)
            
            Note: We cannot remove the old format as it is still can be used to modify the content of plans created before SP32. So mapping old content to new ones as needed.
        &#34;&#34;&#34;
        result = {
            &#34;windowsIncludedPaths&#34;: [],
            &#34;windowsExcludedPaths&#34;: [],
            &#34;windowsFilterToExcludePaths&#34;: [],
            &#34;unixIncludedPaths&#34;: [],
            &#34;unixExcludedPaths&#34;: [],
            &#34;unixFilterToExcludePaths&#34;: [],
            &#34;macIncludedPaths&#34;: [],
            &#34;macExcludedPaths&#34;: [],
            &#34;macFilterToExcludePaths&#34;: [],
            &#34;backupSystemState&#34;: True,
            &#34;useVSSForSystemState&#34;: True,
            &#34;backupSystemStateOnlyWithFullBackup&#34;: False
        }

        if &#39;Linux&#39; in content:
            content[&#39;Unix&#39;] = content.pop(&#39;Linux&#39;)

        for os, data in content.items():
            included_paths_key = f&#34;{os.lower()}IncludedPaths&#34;
            excluded_paths_key = f&#34;{os.lower()}ExcludedPaths&#34;
            filter_to_exclude_paths_key = f&#34;{os.lower()}FilterToExcludePaths&#34;

            if &#39;Content&#39; in data:
                result[included_paths_key] = [path.split(&#39;%&#39;)[-2] for path in data[&#39;Content&#39;]]

            if &#39;Exclude&#39; in data:
                result[excluded_paths_key] = [path.split(&#39;%&#39;)[-2] for path in data[&#39;Exclude&#39;]]

            if &#39;Except&#39; in data:
                result[filter_to_exclude_paths_key] = [path.split(&#39;%&#39;)[-2] for path in data[&#39;Except&#39;]]

            if os == &#39;Windows&#39;:
                result[&#39;backupSystemState&#39;] = data.get(&#39;Backup System State&#39;, True)
                result[&#39;useVSSForSystemState&#39;] = data.get(&#39;useVSSForSystemState&#39;, True)
                result[&#39;backupSystemStateOnlyWithFullBackup&#39;] = data.get(&#39;backupSystemStateOnlyWithFullBackup&#39;, False)

        return result
    
    def update_backup_content(self, content, request_type = &#39;OVERWRITE&#39;):
        &#34;&#34;&#34;
        Args:
            content (dict)  :  dictionary with backup content details. 
            
            example: 
                content = {
                    &#39;Windows&#39; : {
                        &#39;Content&#39; : [&#39;\\%Pictures%&#39;, &#39;\\%Desktop%&#39;],
                        &#39;Exclude&#39; : [&#39;\\%Documents%&#39;],
                        &#39;Except&#39; : [&#39;\\%Documents%&#39;],
                        &#39;Backup System State&#39; : True
                    },
                    &#39;Linux&#39; : {
                        &#39;Content&#39; : [&#39;/%Pictures%&#39;],
                        &#39;Exclude&#39; : [&#39;/%Documents%&#39;]
                    },
                    &#39;Mac&#39; : {
                        &#39;Content&#39; : [&#39;/%Pictures%&#39;],
                        &#39;Exclude&#39; : [&#39;/%Documents%&#39;]
                    }
                }
                    
            request_type (str)      :  Supported values &#39;OVERWRITE&#39; (default), &#39;UPDATE&#39;, &#39;DELETE&#39;. 

            For plans created from SP32, Please use below format of content
            example:
                content = {
                    &#34;windowsIncludedPaths&#34;: [&#34;Desktop&#34;],
                    &#34;windowsExcludedPaths&#34;: [&#34;Music&#34;],
                    &#34;windowsFilterToExcludePaths&#34;: [&#34;Videos&#34;],
                    &#34;backupSystemState&#34;: True,
                    &#34;useVSSForSystemState&#34;: True,
                    &#34;backupSystemStateOnlyWithFullBackup&#34;: False
                }

            For unix and mac, replace key name with respective os name, **IncludedPaths, **ExcludedPaths, **FilterToExcludePaths
        &#34;&#34;&#34;
        
        update_request_type = {
            &#34;OVERWRITE&#34;: 1,
            &#34;UPDATE&#34;: 2,
            &#34;DELETE&#34;: 3
        }
        
        subclients = self.policy_subclient_ids()

        if not subclients:
            if &#39;Windows&#39; in content or &#39;Linux&#39; in content or &#39;Mac&#39; in content:
                content = self.__map_content_to_new_format(content)
            self.__update_content_policy(content)
            return
        
        for os, value in content.items():
            request_json = {
                &#34;subClientProperties&#34;: {
                    &#34;fsExcludeFilterOperationType&#34;: update_request_type.get(request_type, 1),
                    &#34;fsContentOperationType&#34; : update_request_type.get(request_type, 1)
                }
            }
            
            request_url = self._commcell_object._services[&#39;SUBCLIENT&#39;] % subclients[os]
            
            contents = list()
            for key, val in value.items():
                if key.lower() == &#39;content&#39;:
                    for path in val: contents.append({&#34;path&#34; : path})
                if key.lower() == &#39;exclude&#39;:
                    for path in val: contents.append({&#34;excludePath&#34; : path})
                if os == &#39;Windows&#39; and key == &#39;Backup System State&#39;:
                    request_json[&#39;subClientProperties&#39;][&#39;fsSubClientProp&#39;] = {&#39;backupSystemState&#39; : val}
                    
            if contents:
                request_json[&#39;subClientProperties&#39;][&#39;content&#39;] = contents
            
            flag, response = self._commcell_object._cvpysdk_object.make_request(&#39;POST&#39;, request_url, request_json)
                
            if flag:
                if response.json() and &#39;response&#39; in response.json():
                    errorCode = response.json()[&#39;response&#39;][0].get(&#39;errorCode&#39;)
                    if errorCode:
                        raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to Change Content of Plan.&#39;)
                else:
                    raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to get subclient Ids.&#39;)
            else:
                raise SDKException(&#39;Plan&#39;, 102, response.text)

    def enable_data_aging(self, plan_copy_id: int, is_enable=True):

        &#34;&#34;&#34;Method is used to enable/disable the data aging for the plan copy

            Args:
                plan_copy_id(int)      :   copy_id of the plan

                is_enable(bool)       :   value whether to be unable or disable the data aging

                                      example: true = enable
                                               false = disable
            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        payload = {
            &#34;retentionRules&#34;: {
                &#34;enableDataAging&#34;: is_enable
            }
        }

        api_url = self._services[&#39;ENABLE_DATA_AGING&#39;] % (self._plan_id, plan_copy_id)
        flag, response = self._cvpysdk_object.make_request(method=&#39;PUT&#39;,
                                                           url=api_url, payload=payload)
        if not flag:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;,
                               self._commcell_object._update_response_(response.text))
        if not response:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;,
                               self._commcell_object._update_response_(response.text))

    @property
    def applicable_solutions(self):
        &#34;&#34;&#34;Method to read applicable solutions&#34;&#34;&#34;
        return self._applicable_solutions

    @applicable_solutions.setter
    def applicable_solutions(self, solutions: list = list()):
        &#34;&#34;&#34;Method to update applicable solutions of plan
        
        Args:
            solutions (list) : List of Applicable Solutions
            
            example: 
                [&#34;File Servers&#34;, &#34;Databases&#34;] : FS and DB will be set as a applicable solutions
                [] : Passing empty list will reset applicable solutions to ALL
            
        &#34;&#34;&#34;
        request_url  = self._commcell_object._services[&#39;APPLICABLE_SOLNS_ENABLE&#39; if solutions else &#39;APPLICABLE_SOLNS_DISABLE&#39;] % self.plan_id
        
        if solutions:
            supported_solutions =  self._commcell_object.plans.get_supported_solutions()
            request_json = {&#34;solutions&#34;: [{&#34;id&#34;: supported_solutions[soln_name], &#34;name&#34;: soln_name} for soln_name in solutions]}
        else:
            request_json = None
                    
        flag, response = self._commcell_object._cvpysdk_object.make_request(&#39;PUT&#39;, request_url, request_json)
        
        if not flag:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, self._update_response_(response.text))
        
        if not response.json() or response.json()[&#39;errorCode&#39;]:
            raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to update Applicable Solutions for Plan&#39;)
                
        self.refresh()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="cvpysdk.plan.Plan.addons"><code class="name">var <span class="ident">addons</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan addons as read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3575-L3582" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def addons(self):
    &#34;&#34;&#34;Treats the plan addons as read-only attribute&#34;&#34;&#34;
    for addon in self._plan_properties.get(&#39;summary&#39;, {}).get(&#39;addons&#39;, []):
        self._addons.append(
            addon
        )
    return self._addons</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.all_copies"><code class="name">var <span class="ident">all_copies</span> :Â list</code></dt>
<dd>
<div class="desc"><p>Treats the plan's all storage copies as a read-only attribute</p>
<h2 id="returns">Returns</h2>
<p>list &ndash; list of all the copies</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3470-L3478" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def all_copies(self) -&gt; list:
    &#34;&#34;&#34;
    Treats the plan&#39;s all storage copies as a read-only attribute

    Returns:
        list -- list of all the copies
    &#34;&#34;&#34;
    return self._all_copies</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.applicable_solutions"><code class="name">var <span class="ident">applicable_solutions</span></code></dt>
<dd>
<div class="desc"><p>Method to read applicable solutions</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L4383-L4386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def applicable_solutions(self):
    &#34;&#34;&#34;Method to read applicable solutions&#34;&#34;&#34;
    return self._applicable_solutions</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.associated_entities"><code class="name">var <span class="ident">associated_entities</span></code></dt>
<dd>
<div class="desc"><p>getter for the backup entities associated with the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3602-L3605" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def associated_entities(self):
    &#34;&#34;&#34;getter for the backup entities associated with the plan&#34;&#34;&#34;
    return self._associated_entities</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.company"><code class="name">var <span class="ident">company</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Returns the company of the plan</p>
<p>return:
str &ndash;
company's domain name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3691-L3699" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def company(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the company of the plan

    return:
        str --  company&#39;s domain name
    &#34;&#34;&#34;
    return self._provider_domain_name</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.content_indexing"><code class="name">var <span class="ident">content_indexing</span></code></dt>
<dd>
<div class="desc"><p>Returns the Content Indexing status of O365 plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3659-L3673" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def content_indexing(self):
    &#34;&#34;&#34;Returns the Content Indexing status of O365 plan&#34;&#34;&#34;
    try:
        ci_status = (self.properties.get(&#34;office365Info&#34;,{})
                     .get(&#34;o365Exchange&#34;,{})
                     .get(&#34;mbArchiving&#34;, {})
                     .get(&#34;detail&#34;, {})
                     .get(&#34;emailPolicy&#34;, {})
                     .get(&#34;archivePolicy&#34;, {})
                     .get(&#34;contentIndexProps&#34;, {})
                     .get(&#34;enableContentIndex&#34;, {}))
    except:
        ci_status= None
    return ci_status</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.content_indexing_props"><code class="name">var <span class="ident">content_indexing_props</span></code></dt>
<dd>
<div class="desc"><p>returns the DC plan related CI properties from Plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3654-L3657" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def content_indexing_props(self):
    &#34;&#34;&#34;returns the DC plan related CI properties from Plan&#34;&#34;&#34;
    return self._dc_plan_props</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.data_schedule_policy"><code class="name">var <span class="ident">data_schedule_policy</span> :Â object</code></dt>
<dd>
<div class="desc"><p>Treats the plan data scheduler policy as read-only attribute</p>
<h2 id="returns">Returns</h2>
<p>object
-
data schedule policy object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3539-L3549" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def data_schedule_policy(self) -&gt; object:
    &#34;&#34;&#34;
        Treats the plan data scheduler policy as read-only attribute

        Returns:
            object  -   data schedule policy object
    &#34;&#34;&#34;
    if not self._data_schedule_policy:
        self._data_schedule_policy = self.__get_schedule_policy(&#39;data&#39;)
    return self._data_schedule_policy</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.full_operation_window"><code class="name">var <span class="ident">full_operation_window</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan full backup operation window as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3368-L3371" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def full_operation_window(self):
    &#34;&#34;&#34;Treats the plan full backup operation window as a read-only attribute&#34;&#34;&#34;
    return self._full_operation_window</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.log_schedule_policy"><code class="name">var <span class="ident">log_schedule_policy</span> :Â object</code></dt>
<dd>
<div class="desc"><p>Treats the plan log schedule policy as read-only attribute</p>
<h2 id="returns">Returns</h2>
<p>object
-
log schedule policy object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3551-L3561" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def log_schedule_policy(self) -&gt; object:
    &#34;&#34;&#34;
        Treats the plan log schedule policy as read-only attribute

        Returns:
            object  -   log schedule policy object
    &#34;&#34;&#34;
    if not self._log_schedule_policy:
        self._log_schedule_policy = self.__get_schedule_policy(&#39;log&#39;)
    return self._log_schedule_policy</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.operation_window"><code class="name">var <span class="ident">operation_window</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan incremental operation window as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3320-L3323" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def operation_window(self):
    &#34;&#34;&#34;Treats the plan incremental operation window as a read-only attribute&#34;&#34;&#34;
    return self._operation_window</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.override_entities"><code class="name">var <span class="ident">override_entities</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan override_entities as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3425-L3428" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def override_entities(self):
    &#34;&#34;&#34;Treats the plan override_entities as a read-only attribute.&#34;&#34;&#34;
    return self._override_entities</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.parent_plan"><code class="name">var <span class="ident">parent_plan</span></code></dt>
<dd>
<div class="desc"><p>getter for the parent plan of a derived plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3607-L3610" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def parent_plan(self):
    &#34;&#34;&#34;getter for the parent plan of a derived plan&#34;&#34;&#34;
    return self._commcell_object.plans.get(self._parent_plan_name)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.plan_id"><code class="name">var <span class="ident">plan_id</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan id as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3250-L3253" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def plan_id(self):
    &#34;&#34;&#34;Treats the plan id as a read-only attribute.&#34;&#34;&#34;
    return self._plan_id</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.plan_name"><code class="name">var <span class="ident">plan_name</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan name as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3255-L3258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def plan_name(self):
    &#34;&#34;&#34;Treats the plan name as a read-only attribute.&#34;&#34;&#34;
    return self._plan_name</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.plan_type"><code class="name">var <span class="ident">plan_type</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan type as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3415-L3418" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def plan_type(self):
    &#34;&#34;&#34;Treats the plan type as a read-only attribute.&#34;&#34;&#34;
    return self._plan_type</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.properties"><code class="name">var <span class="ident">properties</span></code></dt>
<dd>
<div class="desc"><p>Returns the configured properties for the Plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3681-L3684" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def properties(self):
    &#34;&#34;&#34;Returns the configured properties for the Plan&#34;&#34;&#34;
    return self._plan_properties</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.region_id"><code class="name">var <span class="ident">region_id</span></code></dt>
<dd>
<div class="desc"><p>Returns the Backup destination region id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3686-L3689" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def region_id(self):
    &#34;&#34;&#34;Returns the Backup destination region id&#34;&#34;&#34;
    return self._region_id</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.resources"><code class="name">var <span class="ident">resources</span> :Â list</code></dt>
<dd>
<div class="desc"><p>Returns the resources stored in storage resource pool</p>
<p>return:
list &ndash;
plan's resources</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3701-L3709" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def resources(self) -&gt; list:
    &#34;&#34;&#34;
    Returns the resources stored in storage resource pool

    return:
        list --  plan&#39;s resources
    &#34;&#34;&#34;
    return self._resources</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.schedule_policies"><code class="name">var <span class="ident">schedule_policies</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan schedule policies as read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3501-L3507" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def schedule_policies(self):
    &#34;&#34;&#34;Treats the plan schedule policies as read-only attribute&#34;&#34;&#34;
    if not self._child_policies.get(&#39;schedulePolicy&#39;):
        self.__set_schedule_policies()

    return self._child_policies.get(&#39;schedulePolicy&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.security_associations"><code class="name">var <span class="ident">security_associations</span></code></dt>
<dd>
<div class="desc"><p>getter for the plan's security associations</p>
<h2 id="eg">Eg</h2>
<p>{
'sample_user_group_name': 'role_name'
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3612-L3620" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def security_associations(self):
    &#34;&#34;&#34;getter for the plan&#39;s security associations
        Eg:
            {
                &#39;sample_user_group_name&#39;: &#39;role_name&#39;
            }
    &#34;&#34;&#34;
    return self._security_associations</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.sla_in_minutes"><code class="name">var <span class="ident">sla_in_minutes</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan SLA/RPO as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3294-L3297" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def sla_in_minutes(self):
    &#34;&#34;&#34;Treats the plan SLA/RPO as a read-only attribute.&#34;&#34;&#34;
    return self._sla_in_minutes</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.snap_schedule_policy"><code class="name">var <span class="ident">snap_schedule_policy</span> :Â object</code></dt>
<dd>
<div class="desc"><p>Treats the plan snap schedule policy as read-only attribute</p>
<h2 id="returns">Returns</h2>
<p>object
-
snap schedule policy object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3563-L3573" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def snap_schedule_policy(self) -&gt; object:
    &#34;&#34;&#34;
        Treats the plan snap schedule policy as read-only attribute

        Returns:
            object  -   snap schedule policy object
    &#34;&#34;&#34;
    if not self._snap_schedule_policy:
        self._snap_schedule_policy = self.__get_schedule_policy(&#39;snap&#39;)
    return self._snap_schedule_policy</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.storage_copies"><code class="name">var <span class="ident">storage_copies</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan storage policy as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3480-L3483" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def storage_copies(self):
    &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
    return self._storage_copies</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.storage_policy"><code class="name">var <span class="ident">storage_policy</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan storage policy as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3462-L3468" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def storage_policy(self):
    &#34;&#34;&#34;Treats the plan storage policy as a read-only attribute&#34;&#34;&#34;
    if not self._child_policies.get(&#39;storagePolicy&#39;):
        self.__set_storage_policy()

    return self._child_policies.get(&#39;storagePolicy&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.subclient_policy"><code class="name">var <span class="ident">subclient_policy</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan subclient policy as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3594-L3600" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def subclient_policy(self):
    &#34;&#34;&#34;Treats the plan subclient policy as a read-only attribute&#34;&#34;&#34;
    if not self._child_policies.get(&#39;subclientPolicyIds&#39;):
        self.__set_subclient_policy_ids()

    return self._child_policies.get(&#39;subclientPolicyIds&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.subtype"><code class="name">var <span class="ident">subtype</span></code></dt>
<dd>
<div class="desc"><p>Treats the plan subtype as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3420-L3423" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def subtype(self):
    &#34;&#34;&#34;Treats the plan subtype as a read-only attribute.&#34;&#34;&#34;
    return self._subtype</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cvpysdk.plan.Plan.add_copy"><code class="name flex">
<span>def <span class="ident">add_copy</span></span>(<span>self, copy_name:Â str, storage_pool:Â str, retention:Â intÂ =Â 30, extended_retention:Â dictÂ =Â None, region:Â strÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Method to add an aux copy to the plan</p>
<h2 id="args">Args</h2>
<p>copy_name
(str)
-
name of the copy that is being added
storage_pool (str)
-
name of the storage pool that is to be used for the copy
retention
(int)
-
retention period in days for the copy
extended_retention (dict)
-
extended retention rules of a copy
region
(str)
-
region name to which copy needs to be added</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
-
if failed to add new copy to the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2752-L2789" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_copy(self, copy_name: str, storage_pool: str, retention: int=30, extended_retention: dict=None, region: str=None) -&gt; None:
    &#34;&#34;&#34;
        Method to add an aux copy to the plan

        Args:
            copy_name   (str)   -   name of the copy that is being added
            storage_pool (str)  -   name of the storage pool that is to be used for the copy
            retention   (int)   -   retention period in days for the copy
            extended_retention (dict)  -   extended retention rules of a copy
            region      (str)   -   region name to which copy needs to be added

        Returns:
            None

        Raises:
            SDKException:
            -   if failed to add new copy to the plan
    &#34;&#34;&#34;
    copy_details = {
        &#34;backupDestinationName&#34;: copy_name,
        &#34;storage_name&#34;: storage_pool,
        &#34;retentionPeriodDays&#34;: retention
    }

    if extended_retention:
        copy_details[&#39;useExtendedRetentionRules&#39;] = True
        copy_details[&#34;extendedRetentionRules&#34;] = extended_retention

    request_json = {
        &#39;destinations&#39;: [self.plan_v4_helper.get_copy_payload(copy_details, is_aux_copy=True)]
    }
    # during add copy, region should be specified as the separate blob
    if region:
        request_json[&#39;region&#39;] = {&#34;id&#34;: int(self._commcell_object.regions.get(region).region_id)}

    flag, response = self._cvpysdk_object.make_request(&#39;POST&#39;, self._SERVER_PLAN_BACKUP_DESTINATION, request_json)

    self.__handle_response(flag, response, custom_error_message=f&#39;Failed to add new copy to the plan : [{self.plan_name}]&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.add_region"><code class="name flex">
<span>def <span class="ident">add_region</span></span>(<span>self, region_name:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Method to add a region to the plan</p>
<h2 id="args">Args</h2>
<p>region_name (str)
-
name of the region that is being added</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
-
if failed to add new region to the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2866-L2890" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_region(self, region_name: str) -&gt; None:
    &#34;&#34;&#34;
    Method to add a region to the plan

    Args:
        region_name (str)   -   name of the region that is being added

    Returns:
        None

    Raises:
        SDKException:
            -   if failed to add new region to the plan
    &#34;&#34;&#34;
    region_id = self._commcell_object.regions.get(region_name).region_id

    request_json = {
        &#34;regionToConfigure&#34;: {
            &#34;id&#34;: int(region_id)
        }
    }

    flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_PLAN, request_json)

    self.__handle_response(flag, response, custom_error_message=f&#39;Failed to add new region to the plan : [{self.plan_name}]&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.add_schedule"><code class="name flex">
<span>def <span class="ident">add_schedule</span></span>(<span>self, schedule_options:Â dict) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Method to add a new schedule to the plan</p>
<h2 id="args">Args</h2>
<p>schedule_options (dict) - schedule options to be added (backupType is mandatory)</p>
<dl>
<dt><strong><code>Note</code></strong></dt>
<dd>To prepare advanced schedule options, refer to the API documentation or Command Center equivalent API</dd>
</dl>
<p>Example:</p>
<h1 id="create-schedule-based-on-backup-type-and-rest-use-default-values">create schedule based on backup type and rest use default values</h1>
<p _TRANSACTIONLOG_="&quot;TRANSACTIONLOG&quot;" _backupType_:="&quot;backupType&quot;:">{"backupType": "INCREMENTAL"}</p>
<h1 id="create-schedule-with-advanced-properties">create schedule with advanced properties</h1>
<p>{
"backupType": "FULL",
"schedulePattern": {
"scheduleFrequencyType": "DAILY",
"startTime": 75600,
"frequency": 1
}
}</p>
<h1 id="specify-agents-for-schedules">specify agents for schedules</h1>
<p True _FULL_="&quot;FULL&quot;," _backupType_:="&quot;backupType&quot;:" _forDatabasesOnly_:="&quot;forDatabasesOnly&quot;:">{"backupType": "INCREMENTAL", "forDatabasesOnly": False}</p>
<h1 id="advance-properties-for-schedules">advance properties for schedules</h1>
<p>{"backupType": "TRANSACTIONLOG", "scheduleOption": {"useDiskCacheForLogBackups": True}}</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
- if failed to add the schedule to the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2946-L2994" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_schedule(self, schedule_options: dict) -&gt; None:
    &#34;&#34;&#34;
    Method to add a new schedule to the plan

    Args:
        schedule_options (dict) - schedule options to be added (backupType is mandatory)

        Note: To prepare advanced schedule options, refer to the API documentation or Command Center equivalent API

        Example:

        # create schedule based on backup type and rest use default values
        {&#34;backupType&#34;: &#34;INCREMENTAL&#34;}
        {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;}

        # create schedule with advanced properties
        {
            &#34;backupType&#34;: &#34;FULL&#34;, 
            &#34;schedulePattern&#34;: {
                &#34;scheduleFrequencyType&#34;: &#34;DAILY&#34;,
                &#34;startTime&#34;: 75600,
                &#34;frequency&#34;: 1
                }
        }

        # specify agents for schedules
        {&#34;backupType&#34;: &#34;INCREMENTAL&#34;, &#34;forDatabasesOnly&#34;: False}
        {&#34;backupType&#34;: &#34;FULL&#34;, &#34;forDatabasesOnly&#34;: True}

        # advance properties for schedules
        {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;, &#34;scheduleOption&#34;: {&#34;useDiskCacheForLogBackups&#34;: True}}

    Returns:
        None

    Raises:
        SDKException:
            - if failed to add the schedule to the plan
    &#34;&#34;&#34;
    schedule_payload = self.plan_v4_helper.get_schedule_payload(schedule_options)
    
    payload = {
        &#34;backupFrequency&#34;: {
            &#34;schedules&#34;: [schedule_payload]
        }
    }
    flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._PLAN_RPO, payload)

    self.__handle_response(flag, response, custom_error_message=f&#39;Failed to add new schedule to the plan: [{self.plan_name}]&#39;)    </code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.add_storage_copy"><code class="name flex">
<span>def <span class="ident">add_storage_copy</span></span>(<span>self, copy_name, storage_pool, retention=30, extended_retention=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a storage copy as backup destination to this plan</p>
<h2 id="args">Args</h2>
<p>copy_name
(str)
-
name of the copy that is being added</p>
<p>storage_pool (str)
-
name of the storage pool for the copy to be added</p>
<p>retention
(int)
-
retention period in days for the copy</p>
<p>extended_retention (tuple)
-
extended retention rules of a copy
Example: [1, True, "EXTENDED_ALLFULL", 0, 0]</p>
<h2 id="returns">Returns</h2>
<p>dict
-
dictionary of all copies of this plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3089-L3121" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_storage_copy(self, copy_name, storage_pool, retention=30, extended_retention=None):
    &#34;&#34;&#34;Add a storage copy as backup destination to this plan
        Args:
            copy_name   (str)   -   name of the copy that is being added

            storage_pool (str)  -   name of the storage pool for the copy to be added

            retention   (int)   -   retention period in days for the copy

            extended_retention (tuple)  -   extended retention rules of a copy
                                            Example: [1, True, &#34;EXTENDED_ALLFULL&#34;, 0, 0]
        Returns:
            dict    -   dictionary of all copies of this plan
    &#34;&#34;&#34;
    if isinstance(copy_name, str) and isinstance(storage_pool, str):
        if not self.storage_policy.has_copy(copy_name):
            self.storage_policy.create_secondary_copy(
                copy_name,
                global_policy=storage_pool
            )
            self.storage_policy.get_copy(copy_name).copy_retention = (retention, 0, 0)
            if extended_retention:
                self.storage_policy.get_copy(
                    copy_name).extended_retention_rules = extended_retention
            self.refresh()
            return self.storage_copies
        else:
            err_msg = f&#39;Storage Policy copy &#34;{copy_name}&#34; already exists.&#39;
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)
    else:
        raise SDKException(
            &#39;Plan&#39;, &#39;102&#39;, &#39;Copy name and storage pool name must be a string.&#39;
        )</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.associate_user"><code class="name flex">
<span>def <span class="ident">associate_user</span></span>(<span>self, userlist, send_invite=True)</span>
</code></dt>
<dd>
<div class="desc"><p>associates the users to the plan.
# TODO: Need to handle user groups.</p>
<h2 id="arguments">Arguments</h2>
<p>userlist(list) - list of users to be associated to the plans.</p>
<p>Raises:
SDKException:
if response is empty</p>
<pre><code>     if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3729-L3782" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def associate_user(self, userlist, send_invite=True):
    &#34;&#34;&#34;associates the users to the plan.
        # TODO: Need to handle user groups.

       Arguments:
            userlist(list) - list of users to be associated to the plans.

        Raises:
            SDKException:
                if response is empty

                if response is not success

    &#34;&#34;&#34;
    users_list = []

    for user in userlist:
        if self._commcell_object.users.has_user(user):
            temp = self._commcell_object.users.get(user)

            temp_dict = {
                &#39;sendInvite&#39;: send_invite,
                &#39;user&#39;: {
                    &#39;userName&#39;: temp.user_name,
                    &#39;userId&#39;: int(temp.user_id)
                }
            }

            users_list.append(temp_dict)

    request_json = {
        &#34;userOperationType&#34;: 1,
        &#34;users&#34;: users_list
    }

    flag, response = self._cvpysdk_object.make_request(
        &#39;PUT&#39;, self._ADD_USERS_TO_PLAN, request_json
    )

    if flag:
        if response.json() and &#39;errors&#39; in response.json():
            for error in response.json()[&#34;errors&#34;]:
                error_code = error[&#34;status&#34;][&#34;errorCode&#34;]

                if error_code == 0:
                    pass
                else:
                    o_str = &#39;Failed to add users with error code: &#34;{0}&#34;&#39;
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_code))
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.delete_copy"><code class="name flex">
<span>def <span class="ident">delete_copy</span></span>(<span>self, copy_name:Â str, region_name:Â strÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Method to remove a copy from the plan</p>
<h2 id="args">Args</h2>
<p>copy_name (str)
-
name of the copy to be removed
region_name (str) -
name of the region from which the copy needs to be removed</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
-
if failed to remove the copy from the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2845-L2864" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delete_copy(self, copy_name: str, region_name: str=None) -&gt; None:
    &#34;&#34;&#34;
    Method to remove a copy from the plan

    Args:
        copy_name (str)   -   name of the copy to be removed
        region_name (str) -   name of the region from which the copy needs to be removed

    Returns:
        None

    Raises:
        SDKException:
            -   if failed to remove the copy from the plan
    &#34;&#34;&#34;
    copy_id = self.get_storage_copy_id(copy_name, region_name)

    flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, self._services[&#39;V4_SERVER_PLAN_COPY&#39;] % (self.plan_id, copy_id))

    self.__handle_response(flag, response, custom_error_message=f&#39;Failed to remove copy from the plan: [{self.plan_name}]&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.delete_schedule"><code class="name flex">
<span>def <span class="ident">delete_schedule</span></span>(<span>self, schedule_filter:Â dict) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Method to delete the schedule from the plan</p>
<h2 id="args">Args</h2>
<p>schedule_filter (dict)
- schedule to be deleted</p>
<p>Refer to the get_schedule_properties method for the format of the schedule filter</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
- if failed to edit the schedule options of the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3031-L3058" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delete_schedule(self, schedule_filter: dict) -&gt; None:
    &#34;&#34;&#34;
    Method to delete the schedule from the plan

    Args:
        schedule_filter (dict)  - schedule to be deleted

        Refer to the get_schedule_properties method for the format of the schedule filter

    Returns:
        None

    Raises:
        SDKException:
            - if failed to edit the schedule options of the plan
    &#34;&#34;&#34;
    schedule_payload = self.get_schedule_properties(schedule_filter)
    schedule_payload[&#39;scheduleOperation&#39;] = &#39;DELETE&#39;

    payload = {
        &#34;backupFrequency&#34;: {
            &#34;schedules&#34;: [schedule_payload]
        }
    }

    flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._PLAN_RPO, payload)

    self.__handle_response(flag, response, custom_error_message=f&#39;Failed to delete schedule from the plan: [{self.plan_name}]&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.derive_and_add"><code class="name flex">
<span>def <span class="ident">derive_and_add</span></span>(<span>self, plan_name, storage_pool_name=None, sla_in_minutes=None, override_entities=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Derives the base plan based on the the inheritance properties to created a derived plan</p>
<pre><code>Args:
    plan_name           (str)        --  name of the new plan to add

    storage_pool_name   (str)   --  name of the storage pool to be used for the plan
        default: None   :   when the name is left to default, it inherits the base plan
                            storage pool if overriding is optional/not allowed

    sla_in_minutes        (int)        --  Backup SLA in hours
        default: None   :   when the SLA is left to default, it inherits the base plan
                            SLA if overriding is optional/not allowed

    override_entities   (dict)  --  Specify the entities with respective overriding.

        default: None

            {
                'privateEntities': [1, 4],

                'enforcedEntities': [256, 512, 1024]
            }
            - where,
                    privateEntities are set when respective entity overriding is must
                    enforcedEntities are set when respective entity overriding is
                    not allowed
                    left blank if overriding is optional

            - entity IDs,
                    1    - Storage
                    4    - SLA/Schedules
                    256  - Windows content
                    512  - Unix content
                    1024 - Mac content
</code></pre>
<h2 id="returns">Returns</h2>
<p>object - instance of the Plan class created by this method</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if plan name is in incorrect format</p>
<pre><code>if plan already exists

if neccessary arguments are not passed

if inheritance rules are not followed
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2335-L2616" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def derive_and_add(self,
                   plan_name,
                   storage_pool_name=None,
                   sla_in_minutes=None,
                   override_entities=None):
    &#34;&#34;&#34;Derives the base plan based on the the inheritance properties to created a derived plan

        Args:
            plan_name           (str)        --  name of the new plan to add

            storage_pool_name   (str)   --  name of the storage pool to be used for the plan
                default: None   :   when the name is left to default, it inherits the base plan
                                    storage pool if overriding is optional/not allowed

            sla_in_minutes        (int)        --  Backup SLA in hours
                default: None   :   when the SLA is left to default, it inherits the base plan
                                    SLA if overriding is optional/not allowed

            override_entities   (dict)  --  Specify the entities with respective overriding.

                default: None

                    {
                        &#39;privateEntities&#39;: [1, 4],

                        &#39;enforcedEntities&#39;: [256, 512, 1024]
                    }
                    - where,
                            privateEntities are set when respective entity overriding is must
                            enforcedEntities are set when respective entity overriding is
                            not allowed
                            left blank if overriding is optional

                    - entity IDs,
                            1    - Storage
                            4    - SLA/Schedules
                            256  - Windows content
                            512  - Unix content
                            1024 - Mac content


    Returns:
        object - instance of the Plan class created by this method

    Raises:
        SDKException:
            if plan name is in incorrect format

            if plan already exists

            if neccessary arguments are not passed

            if inheritance rules are not followed

    &#34;&#34;&#34;
    if not isinstance(plan_name, str):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;, &#39;Plan name must be string value&#39;)
    else:
        if self._commcell_object.plans.has_plan(plan_name):
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(
                    plan_name)
            )
    if self._override_entities is not None:
        request_json = self._commcell_object.plans._get_plan_template(
            str(self._subtype), &#34;MSP&#34;)

        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;parent&#39;] = {
            &#39;planId&#39;: int(self._plan_id)
        }

        is_dedupe = True
        if storage_pool_name is not None:
            storage_pool_obj = self._commcell_object.storage_pools.get(
                storage_pool_name
            )
            if &#39;dedupDBDetailsList&#39; \
                    not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
                is_dedupe = False
            storage_pool_id = int(storage_pool_obj.storage_pool_id)
            if is_dedupe:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;useGlobalDedupStore&#39;] = 1
            else:
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;enableDeduplication&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                    &#39;enableClientSideDedup&#39;]
                del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                    &#39;useGlobalStoragePolicy&#39;: 1
                }
        else:
            storage_pool_id = None

        if 1 in self._override_entities[&#39;enforcedEntities&#39;]:
            if storage_pool_id is None:
                request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                    &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                }
                snap_copy_id = self.storage_policy.storage_policy_id
            else:
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;Storage is enforced by base plan, cannot be overridden&#39;)
        elif 1 in self._override_entities[&#39;privateEntities&#39;]:
            if storage_pool_id is not None:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                    &#34;storagePolicyId&#34;: storage_pool_id
                }
                snap_copy_id = storage_pool_id
            else:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Storage must be input&#39;)
        else:
            if storage_pool_id is not None:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
                    &#34;storagePolicyId&#34;: storage_pool_id
                }
                snap_copy_id = storage_pool_id
            else:
                request_json[&#39;plan&#39;][&#39;storage&#39;] = {
                    &#34;storagePolicyId&#34;: self.storage_policy.storage_policy_id
                }
                snap_copy_id = self.storage_policy.storage_policy_id

        if 4 in self._override_entities[&#39;enforcedEntities&#39;]:
            if sla_in_minutes is None:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes
            else:
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;SLA is enforced by base plan, cannot be overridden&#39;)
        elif 4 in self._override_entities[&#39;privateEntities&#39;]:
            if sla_in_minutes is not None:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
            else:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;SLA must be input&#39;)
        else:
            if sla_in_minutes is not None:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = sla_in_minutes
            else:
                request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;slaInMinutes&#39;] = self._sla_in_minutes

        if isinstance(override_entities, dict):
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: False
            }
            for entity in self._override_entities[&#39;enforcedEntities&#39;]:
                from functools import reduce
                if override_entities and entity in reduce(
                        lambda i, j: i + j, override_entities.values()):
                    raise SDKException(
                        &#39;Plan&#39;, &#39;102&#39;, &#39;Override not allowed&#39;)
            if &#39;enforcedEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = (
                    override_entities[&#39;enforcedEntities&#39;]
                )
            if &#39;privateEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = (
                    override_entities[&#39;privateEntities&#39;]
                )
        else:
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: True
            }

        if sla_in_minutes is not None:
            request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                &#39;definesEntity&#39;: True
            }
        else:
            request_json[&#39;plan&#39;][&#39;definesSchedule&#39;] = {
                &#39;definesEntity&#39;: False
            }

        if isinstance(self._override_entities, dict):
            if (4 not in
                    self._override_entities[&#39;enforcedEntities&#39;] +
                    self._override_entities[&#39;privateEntities&#39;]):
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 0
            elif 4 in self._override_entities[&#39;enforcedEntities&#39;]:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 2
            elif 4 in self._override_entities[&#39;privateEntities&#39;]:
                request_json[&#39;plan&#39;][&#39;definesSchedule&#39;][&#39;overrideEntity&#39;] = 1

        if storage_pool_id is not None:
            request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                &#39;definesEntity&#39;: True
            }
        else:
            request_json[&#39;plan&#39;][&#39;definesStorage&#39;] = {
                &#39;definesEntity&#39;: False
            }

        if isinstance(self._override_entities, dict):
            if (1 not in
                    self._override_entities[&#39;enforcedEntities&#39;] +
                    self._override_entities[&#39;privateEntities&#39;]):
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 0
            elif 1 in self._override_entities[&#39;enforcedEntities&#39;]:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 2
            elif 1 in self._override_entities[&#39;privateEntities&#39;]:
                request_json[&#39;plan&#39;][&#39;definesStorage&#39;][&#39;overrideEntity&#39;] = 1

        if self._subtype != 33554437:
            temp_defines_key = {
                &#39;definesEntity&#39;: False
            }
            if isinstance(self._override_entities, dict):
                if (not all(entity in
                            self._override_entities[&#39;enforcedEntities&#39;] +
                            self._override_entities[&#39;privateEntities&#39;]
                            for entity in [256, 512, 1024])):
                    temp_defines_key[&#39;overrideEntity&#39;] = 0
                elif all(entity in self._override_entities[&#39;enforcedEntities&#39;]
                         for entity in [256, 512, 1024]):
                    temp_defines_key[&#39;overrideEntity&#39;] = 2
                elif all(entity in self._override_entities[&#39;privateEntities&#39;]
                         for entity in [256, 512, 1024]):
                    temp_defines_key[&#39;overrideEntity&#39;] = 1
            request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientLin&#39;] = temp_defines_key
            request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientMac&#39;] = temp_defines_key
            request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;content&#39;][&#39;definesSubclientWin&#39;] = temp_defines_key

        if self._subtype == 33554437 and &#39;snap&#39; in self.addons and &#39;copy&#39; \
                in request_json[&#39;plan&#39;][&#39;storage&#39;]:
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                &#39;storagePolicyId&#39;: snap_copy_id
            }
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                &#39;useGlobalStoragePolicy&#39;: 1
            }

        add_plan_service = self._commcell_object.plans._PLANS
        headers = self._commcell_object._headers.copy()
        headers[&#39;LookupNames&#39;] = &#39;False&#39;

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, add_plan_service, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = None

                if &#39;errors&#39; in response_value:
                    error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                # error_codes 0 - OK, 1 - plan without storage, 84 - restricted plan
                if error_code not in [0, 1, 84]:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                    # initialize the plans again
                    # so that the plans object has all the plans
                    self._commcell_object.plans.refresh()

                    return self._commcell_object.plans.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
    else:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Inheritance disabled for plan&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.disable_full_schedule"><code class="name flex">
<span>def <span class="ident">disable_full_schedule</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable the full backup schedule of the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3123-L3130" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def disable_full_schedule(self):
    &#34;&#34;&#34;Disable the full backup schedule of the plan&#34;&#34;&#34;
    try:
        self.schedule_policies[&#39;data&#39;].delete_schedule(schedule_id=list(filter(
            lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
        ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;])
    except IndexError:
        raise IndexError(&#39;Full backup schedule not enabled&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.edit_association"><code class="name flex">
<span>def <span class="ident">edit_association</span></span>(<span>self, entities, new_plan=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reassociates or dissociates the entities from this plan</p>
<h2 id="args">Args</h2>
<p>entities
(list)
&ndash;
list containing entity objects whose plan association must be edited
Eg: [
{
"clientName": "client",
"subclientName": "subclient",
"backupsetName": "backupset",
"appName": "app"
}
]</p>
<p>new_plan
(str)
&ndash;
new plan to which the associated entities must be reassociated with</p>
<h2 id="raises">Raises</h2>
<p>SDKException
if plan not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3132-L3191" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def edit_association(self, entities, new_plan=None):
    &#34;&#34;&#34;Reassociates or dissociates the entities from this plan
        Args:
            entities    (list)  --  list containing entity objects whose plan association must be edited
                                    Eg: [
                                        {
                                            &#34;clientName&#34;: &#34;client&#34;,
                                            &#34;subclientName&#34;: &#34;subclient&#34;,
                                            &#34;backupsetName&#34;: &#34;backupset&#34;,
                                            &#34;appName&#34;: &#34;app&#34;
                                        }
                                    ]

            new_plan    (str)   --  new plan to which the associated entities must be reassociated with

        Raises:
            SDKException
                if plan not found
    &#34;&#34;&#34;
    req_json = {
        &#39;plan&#39;: {
            &#39;planName&#39;: self.plan_name
        },
        &#39;entities&#39;: entities
    }
    if new_plan is not None:
        if self._commcell_object.plans.has_plan(new_plan):
            req_json.update({
                &#39;planOperationType&#39;: &#39;OVERWRITE&#39;,
                &#39;newPlan&#39;: {
                    &#39;planName&#39;: new_plan
                }
            })
        else:
            SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                new_plan)
            )
    else:
        req_json.update({
            &#39;planOperationType&#39;: &#39;DELETE&#39;
        })
    req_url = self._services[&#39;ASSOCIATED_ENTITIES&#39;] % (self._plan_id)
    flag, response = self._cvpysdk_object.make_request(
        &#39;PUT&#39;, req_url, req_json
    )

    if flag:
        if &#39;response&#39; in response.json():
            error_code = str(response.json()[&#34;response&#34;][0][&#34;errorCode&#34;])

            if error_code == &#34;0&#34;:
                self.refresh()
                return
        else:
            error_message = str(response.json()[&#34;errorMessage&#34;])
            o_str = &#39;Failed to edit plan associated entities\nError: &#34;{0}&#34;&#39;
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str.format(error_message))
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.edit_copy"><code class="name flex">
<span>def <span class="ident">edit_copy</span></span>(<span>self, copy_name:Â str, new_retention_days:Â intÂ =Â None, new_recovery_points:Â intÂ =Â None, new_extended_retention:Â dictÂ =Â None, current_region_name:Â strÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Method to edit a copy settings</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>copy_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the copy that is being edited</dd>
<dt><strong><code>new_retention_days</code></strong> :&ensp;<code>int</code></dt>
<dd>new retention period in days for the copy</dd>
<dt><strong><code>new_recovery_points</code></strong> :&ensp;<code>int</code></dt>
<dd>new recovery points for the snap copy</dd>
<dt><strong><code>new_extended_retention</code></strong> :&ensp;<code>dict</code></dt>
<dd>new extended retention rules of a copy</dd>
<dt><strong><code>current_region_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the region from which the copy needs to be edited</dd>
</dl>
<p>Example:
new_extended_retention =
{
"firstExtendedRetentionRule": {
"isInfiniteRetention": False,
"type": "WEEKLY_FULLS",
"retentionPeriodDays": 90
}
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2791-L2843" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def edit_copy(self, copy_name: str, new_retention_days: int = None, new_recovery_points: int = None, new_extended_retention: dict = None, current_region_name: str = None) -&gt; None:
    &#34;&#34;&#34;
    Method to edit a copy settings

    Args:
        copy_name (str): name of the copy that is being edited
        new_retention_days (int): new retention period in days for the copy
        new_recovery_points (int): new recovery points for the snap copy
        new_extended_retention (dict): new extended retention rules of a copy
        current_region_name (str): name of the region from which the copy needs to be edited

        Example:
            new_extended_retention =  {
            &#34;firstExtendedRetentionRule&#34;: {
                &#34;isInfiniteRetention&#34;: False,
                &#34;type&#34;: &#34;WEEKLY_FULLS&#34;,
                &#34;retentionPeriodDays&#34;: 90
            }
    }
    &#34;&#34;&#34;
    copy_details = self.get_storage_copy_details(copy_name, current_region_name)
    copy_id = self.get_storage_copy_id(copy_name, current_region_name)
    is_snap_copy = copy_details.get(&#39;isSnapCopy&#39;, False)

    # input validation
    if new_retention_days is not None and new_recovery_points is not None:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Both retention days and recovery points cannot be set at the same time&#39;)

    if new_recovery_points and not is_snap_copy:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Recovery points can be set only for snap copy&#39;)

    # copy the old details to the required payload first
    required_props = [&#39;retentionPeriodDays&#39;, &#39;retentionRuleType&#39;, &#39;useExtendedRetentionRules&#39;, &#39;extendedRetentionRules&#39;]
    new_retention_rules = {key: copy_details[key] for key in required_props if key in copy_details}

    # update the payload based on the input
    if new_retention_days is not None:
        new_retention_rules.update({&#39;retentionPeriodDays&#39;: new_retention_days, &#39;retentionRuleType&#39;: &#34;RETENTION_PERIOD&#34;})

    if new_recovery_points is not None:
        new_retention_rules.update({&#39;retentionPeriodDays&#39;: new_recovery_points, &#39;retentionRuleType&#39;: &#34;SNAP_RECOVERY_POINTS&#34;})

    if new_extended_retention:
        new_retention_rules.update({&#39;useExtendedRetentionRules&#39;: True, &#39;extendedRetentionRules&#39;: new_extended_retention})

    # special property that needs to be sent during edit
    new_retention_rules[&#39;fullBackupTypesToBeRetained&#39;] = &#39;FIRST&#39;

    request_json = {&#39;retentionRules&#39;: new_retention_rules}

    flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._services[&#39;V5_SERVER_PLAN_COPY&#39;] % (self.plan_id, copy_id), request_json)

    self.__handle_response(flag, response, custom_error_message=f&#39;Failed to edit copy settings for the plan : [{self.plan_name}] Copy: [{copy_name}] Region: [{current_region_name}]&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.edit_plan"><code class="name flex">
<span>def <span class="ident">edit_plan</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Edit plan options</p>
<h2 id="args">Args</h2>
<p>**kwargs for Data Classification Plan</p>
<p>index_content
(bool)
&ndash;
Speifies whether to index content or not to index server</p>
<p>content_analyzer
(list)
&ndash;
list of Content analyzer client name</p>
<p>entity_list
(list)
&ndash;
list of entities which needs to be extracted</p>
<p>classifier_list
(list)
&ndash;
list of classifier which needs to be classified</p>
<p>enable_ocr
(bool)
&ndash;
specifies whether OCR is enabled or not</p>
<p>ocr_language
(int)
&ndash;
Language to be used when doing OCR
Default : English (Value-1)</p>
<p>Supported Languages:</p>
<pre><code>            ENGLISH = 1,
            HEBREW = 2,
            SPANISH = 3,
            FRENCH = 4,
            ITALIAN = 5,
            DANISH = 6
</code></pre>
<p>include_docs
(str)
&ndash;
Include documents type separated by comma</p>
<p>exclude_path
(list)
&ndash;
List of paths which needs to be excluded</p>
<p>min_doc_size
(int)
&ndash;
Minimum document size in MB</p>
<p>max_doc_size
(int)
&ndash;
Maximum document size in MB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3941-L4035" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def edit_plan(self, **kwargs):
    &#34;&#34;&#34;Edit plan options

            Args:

                **kwargs for Data Classification Plan

                index_content       (bool)      --  Speifies whether to index content or not to index server

                content_analyzer    (list)      --  list of Content analyzer client name

                entity_list         (list)      --  list of entities which needs to be extracted

                classifier_list     (list)      --  list of classifier which needs to be classified

                enable_ocr          (bool)      --  specifies whether OCR is enabled or not

                ocr_language        (int)       --  Language to be used when doing OCR
                                                        Default : English (Value-1)

                 Supported Languages:

                                ENGLISH = 1,
                                HEBREW = 2,
                                SPANISH = 3,
                                FRENCH = 4,
                                ITALIAN = 5,
                                DANISH = 6

                include_docs        (str)       --  Include documents type separated by comma

                exclude_path        (list)      --  List of paths which needs to be excluded

                min_doc_size        (int)       --  Minimum document size in MB

                max_doc_size        (int)       --  Maximum document size in MB
    &#34;&#34;&#34;
    if self.plan_type != PlanTypes.DC.value:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Function Not supported for this plan type&#34;)
    extraction_policy_list = []
    request_json = None
    if self.plan_type == PlanTypes.DC.value:
        request_json = copy.deepcopy(PlanConstants.PLAN_UPDATE_REQUEST_JSON[self.plan_type])
        request_json[&#39;summary&#39;][&#39;plan&#39;][&#39;planId&#39;] = int(self.plan_id)
        if TargetApps.SDG.value in self.content_indexing_props[&#39;targetApps&#39;]:
            request_json[&#39;eePolicyInfo&#39;][&#39;eePolicy&#39;][&#39;detail&#39;][&#39;eePolicy&#39;] = self.content_indexing_props[&#39;eePolicy&#39;]
            request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;] = self.content_indexing_props[&#39;ciPolicy&#39;]
            activate_obj = self._commcell_object.activate
            if &#39;content_analyzer&#39; in kwargs:
                ca_list = []
                for ca in kwargs.get(&#39;content_analyzer&#39;, []):
                    ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                    ca_list.append({
                        &#39;clientId&#39;: ca_client_id
                    })
                request_json[&#39;eDiscoveryInfo&#39;] = {
                    &#39;contentAnalyzerClient&#39;: ca_list}
            if &#39;entity_list&#39; in kwargs or &#39;classifier_list&#39; in kwargs:
                entity_mgr_obj = activate_obj.entity_manager()
                # classifier is also an activate entity with type alone different so
                # append this to entity list itself
                entity_list = []
                for entity in kwargs.get(&#39;entity_list&#39;, []):
                    entity_list.append(entity)
                for entity in kwargs.get(&#39;classifier_list&#39;, []):
                    entity_list.append(entity)
                for entity in entity_list:
                    entity_obj = entity_mgr_obj.get(entity)
                    extraction_policy_list.append(entity_obj.container_details)
                request_json[&#39;eePolicyInfo&#39;][&#39;eePolicy&#39;][&#39;detail&#39;][&#39;eePolicy&#39;][&#39;extractionPolicy&#39;][&#39;extractionPolicyList&#39;] = extraction_policy_list

            if &#39;enable_ocr&#39; in kwargs:
                request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;enableImageExtraction&#39;] = kwargs.get(
                    &#39;enable_ocr&#39;, False)
                request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;ocrLanguages&#39;] = [
                    kwargs.get(&#39;ocr_language&#39;, 1)]
            if &#39;include_docs&#39; in kwargs:
                request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
                    &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
            if &#39;min_doc_size&#39; in kwargs:
                request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
                    &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
            if &#39;max_doc_size&#39; in kwargs:
                request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                    &#39;maxDocSize&#39;] = kwargs.get(&#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
            if &#39;exclude_path&#39; in kwargs:
                request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                    &#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, PlanConstants.DEFAULT_EXCLUDE_LIST)
            if &#39;index_content&#39; in kwargs:
                request_json[&#39;ciPolicyInfo&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;opType&#39;] = kwargs.get(
                    &#39;index_content&#39;, PlanConstants.INDEXING_ONLY_METADATA)
        elif TargetApps.FSO.value in self.content_indexing_props[&#39;targetApps&#39;]:
            # currently we dont have any thing to update in DC plan for FSO app so throw exception
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;No attributes to Edit for DC Plan with TargetApps as : FSO&#39;)
    self._update_plan_props(request_json)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.edit_risk_analysis_dc_plan"><code class="name flex">
<span>def <span class="ident">edit_risk_analysis_dc_plan</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Edit Risk Analysis Data Classification Plan options
Args:
**kwargs for risk analysis Data Classification Plan
index_content
(bool)
&ndash;
Specifies whether to index content or not to index server
content_analyzer
(list)
&ndash;
list of Content analyzer client name
entity_list
(list)
&ndash;
list of entities which needs to be extracted
classifier_list
(list)
&ndash;
list of classifier which needs to be classified
enable_ocr
(bool)
&ndash;
specifies whether OCR is enabled or not
ocr_language
(int)
&ndash;
Language to be used when doing OCR
Default : English (Value-1)
Supported Languages:
ENGLISH = 1,
HEBREW = 2,
SPANISH = 3,
FRENCH = 4,
ITALIAN = 5,
DANISH = 6
include_docs
(str)
&ndash;
Include documents type separated by comma
exclude_path
(list)
&ndash;
List of paths which needs to be excluded
min_doc_size
(int)
&ndash;
Minimum document size in MB
max_doc_size
(int)
&ndash;
Maximum document size in MB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L4037-L4114" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def edit_risk_analysis_dc_plan(self, **kwargs):
    &#34;&#34;&#34;
    Edit Risk Analysis Data Classification Plan options
        Args:
        **kwargs for risk analysis Data Classification Plan
        index_content       (bool)      --  Specifies whether to index content or not to index server
        content_analyzer    (list)      --  list of Content analyzer client name
        entity_list         (list)      --  list of entities which needs to be extracted
        classifier_list     (list)      --  list of classifier which needs to be classified
        enable_ocr          (bool)      --  specifies whether OCR is enabled or not
        ocr_language        (int)       --  Language to be used when doing OCR
                                            Default : English (Value-1)
            Supported Languages:
                        ENGLISH = 1,
                        HEBREW = 2,
                        SPANISH = 3,
                        FRENCH = 4,
                        ITALIAN = 5,
                        DANISH = 6
        include_docs        (str)       --  Include documents type separated by comma
        exclude_path        (list)      --  List of paths which needs to be excluded
        min_doc_size        (int)       --  Minimum document size in MB
        max_doc_size        (int)       --  Maximum document size in MB
    &#34;&#34;&#34;
    if self.plan_type != PlanTypes.DC.value:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Function Not supported for this plan type&#34;)
    request_json = {}
    if self.plan_type == PlanTypes.DC.value:
        if &#39;content_analyzer&#39; in kwargs:
            # change to support SaaS and unification project
            ca_list = []
            for ca in kwargs.get(&#39;content_analyzer&#39;, []):
                ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                ca_list.append({
                    &#39;id&#39;: ca_client_id
                })
            request_json[&#39;contentAnalyzer&#39;] = ca_list

        request_json[&#39;entityDetection&#39;] = {}
        activate_obj = self._commcell_object.activate
        entity_mgr_obj = activate_obj.entity_manager()
        if &#39;entity_list&#39; in kwargs:
            entity_list = []
            entity_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;entity_list&#39;, []))
            for entity_id in entity_ids:
                entity_list.append({&#34;id&#34;: entity_id})
            request_json[&#39;entityDetection&#39;][&#34;entities&#34;] = entity_list
        if &#39;classifier_list&#39; in kwargs:
            classifier_list = []
            classifier_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;classifier_list&#39;, []))
            for classifier_id in classifier_ids:
                classifier_list.append({&#34;id&#34;: classifier_id})
            request_json[&#39;entityDetection&#39;][&#34;classifiers&#34;] = classifier_list

        request_json[&#39;contentIndexing&#39;] = {}
        if &#39;index_content&#39; in kwargs:
            request_json[&#39;contentIndexing&#39;][&#34;searchType&#34;] = kwargs.get(
                &#39;index_content&#39;, PlanConstants.RAPlanSearchType.SEARCH_TYPE_ONLY_METADATA).value
        if &#39;enable_ocr&#39; in kwargs:
            request_json[&#39;contentIndexing&#39;][&#34;extractTextFromImage&#34;] = kwargs.get(&#39;enable_ocr&#39;, False)
            request_json[&#39;contentIndexing&#39;][&#34;contentLanguage&#34;] = kwargs.get(&#39;ocr_language&#39;, 1)

        request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;] = {}
        if &#39;include_docs&#39; in kwargs:
            request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
                &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
        if &#39;min_doc_size&#39; in kwargs:
            request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
                &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
        if &#39;max_doc_size&#39; in kwargs:
            request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;maxDocSize&#39;] = kwargs.get(
                &#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
        if &#39;exclude_path&#39; in kwargs:
            request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, [])

    flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_DC_PLAN, request_json)
    self.__handle_response(flag, response, custom_error_message=&#39;Failed to edit risk analysis DC plan : &#39;
                                                                f&#39;[{self.plan_name}]&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.edit_schedule"><code class="name flex">
<span>def <span class="ident">edit_schedule</span></span>(<span>self, schedule_options:Â dict, schedule_filter:Â dict) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Method to edit the schedule options of the plan</p>
<h2 id="args">Args</h2>
<p>schedule_options (dict) - schedule options to be edited
schedule_filter (dict)
- schedule for which the options are to be edited</p>
<p>Refer to the add_schedule method for the format of the schedule options</p>
<p>Refer to the get_schedule_properties method for the format of the schedule filter</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
- if failed to edit the schedule options of the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2996-L3029" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def edit_schedule(self, schedule_options: dict, schedule_filter: dict) -&gt; None:
    &#34;&#34;&#34;
    Method to edit the schedule options of the plan

    Args:
        schedule_options (dict) - schedule options to be edited
        schedule_filter (dict)  - schedule for which the options are to be edited

        Refer to the add_schedule method for the format of the schedule options

        Refer to the get_schedule_properties method for the format of the schedule filter

    Returns:
        None

    Raises:
        SDKException:
            - if failed to edit the schedule options of the plan
    &#34;&#34;&#34;
    schedule_payload = self.get_schedule_properties(schedule_filter)

    schedule_payload[&#39;scheduleOperation&#39;] = &#39;MODIFY&#39;
    # update the payload with the new provided options
    schedule_payload = self.plan_v4_helper.update_payload(schedule_payload, schedule_options)

    payload = {
        &#34;backupFrequency&#34;: {
            &#34;schedules&#34;: [schedule_payload]
        }
    }

    flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._PLAN_RPO, payload)

    self.__handle_response(flag, response, custom_error_message=f&#39;Failed to edit schedule options for the plan: [{self.plan_name}]&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.edit_snapshot_options"><code class="name flex">
<span>def <span class="ident">edit_snapshot_options</span></span>(<span>self, enable_backup_copy:Â boolÂ =Â True, backup_copy_rpo:Â intÂ =Â None) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Method to edit the snapshot options of the plan</p>
<h2 id="args">Args</h2>
<p>enable_backup_copy (bool)
-
enable backup copy for the plan</p>
<p>backup_copy_rpo (int)
-
backup copy RPO for the plan</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
-
if failed to edit the snapshot options of the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3060-L3087" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def edit_snapshot_options(self, enable_backup_copy:bool=True, backup_copy_rpo: int=None) -&gt; None:
    &#34;&#34;&#34;
    Method to edit the snapshot options of the plan

    Args:
        enable_backup_copy (bool)   -   enable backup copy for the plan

        backup_copy_rpo (int)       -   backup copy RPO for the plan

    Returns:
        None

    Raises:
        SDKException:
            -   if failed to edit the snapshot options of the plan
    &#34;&#34;&#34;
    request_json = {
        &#34;snapshotOptions&#34;: {
            &#34;enableBackupCopy&#34;: enable_backup_copy
        }
    }

    if backup_copy_rpo:
        request_json[&#34;snapshotOptions&#34;][&#34;backupCopyRPOMins&#34;] = backup_copy_rpo

    flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._V4_PLAN, request_json)

    self.__handle_response(flag, response, custom_error_message=f&#39;Failed to edit snapshot settings for the plan : [{self.plan_name}]&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.enable_data_aging"><code class="name flex">
<span>def <span class="ident">enable_data_aging</span></span>(<span>self, plan_copy_id:Â int, is_enable=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Method is used to enable/disable the data aging for the plan copy</p>
<h2 id="args">Args</h2>
<p>plan_copy_id(int)
:
copy_id of the plan</p>
<p>is_enable(bool)
:
value whether to be unable or disable the data aging</p>
<pre><code>                  example: true = enable
                           false = disable
</code></pre>
<h2 id="raises">Raises</h2>
<p>SDKException:
if response is empty</p>
<pre><code>if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L4350-L4381" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def enable_data_aging(self, plan_copy_id: int, is_enable=True):

    &#34;&#34;&#34;Method is used to enable/disable the data aging for the plan copy

        Args:
            plan_copy_id(int)      :   copy_id of the plan

            is_enable(bool)       :   value whether to be unable or disable the data aging

                                  example: true = enable
                                           false = disable
        Raises:
            SDKException:
                if response is empty

                if response is not success
    &#34;&#34;&#34;
    payload = {
        &#34;retentionRules&#34;: {
            &#34;enableDataAging&#34;: is_enable
        }
    }

    api_url = self._services[&#39;ENABLE_DATA_AGING&#39;] % (self._plan_id, plan_copy_id)
    flag, response = self._cvpysdk_object.make_request(method=&#39;PUT&#39;,
                                                       url=api_url, payload=payload)
    if not flag:
        raise SDKException(&#39;Response&#39;, &#39;101&#39;,
                           self._commcell_object._update_response_(response.text))
    if not response:
        raise SDKException(&#39;Response&#39;, &#39;102&#39;,
                           self._commcell_object._update_response_(response.text))</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.get_plan_properties"><code class="name flex">
<span>def <span class="ident">get_plan_properties</span></span>(<span>self) â€‘>Â Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Method to get the properties of this plan fetched from v4 API.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict</code></dt>
<dd>A dictionary containing the properties of the plan fetched from the v4 API.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2700-L2707" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_plan_properties(self) -&gt; Dict:
    &#34;&#34;&#34;
    Method to get the properties of this plan fetched from v4 API.
    
    Returns:
        Dict: A dictionary containing the properties of the plan fetched from the v4 API.
    &#34;&#34;&#34;
    return self._v4_plan_properties</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.get_schedule_properties"><code class="name flex">
<span>def <span class="ident">get_schedule_properties</span></span>(<span>self, schedule_filter:Â dict) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Method to get the schedule properties of the plan</p>
<h2 id="args">Args</h2>
<p>schedule_filter (dict) - dictionary containing the filter criteria for the schedule</p>
<p>Example for schedule filter:</p>
<h1 id="select-the-full-backup-schedule">select the full backup schedule</h1>
<pre><code>{"backupType": "FULL"}
</code></pre>
<h1 id="select-the-schedule-where-backup-type-is-incremental-and-schedule-is-applicable-to-all-agents">select the schedule where backup type is incremental and schedule is applicable to all agents</h1>
<p>{"backupType": "INCREMENTAL", "forDatabasesOnly": False}</p>
<h2 id="returns">Returns</h2>
<p>dict - schedule properties of the plan</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
- if no schedule is found with the provided filter
- if multiple schedules are found with the provided filter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2912-L2944" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_schedule_properties(self, schedule_filter: dict) -&gt; dict:
    &#34;&#34;&#34;
    Method to get the schedule properties of the plan

    Args:
        schedule_filter (dict) - dictionary containing the filter criteria for the schedule

        Example for schedule filter:

        # select the full backup schedule
            {&#34;backupType&#34;: &#34;FULL&#34;}

        # select the schedule where backup type is incremental and schedule is applicable to all agents
        {&#34;backupType&#34;: &#34;INCREMENTAL&#34;, &#34;forDatabasesOnly&#34;: False}

    Returns:
        dict - schedule properties of the plan

    Raises:
        SDKException:
            - if no schedule is found with the provided filter
            - if multiple schedules are found with the provided filter
    &#34;&#34;&#34;
    schedules = self._v4_plan_properties[&#39;rpo&#39;][&#39;backupFrequency&#39;][&#39;schedules&#39;]
    filtered_schedules = [schedule for schedule in schedules if all(schedule.get(key) == value for key, value in schedule_filter.items())]

    if not filtered_schedules:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;No schedule found with the provided filter: {schedule_filter} for plan: [{self.plan_name}]&#39;)
    
    if len(filtered_schedules) &gt; 1:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Multiple schedules found with the provided filter: {schedule_filter} for plan: [{self.plan_name}]&#39;)

    return copy.deepcopy(filtered_schedules[0]) # return a deep copy to avoid modifying the original schedule properties</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.get_storage_copy_details"><code class="name flex">
<span>def <span class="ident">get_storage_copy_details</span></span>(<span>self, copy_name:Â str, region_name:Â strÂ =Â None) â€‘>Â Dict</span>
</code></dt>
<dd>
<div class="desc"><p>Method to get the storage copy details of the given copy name and region name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>copy_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the copy</dd>
<dt><strong><code>region_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary consisting of the properties of the given copy name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2709-L2737" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_storage_copy_details(self, copy_name: str, region_name: str = None) -&gt; Dict:
    &#34;&#34;&#34;Method to get the storage copy details of the given copy name and region name

    Args:
        copy_name (str): Name of the copy
        region_name (str, optional): Name of the region

    Returns:
        dict: Dictionary consisting of the properties of the given copy name
    &#34;&#34;&#34;
    backup_destinations = self._v4_plan_properties.get(&#39;backupDestinations&#39;, [])

    # Filter by region name
    if region_name:
        backup_destinations = list(filter(lambda item: item.get(&#39;region&#39;, {}).get(&#34;name&#34;) == region_name, backup_destinations))

    # Filter by copy name
    if copy_name:
        backup_destinations = list(filter(lambda item: item.get(&#39;planBackupDestination&#39;, {}).get(&#34;name&#34;) == copy_name, backup_destinations))

    if not backup_destinations:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;No copy found with name: [{copy_name}] and region: [{region_name}]&#39;)

    if len(backup_destinations) &gt; 1:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Multiple copies found with name: [{copy_name}] and region: [{region_name}]&#39;)
    
    copy_details = next(iter(backup_destinations), None)
    
    return copy.deepcopy(copy_details) # return a deep copy to avoid modifying the original properties</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.get_storage_copy_id"><code class="name flex">
<span>def <span class="ident">get_storage_copy_id</span></span>(<span>self, copy_name:Â str, region_name:Â strÂ =Â None) â€‘>Â int</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the storage copy id of the given copy name</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>copy_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the copy</dd>
<dt><strong><code>region_name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the region</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Storage copy id of the given copy name</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2739-L2750" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_storage_copy_id(self, copy_name: str, region_name: str = None) -&gt; int:
    &#34;&#34;&#34;Gets the storage copy id of the given copy name

    Args:
        copy_name (str): Name of the copy
        region_name (str, optional): Name of the region

    Returns:
        int: Storage copy id of the given copy name
    &#34;&#34;&#34;
    copy_details = self.get_storage_copy_details(copy_name, region_name)
    return copy_details.get(&#39;planBackupDestination&#39;, {}).get(&#39;id&#39;, 0) if copy_details else 0</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.modify_schedule"><code class="name flex">
<span>def <span class="ident">modify_schedule</span></span>(<span>self, schedule_json, is_full_schedule=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Modifies the incremental RPO schedule pattern of the plan with the given schedule json</p>
<p>Args:
schedule_json (dict) &ndash; {
pattern : {}, &ndash; Please refer SchedulePattern.create_schedule in schedules.py for the types of
pattern to be sent</p>
<pre><code>                     eg: {
                            "freq_type": 'daily',
                            "active_start_time": time_in_%H/%S (str),
                            "repeat_days": days_to_repeat (int)
                         }

    options: {} -- Please refer ScheduleOptions.py classes for respective schedule options

                    eg:  {
                        "maxNumberOfStreams": 0,
                        "useMaximumStreams": True,
                        "useScallableResourceManagement": True,
                        "totalJobsToProcess": 1000,
                        "allCopies": True,
                        "mediaAgent": {
                            "mediaAgentName": "&lt;ANY MEDIAAGENT&gt;"
                        }
                    }
    }
</code></pre>
<p>is_full_schedule (bool) &ndash;
Pass True if he schedule to be modified is the full backup schedule</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2618-L2662" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def modify_schedule(self, schedule_json, is_full_schedule=False):
    &#34;&#34;&#34;Modifies the incremental RPO schedule pattern of the plan with the given schedule json

        Args:
        schedule_json (dict) -- {
                pattern : {}, -- Please refer SchedulePattern.create_schedule in schedules.py for the types of
                                 pattern to be sent

                                 eg: {
                                        &#34;freq_type&#34;: &#39;daily&#39;,
                                        &#34;active_start_time&#34;: time_in_%H/%S (str),
                                        &#34;repeat_days&#34;: days_to_repeat (int)
                                     }

                options: {} -- Please refer ScheduleOptions.py classes for respective schedule options

                                eg:  {
                                    &#34;maxNumberOfStreams&#34;: 0,
                                    &#34;useMaximumStreams&#34;: True,
                                    &#34;useScallableResourceManagement&#34;: True,
                                    &#34;totalJobsToProcess&#34;: 1000,
                                    &#34;allCopies&#34;: True,
                                    &#34;mediaAgent&#34;: {
                                        &#34;mediaAgentName&#34;: &#34;&lt;ANY MEDIAAGENT&gt;&#34;
                                    }
                                }
                }
        is_full_schedule (bool) --  Pass True if he schedule to be modified is the full backup schedule
    &#34;&#34;&#34;
    if is_full_schedule:
        try:
            schedule_id = list(filter(
                lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 4194304, self.schedule_policies[&#39;data&#39;]._subtasks
            ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
        except IndexError:
            raise IndexError(&#39;Full backup schedule not enabled&#39;)
    else:
        schedule_id = list(filter(
            lambda st: st[&#39;subTask&#39;][&#39;flags&#39;] == 65536, self.schedule_policies[&#39;data&#39;]._subtasks
        ))[0][&#39;subTask&#39;][&#39;subTaskId&#39;]
    self.schedule_policies[&#39;data&#39;].modify_schedule(
        schedule_json,
        schedule_id=schedule_id
    )
    self.refresh()</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.policy_subclient_ids"><code class="name flex">
<span>def <span class="ident">policy_subclient_ids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns Policy subclient IDs of the plan</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict </code></dt>
<dd>OS and its associated subclient ID</dd>
</dl>
<p>example:
{
'Windows' : windows_subclient_policy_subclient_id,
'Linux' : linux_subclient_policy_subclient_id,
'Mac' : mac_subclient_policy_subclient_id
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L4151-L4181" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def policy_subclient_ids(self):
    &#34;&#34;&#34;Returns Policy subclient IDs of the plan
    
    Returns:
        dict : OS and its associated subclient ID
    
    example:
        {
            &#39;Windows&#39; : windows_subclient_policy_subclient_id,
            &#39;Linux&#39; : linux_subclient_policy_subclient_id,
            &#39;Mac&#39; : mac_subclient_policy_subclient_id
        }
    
    &#34;&#34;&#34;
    result = dict()
    for backupset_id in self.subclient_policy:
        url = self._commcell_object._services[&#39;ADD_SUBCLIENT&#39;] + &#39;?clientId=2&amp;applicationId=1030&amp;backupsetid=&#39; + str(backupset_id)

        flag, response = self._commcell_object._cvpysdk_object.make_request(&#39;GET&#39;, url)
        if flag:
            if response.json() and &#39;subClientProperties&#39; in response.json():
                subclient_id = response.json()[&#39;subClientProperties&#39;][0][&#39;subClientEntity&#39;][&#39;subclientId&#39;]
                backupset_name = response.json()[&#39;subClientProperties&#39;][0][&#39;subClientEntity&#39;][&#39;backupsetName&#39;]
                os = backupset_name.split()[-3]
                result[os] = subclient_id
            else:
                raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to get subclient Ids.&#39;)
        else:
            raise SDKException(&#39;Plan&#39;, 102, response.text)
        
    return result</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the properties of the Plan.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3711-L3727" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Refresh the properties of the Plan.&#34;&#34;&#34;
    self._properties = self._get_plan_properties()

    # fetch v4 properties for server plans
    if self.subtype == 33554437:
        self._v4_plan_properties = self._get_v4_plan_properties()

    # lazy loading of properties
    self._data_schedule_policy = None
    self._log_schedule_policy = None
    self._snap_schedule_policy = None
    self._child_policies = {
        &#39;storagePolicy&#39;: None,
        &#39;schedulePolicy&#39;: {},
        &#39;subclientPolicyIds&#39;: []
    } # reset to constructor state</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.remove_region"><code class="name flex">
<span>def <span class="ident">remove_region</span></span>(<span>self, region_name:Â str) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Method to remove a region from the plan</p>
<h2 id="args">Args</h2>
<p>region_name (str)
-
name of the region that is being removed</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
-
if failed to remove the region from the plan</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2892-L2910" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def remove_region(self, region_name: str) -&gt; None:
    &#34;&#34;&#34;
    Method to remove a region from the plan

    Args:
        region_name (str)   -   name of the region that is being removed

    Returns:
        None

    Raises:
        SDKException:
            -   if failed to remove the region from the plan
    &#34;&#34;&#34;
    region_id = self._commcell_object.regions.get(region_name).region_id

    flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, self._services[&#39;SERVER_PLAN_REGIONS&#39;] % (self.plan_id, region_id))

    self.__handle_response(flag, response, custom_error_message=f&#39;Failed to remove region from the plan: [{self.plan_name}]&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.schedule"><code class="name flex">
<span>def <span class="ident">schedule</span></span>(<span>self, schedule_name, pattern_json, ops_type=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates or modifies the schedule associated with plan</p>
<h2 id="args">Args</h2>
<p>schedule_name
(str)
&ndash;
Schedule name</p>
<p>pattern_json
(dict)
&ndash;
Schedule pattern dict (Refer to Create_schedule_pattern in schedule.py)</p>
<p>ops_type
(int)
&ndash;
Operation type</p>
<pre><code>                                    Default : 2 (Add)

                                    Supported : 2 (Add/Modify)
</code></pre>
<h2 id="raises">Raises</h2>
<p>SDKException:</p>
<pre><code>  if input is not valid

  if failed to create/modify schedule

  if plan is not of type Data classification plan
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3897-L3939" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def schedule(self, schedule_name, pattern_json, ops_type=2):
    &#34;&#34;&#34;Creates or modifies the schedule associated with plan

            Args:

                schedule_name       (str)       --  Schedule name

                pattern_json        (dict)      --  Schedule pattern dict (Refer to Create_schedule_pattern in schedule.py)

                ops_type            (int)       --  Operation type

                                                        Default : 2 (Add)

                                                        Supported : 2 (Add/Modify)

            Raises:

                  SDKException:

                        if input is not valid

                        if failed to create/modify schedule

                        if plan is not of type Data classification plan

    &#34;&#34;&#34;
    if not isinstance(schedule_name, str) or not isinstance(pattern_json, dict):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    if self.plan_type not in [PlanTypes.DC.value]:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Add/Modify Schedule is supported only for DC Plan via CvpySDK&#34;)
    if ops_type not in [2]:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Schedule operation type provided is not supported&#34;)
    request_json = copy.deepcopy(PlanConstants.PLAN_SCHEDULE_REQUEST_JSON[self.plan_type])
    request_json[&#39;summary&#39;][&#39;plan&#39;][&#39;planId&#39;] = int(self.plan_id)
    request_json[&#39;schedule&#39;][&#39;associations&#39;][0][&#39;entityId&#39;] = int(self.plan_id)
    request_json[&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;] = f&#34;Cvpysdk created Schedule policy for plan - {self.plan_name}&#34;
    request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;subTask&#39;][
        &#39;subTaskName&#39;] = schedule_name
    request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;pattern&#39;] = pattern_json
    request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;adminOpts&#39;][&#39;contentIndexingOption&#39;][&#39;operationType&#39;] = ops_type
    if self._dc_plan_props[&#39;targetApps&#39;][0] == TargetApps.FS.value:
        request_json[&#39;schedule&#39;][&#39;subTasks&#39;][0][&#39;subTask&#39;][&#39;operationType&#39;] = 5022
    self._update_plan_props(request_json)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.share"><code class="name flex">
<span>def <span class="ident">share</span></span>(<span>self, user_or_group_name, role_name, is_user=True, ops_type=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Shares plan with given user or group by associating with given role</p>
<h2 id="args">Args</h2>
<p>user_or_group_name
(str)
&ndash;
User or Group name to which we are sharing</p>
<p>role_name
(str)
&ndash;
Role name which needs to associated with</p>
<p>ops_type
(int)
&ndash;
Operation type</p>
<pre><code>                                    Default : 1 (Add)

                                    Supported : 1 (Add)
                                                3 (Delete)
</code></pre>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:</p>
<pre><code>    if input is not valid

    if failed to do sharing

    if user/group/role not exists on commcell

    if failed to get exisitng association details
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3784-L3895" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def share(self, user_or_group_name, role_name, is_user=True, ops_type=1):
    &#34;&#34;&#34;Shares plan with given user or group by associating with given role

            Args:

                user_or_group_name      (str)       --  User or Group name to which we are sharing

                role_name               (str)       --  Role name which needs to associated with

                ops_type                (int)       --  Operation type

                                                        Default : 1 (Add)

                                                        Supported : 1 (Add)
                                                                    3 (Delete)

            Returns:

                None

            Raises:

                SDKException:

                        if input is not valid

                        if failed to do sharing

                        if user/group/role not exists on commcell

                        if failed to get exisitng association details

    &#34;&#34;&#34;
    if not isinstance(user_or_group_name, str) or not isinstance(role_name, str):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    if ops_type not in [1, 3]:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Sharing operation type provided is not supported&#34;)
    if is_user:
        if not self._commcell_object.users.has_user(user_or_group_name):
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;User doesn&#39;t exists in the commcell&#34;)
    if not self._commcell_object.roles.has_role(role_name=role_name):
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#34;Role doesn&#39;t exists in the commcell&#34;)
    request_json = copy.deepcopy(PlanConstants.PLAN_SHARE_REQUEST_JSON)
    association_response = None
    if ops_type == 1 and len(self.security_associations) &gt; 1:
        association_request_json = copy.deepcopy(PlanConstants.PLAN_SHARE_REQUEST_JSON)
        del association_request_json[&#39;securityAssociations&#39;]
        association_request_json[&#39;entityAssociated&#39;][&#39;entity&#39;][0][&#39;entityId&#39;] = int(self._plan_id)
        flag, response = self._cvpysdk_object.make_request(
            &#39;GET&#39;, self._API_SECURITY_ENTITY %
            (self._plan_entity_type, int(
                self._plan_id)), association_request_json)
        if flag:
            if response.json() and &#39;securityAssociations&#39; in response.json():
                association_response = response.json(
                )[&#39;securityAssociations&#39;][0][&#39;securityAssociations&#39;][&#39;associations&#39;]
            else:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Failed to get existing security associations&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    external_user = False
    if &#39;\\&#39; in user_or_group_name:
        external_user = True
    if is_user:
        user_obj = self._commcell_object.users.get(user_or_group_name)
        user_id = user_obj.user_id
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;userId&#39;] = int(user_id)
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;_type_&#39;] = 13
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;userName&#39;] = user_or_group_name
    elif external_user:
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;groupId&#39;] = 0
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;_type_&#39;] = 62
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][
            &#39;externalGroupName&#39;] = user_or_group_name
    else:
        grp_obj = self._commcell_object.user_groups.get(user_or_group_name)
        grp_id = grp_obj.user_group_id
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;userGroupId&#39;] = int(grp_id)
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][&#39;_type_&#39;] = 15
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;userOrGroup&#39;][0][
            &#39;userGroupName&#39;] = user_or_group_name

    request_json[&#39;entityAssociated&#39;][&#39;entity&#39;][0][&#39;entityId&#39;] = int(self._plan_id)
    request_json[&#39;securityAssociations&#39;][&#39;associationsOperationType&#39;] = ops_type
    role_obj = self._commcell_object.roles.get(role_name)
    request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;properties&#39;][&#39;role&#39;][&#39;roleId&#39;] = role_obj.role_id
    request_json[&#39;securityAssociations&#39;][&#39;associations&#39;][0][&#39;properties&#39;][&#39;role&#39;][&#39;roleName&#39;] = role_obj.role_name

    # Associate existing associations to the request
    if ops_type == 1 and len(self.security_associations) &gt; 1:
        request_json[&#39;securityAssociations&#39;][&#39;associations&#39;].extend(association_response)

    flag, response = self._cvpysdk_object.make_request(
        &#39;POST&#39;, self._API_SECURITY, request_json
    )
    if flag:
        if response.json() and &#39;response&#39; in response.json():
            response_json = response.json()[&#39;response&#39;][0]
            error_code = response_json[&#39;errorCode&#39;]
            if error_code != 0:
                error_message = response_json[&#39;errorString&#39;]
                raise SDKException(
                    &#39;Plan&#39;,
                    &#39;102&#39;, error_message)
            self.refresh()
        else:
            raise SDKException(&#39;Plan&#39;, &#39;105&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.update_backup_content"><code class="name flex">
<span>def <span class="ident">update_backup_content</span></span>(<span>self, content, request_type='OVERWRITE')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>content (dict)
:
dictionary with backup content details. </p>
<dl>
<dt><strong><code>example</code></strong></dt>
<dd>content = {
'Windows' : {
'Content' : ['\%Pictures%', '\%Desktop%'],
'Exclude' : ['\%Documents%'],
'Except' : ['\%Documents%'],
'Backup System State' : True
},
'Linux' : {
'Content' : ['/%Pictures%'],
'Exclude' : ['/%Documents%']
},
'Mac' : {
'Content' : ['/%Pictures%'],
'Exclude' : ['/%Documents%']
}
}</dd>
</dl>
<p>request_type (str)
:
Supported values 'OVERWRITE' (default), 'UPDATE', 'DELETE'. </p>
<p>For plans created from SP32, Please use below format of content
example:
content = {
"windowsIncludedPaths": ["Desktop"],
"windowsExcludedPaths": ["Music"],
"windowsFilterToExcludePaths": ["Videos"],
"backupSystemState": True,
"useVSSForSystemState": True,
"backupSystemStateOnlyWithFullBackup": False
}</p>
<p>For unix and mac, replace key name with respective os name, <strong>IncludedPaths, </strong>ExcludedPaths, **FilterToExcludePaths</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L4263-L4348" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update_backup_content(self, content, request_type = &#39;OVERWRITE&#39;):
    &#34;&#34;&#34;
    Args:
        content (dict)  :  dictionary with backup content details. 
        
        example: 
            content = {
                &#39;Windows&#39; : {
                    &#39;Content&#39; : [&#39;\\%Pictures%&#39;, &#39;\\%Desktop%&#39;],
                    &#39;Exclude&#39; : [&#39;\\%Documents%&#39;],
                    &#39;Except&#39; : [&#39;\\%Documents%&#39;],
                    &#39;Backup System State&#39; : True
                },
                &#39;Linux&#39; : {
                    &#39;Content&#39; : [&#39;/%Pictures%&#39;],
                    &#39;Exclude&#39; : [&#39;/%Documents%&#39;]
                },
                &#39;Mac&#39; : {
                    &#39;Content&#39; : [&#39;/%Pictures%&#39;],
                    &#39;Exclude&#39; : [&#39;/%Documents%&#39;]
                }
            }
                
        request_type (str)      :  Supported values &#39;OVERWRITE&#39; (default), &#39;UPDATE&#39;, &#39;DELETE&#39;. 

        For plans created from SP32, Please use below format of content
        example:
            content = {
                &#34;windowsIncludedPaths&#34;: [&#34;Desktop&#34;],
                &#34;windowsExcludedPaths&#34;: [&#34;Music&#34;],
                &#34;windowsFilterToExcludePaths&#34;: [&#34;Videos&#34;],
                &#34;backupSystemState&#34;: True,
                &#34;useVSSForSystemState&#34;: True,
                &#34;backupSystemStateOnlyWithFullBackup&#34;: False
            }

        For unix and mac, replace key name with respective os name, **IncludedPaths, **ExcludedPaths, **FilterToExcludePaths
    &#34;&#34;&#34;
    
    update_request_type = {
        &#34;OVERWRITE&#34;: 1,
        &#34;UPDATE&#34;: 2,
        &#34;DELETE&#34;: 3
    }
    
    subclients = self.policy_subclient_ids()

    if not subclients:
        if &#39;Windows&#39; in content or &#39;Linux&#39; in content or &#39;Mac&#39; in content:
            content = self.__map_content_to_new_format(content)
        self.__update_content_policy(content)
        return
    
    for os, value in content.items():
        request_json = {
            &#34;subClientProperties&#34;: {
                &#34;fsExcludeFilterOperationType&#34;: update_request_type.get(request_type, 1),
                &#34;fsContentOperationType&#34; : update_request_type.get(request_type, 1)
            }
        }
        
        request_url = self._commcell_object._services[&#39;SUBCLIENT&#39;] % subclients[os]
        
        contents = list()
        for key, val in value.items():
            if key.lower() == &#39;content&#39;:
                for path in val: contents.append({&#34;path&#34; : path})
            if key.lower() == &#39;exclude&#39;:
                for path in val: contents.append({&#34;excludePath&#34; : path})
            if os == &#39;Windows&#39; and key == &#39;Backup System State&#39;:
                request_json[&#39;subClientProperties&#39;][&#39;fsSubClientProp&#39;] = {&#39;backupSystemState&#39; : val}
                
        if contents:
            request_json[&#39;subClientProperties&#39;][&#39;content&#39;] = contents
        
        flag, response = self._commcell_object._cvpysdk_object.make_request(&#39;POST&#39;, request_url, request_json)
            
        if flag:
            if response.json() and &#39;response&#39; in response.json():
                errorCode = response.json()[&#39;response&#39;][0].get(&#39;errorCode&#39;)
                if errorCode:
                    raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to Change Content of Plan.&#39;)
            else:
                raise SDKException(&#39;Plan&#39;, 102, &#39;Failed to get subclient Ids.&#39;)
        else:
            raise SDKException(&#39;Plan&#39;, 102, response.text)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plan.update_security_associations"><code class="name flex">
<span>def <span class="ident">update_security_associations</span></span>(<span>self, associations_list, is_user=True, request_type=None, external_group=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds the security association on the plan object</p>
<h2 id="args">Args</h2>
<p>associations_list
(list)
&ndash;
list of users to be associated
Example:
associations_list = [
{
'user_name': user1,
'role_name': role1
},
{
'user_name': user2,
'role_name': role2
}
]</p>
<p>is_user (bool)
&ndash;
True or False. set is_user = False, If associations_list made up of user groups
request_type (str)
&ndash;
eg : 'OVERWRITE' or 'UPDATE' or 'DELETE', Default will be OVERWRITE operation
external_group (bool)
&ndash;
True or False, set external_group = True. If Security associations is being done on External User Groups</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if association is not of List type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L3622-L3652" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update_security_associations(self, associations_list, is_user = True, request_type = None, external_group = False):
    &#34;&#34;&#34;
    Adds the security association on the plan object

    Args:
        associations_list   (list)  --  list of users to be associated
            Example:
                associations_list = [
                    {
                        &#39;user_name&#39;: user1,
                        &#39;role_name&#39;: role1
                    },
                    {
                        &#39;user_name&#39;: user2,
                        &#39;role_name&#39;: role2
                    }
                ]

        is_user (bool)           --    True or False. set is_user = False, If associations_list made up of user groups
        request_type (str)      --    eg : &#39;OVERWRITE&#39; or &#39;UPDATE&#39; or &#39;DELETE&#39;, Default will be OVERWRITE operation
        external_group (bool)    --    True or False, set external_group = True. If Security associations is being done on External User Groups

    Raises:
        SDKException:
            if association is not of List type
    &#34;&#34;&#34;
    if not isinstance(associations_list, list):
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;)

    SecurityAssociation(self._commcell_object, self)._add_security_association(associations_list, 
                                    is_user, request_type, external_group)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cvpysdk.plan.PlanTypes"><code class="flex name class">
<span>class <span class="ident">PlanTypes</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Class Enum to represent different plan types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L217-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PlanTypes(Enum):
    &#34;&#34;&#34;Class Enum to represent different plan types&#34;&#34;&#34;
    Any = 0
    DLO = 1
    MSP = 2
    FS = 3
    SNAP = 4
    VSA = 5
    EXCHANGE = 6
    DC = 7
    EDISCOVERY = 8
    ARCHIVER = 9</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="cvpysdk.plan.PlanTypes.ARCHIVER"><code class="name">var <span class="ident">ARCHIVER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cvpysdk.plan.PlanTypes.Any"><code class="name">var <span class="ident">Any</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cvpysdk.plan.PlanTypes.DC"><code class="name">var <span class="ident">DC</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cvpysdk.plan.PlanTypes.DLO"><code class="name">var <span class="ident">DLO</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cvpysdk.plan.PlanTypes.EDISCOVERY"><code class="name">var <span class="ident">EDISCOVERY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cvpysdk.plan.PlanTypes.EXCHANGE"><code class="name">var <span class="ident">EXCHANGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cvpysdk.plan.PlanTypes.FS"><code class="name">var <span class="ident">FS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cvpysdk.plan.PlanTypes.MSP"><code class="name">var <span class="ident">MSP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cvpysdk.plan.PlanTypes.SNAP"><code class="name">var <span class="ident">SNAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="cvpysdk.plan.PlanTypes.VSA"><code class="name">var <span class="ident">VSA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="cvpysdk.plan.Plans"><code class="flex name class">
<span>class <span class="ident">Plans</span></span>
<span>(</span><span>commcell_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for representing all the plans in the commcell.</p>
<p>Initialize object of Plans class.</p>
<h2 id="args">Args</h2>
<p>commcell_object (object)
&ndash; instance of the Commcell class</p>
<h2 id="returns">Returns</h2>
<p>object - instance of Plans class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L479-L2043" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Plans(object):
    &#34;&#34;&#34;Class for representing all the plans in the commcell.&#34;&#34;&#34;

    def __init__(self, commcell_object):
        &#34;&#34;&#34;Initialize object of Plans class.

            Args:
                commcell_object (object)  -- instance of the Commcell class

            Returns:
                object - instance of Plans class
        &#34;&#34;&#34;

        self._all_plans_props = None
        self._commcell_object = commcell_object

        self._cvpysdk_object = commcell_object._cvpysdk_object
        self._services = commcell_object._services
        self._update_response_ = commcell_object._update_response_

        self._PLANS = self._services[&#39;PLANS&#39;]
        self._V4_DC_PLANS = self._services[&#39;V4_DC_PLANS&#39;]
        self._V4_PLANS = self._services[&#39;V4_SERVER_PLANS&#39;]
        self._V4_GLOBAL_PLANS = self._services[&#39;V4_GLOBAL_SERVER_PLANS&#39;]
        self._plans = None
        self._plans_cache = None
        self.filter_query_count = 0
        self.refresh()

    def __str__(self):
        &#34;&#34;&#34;Representation string consisting of all plans of the Commcell.

            Returns:
                str - string of all the plans for a commcell
        &#34;&#34;&#34;
        representation_string = &#34;{:^5}\t{:^50}\n\n&#34;.format(&#39;S. No.&#39;, &#39;Plan&#39;)

        for index, plan in enumerate(self._plans):
            sub_str = &#39;{:^5}\t{:30}\n&#39;.format(index + 1, plan)
            representation_string += sub_str

        return representation_string.strip()

    def __repr__(self):
        &#34;&#34;&#34;Representation string for the instance of the Plans class.&#34;&#34;&#34;
        return &#34;Plans class instance for Commcell&#34;

    def __len__(self):
        &#34;&#34;&#34;Returns the number of the plans added to the Commcell.&#34;&#34;&#34;
        return len(self.all_plans)

    def __getitem__(self, value):
        &#34;&#34;&#34;Returns the name of the plan for the given plan ID or
            the details of the plan for given plan Name.

            Args:
                value   (str / int)     --  Name or ID of the plan

            Returns:
                str     -   name of the plan, if the plan id was given

                dict    -   dict of details of the plan, if plan name was given

            Raises:
                IndexError:
                    no plan exists with the given Name / Id

        &#34;&#34;&#34;
        value = str(value)

        if value in self.all_plans:
            return self.all_plans[value]
        else:
            try:
                return list(filter(lambda x: x[1][&#39;id&#39;] == value, self.all_plans.items()))[0][0]
            except IndexError:
                raise IndexError(&#39;No plan exists with the given Name / Id&#39;)

    def _get_plans(self, full_response: bool = False):
        &#34;&#34;&#34;Gets all the plans associated with the commcell
            Args:
                full_response(bool) --  flag to return complete response
            Returns:
                dict - consists of all plans in the commcell
                    {
                        &#34;plan1_name&#34;: plan1_id,
                        &#34;plan2_name&#34;: plan2_id
                    }

                Raises:
                    SDKException:
                        if response is empty

                        if response is not success
        &#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, self._PLANS)

        if flag:
            plans = {}

            if response.json() and &#39;plans&#39; in response.json():
                if full_response:
                    return response.json()

                name_count = {}

                for temp in response.json()[&#39;plans&#39;]:
                    temp_name = temp.get(&#39;plan&#39;, {}).get(&#39;planName&#39;, &#39;&#39;).lower()
                    temp_company = temp.get(&#39;plan&#39;, {}).get(&#39;entityInfo&#39;, {}).get(&#39;companyName&#39;, &#39;&#39;).lower()

                    if temp_name in name_count:
                        name_count[temp_name].add(temp_company)
                    else:
                        name_count[temp_name] = {temp_company}

                for temp in response.json()[&#39;plans&#39;]:
                    temp_name = temp.get(&#39;plan&#39;, {}).get(&#39;planName&#39;, &#39;&#39;).lower()
                    temp_id = str(temp[&#39;plan&#39;][&#39;planId&#39;]).lower()
                    temp_company = temp.get(&#39;plan&#39;, {}).get(&#39;entityInfo&#39;, {}).get(&#39;companyName&#39;, &#39;&#39;).lower()

                    if len(name_count[temp_name]) &gt; 1:
                        unique_key = f&#34;{temp_name}_({temp_company})&#34;
                    else:
                        unique_key = temp_name

                    plans[unique_key] = temp_id

            return plans
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_plan_template(self, plan_sub_type, plan_type=&#34;MSP&#34;):
        &#34;&#34;&#34;Gets the Plan subtype&#39;s JSON template.

            Args:
                plan_sub_type    (str)   --  Sub-type of plan to add

                    &#34;Server&#34;    -   Server Plans

                    &#34;FSServer&#34;  -   File System Plans

                    &#34;Laptop&#34;    -   Laptop Plans


                plan_type       (str)   --  Type of plan to add

                    default: &#34;MSP&#34;

            Returns:
                str     -   JSON string of the Plan&#39;s template

            Raises:
                SDKException:
                    if type or subtype of the plan does not exist

                    if there is a failure in getting the template

        &#34;&#34;&#34;
        if not (isinstance(plan_sub_type, str) and
                isinstance(plan_type, str)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            template_url = self._services[&#39;GET_PLAN_TEMPLATE&#39;] % (plan_type, plan_sub_type)

            flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, template_url)

            if flag:
                if response.json() and &#39;plan&#39; in response.json():
                    return response.json()
                else:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Failed to get Plan template&#39;)
            else:
                response_string = self._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_fl_parameters(self, fl: list = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the fl parameters to be passed in the mongodb caching api call

        Args:
            fl    (list)  --   list of columns to be passed in API request

        Returns:
            fl_parameters(str) -- fl parameter string
        &#34;&#34;&#34;
        self.valid_columns = {
            &#39;planName&#39;: &#39;plans.plan.planName&#39;,
            &#39;planId&#39;: &#39;plans.plan.planId&#39;,
            &#39;planType&#39;: &#39;plans.subtype&#39;,
            &#39;description&#39;: &#39;plans.description&#39;,
            &#39;numAssocEntities&#39;: &#39;plans.numAssocEntities&#39;,
            &#39;rpoInMinutes&#39;: &#39;plans.rpoInMinutes&#39;,
            &#39;numCopies&#39;: &#39;plans.numCopies&#39;,
            &#39;planStatusFlag&#39;: &#39;plans.planStatusFlag&#39;,
            &#39;storage&#39;: &#39;plans.storageResourcePoolMaps.resources.resourcePool&#39;,
            &#39;companyName&#39;: &#39;plans.plan.entityInfo.companyName&#39;,
            &#39;tags&#39;: &#39;tags&#39;
        }
        default_columns = &#39;plans.plan.planName,plans.plan.planId&#39;

        if fl:
            if all(col in self.valid_columns for col in fl):
                fl_parameters = f&#34;&amp;fl={default_columns},{&#39;,&#39;.join(self.valid_columns[column] for column in fl)}&#34;
            else:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid column name passed&#39;)
        else:
            fl_parameters = f&#34;&amp;fl={default_columns},{&#39;,&#39;.join(column for column in self.valid_columns.values())}&#34;

        return fl_parameters

    def _get_sort_parameters(self, sort: list = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the sort parameters to be passed in the mongodb caching api call

        Args:
            sort  (list)  --   contains the name of the column on which sorting will be performed and type of sort
                                valid sor type -- 1 for ascending and -1 for descending
                                e.g. sort = [&#39;connectName&#39;,&#39;1&#39;]

        Returns:
            sort_parameters(str) -- sort parameter string
        &#34;&#34;&#34;
        sort_type = str(sort[1])
        col = sort[0]
        if col in self.valid_columns.keys() and sort_type in [&#39;1&#39;, &#39;-1&#39;]:
            sort_parameter = &#39;&amp;sort=&#39; + self.valid_columns[col] + &#39;:&#39; + sort_type
        else:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid column name passed&#39;)
        return sort_parameter

    def _get_fq_parameters(self, fq: list = None) -&gt; str:
        &#34;&#34;&#34;
        Returns the fq parameters based on the fq list passed
        Args:
             fq     (list) --   contains the columnName, condition and value
                    e.g. fq = [[&#39;planName&#39;,&#39;contains&#39;, test&#39;],[&#39;numAssocEntities&#39;,&#39;between&#39;, &#39;0-1&#39;]]

        Returns:
            fq_parameters(str) -- fq parameter string
        &#34;&#34;&#34;
        conditions = {&#34;contains&#34;, &#34;notContain&#34;, &#34;eq&#34;, &#34;neq&#34;, &#34;gt&#34;, &#34;lt&#34;}
        params = []

        for column, condition, *value in fq or []:
            if column not in self.valid_columns:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid column name passed&#39;)

            # Handle &#39;tags&#39; column separately
            if column == &#34;tags&#34; and condition == &#34;contains&#34;:
                params.append(f&#34;&amp;tags={value[0]}&#34;)
            elif condition in conditions:
                params.append(f&#34;&amp;fq={self.valid_columns[column]}:{condition.lower()}:{value[0]}&#34;)
            elif condition == &#34;isEmpty&#34; and not value:
                params.append(f&#34;&amp;fq={self.valid_columns[column]}:in:null,&#34;)
            elif condition == &#34;between&#34; and value and &#34;-&#34; in value[0]:
                start, end = value[0].split(&#34;-&#34;, 1)
                params.append(f&#34;&amp;fq={self.valid_columns[column]}:gteq:{start}&#34;)
                params.append(f&#34;&amp;fq={self.valid_columns[column]}:lteq:{end}&#34;)
            else:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid condition passed&#39;)

        return &#34;&#34;.join(params)

    def get_plans_cache(self, hard: bool = False, **kwargs) -&gt; dict:
        &#34;&#34;&#34;
        Returns plan cache in response.

        Args:
            hard  (bool)    --   Flag to perform hard refresh on plans cache.
            **kwargs (dict):
                fl (list)   --   List of columns to return in response (default: None).
                sort (list) --   Contains the name of the column on which sorting will be performed and type of sort.
                                       Valid sort type: 1 for ascending and -1 for descending
                                       e.g. sort = [&#39;columnName&#39;, &#39;1&#39;] (default: None).
                limit (list)--   Contains the start and limit parameter value.
                                        Default [&#39;0&#39;, &#39;100&#39;].
                search (str)--   Contains the string to search in the commcell entity cache (default: None).
                fq (list)   --   Contains the columnName, condition, and value.
                                        e.g. fq = [[&#39;planName&#39;, &#39;contains&#39;, &#39;test&#39;],
                                        [&#39;numAssocEntities&#39;, &#39;between&#39;, &#39;0-1&#39;]] (default: None).

        Returns:
            dict: Dictionary of all the properties present in response.
        &#34;&#34;&#34;
        # computing parameters
        fl_parameters = self._get_fl_parameters(kwargs.get(&#39;fl&#39;, None))
        fq_parameters = self._get_fq_parameters(kwargs.get(&#39;fq&#39;, None))
        limit = kwargs.get(&#39;limit&#39;, None)
        limit_parameters = f&#39;start={limit[0]}&amp;limit={limit[1]}&#39; if limit else &#39;&#39;
        hard_refresh = &#39;&amp;hardRefresh=true&#39; if hard else &#39;&#39;
        sort_parameters = self._get_sort_parameters(kwargs.get(&#39;sort&#39;, None)) if kwargs.get(&#39;sort&#39;, None) else &#39;&#39;

        # Search operation can only be performed on limited columns, so filtering out the columns on which search works
        searchable_columns = [&#34;planName&#34;,&#34;planType&#34;,&#34;planStatusFlag&#34;,&#34;companyName&#34;,&#34;description&#34;]
        search_parameter = (f&#39;&amp;search=tagName,tagValue,{&#34;,&#34;.join(self.valid_columns[col] for col in searchable_columns)}&#39;
                            f&#39;:contains:{kwargs.get(&#34;search&#34;, None)}&#39;) if kwargs.get(&#39;search&#39;, None) else &#39;&#39;

        params = [
            limit_parameters,
            sort_parameters,
            fl_parameters,
            hard_refresh,
            search_parameter,
            fq_parameters
        ]
        request_url = f&#34;{self._PLANS}?&#34; + &#34;&#34;.join(params)
        flag, response = self._cvpysdk_object.make_request(&#34;GET&#34;, request_url)

        if not flag:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        plans_summary = {}
        if response.json() and &#39;plans&#39; in response.json():
            self.filter_query_count = response.json().get(&#39;filterQueryCount&#39;,0)
            for plan in response.json()[&#39;plans&#39;]:
                name = plan.get(&#34;plan&#34;, {}).get(&#34;planName&#34;, None)
                company = plan.get(&#39;plan&#39;, {}).get(&#39;entityInfo&#39;, {}).get(&#39;companyName&#39;, None)

                plan_config = {
                    &#39;planName&#39;:name,
                    &#39;planId&#39;: plan.get(&#39;plan&#39;, {}).get(&#39;planId&#39;, None),
                    &#39;planType&#39;: plan.get(&#39;subtype&#39;),
                    &#39;description&#39;: plan.get(&#39;description&#39;),
                    &#39;numCopies&#39;: plan.get(&#39;numCopies&#39;),
                    &#39;numAssocEntities&#39;: plan.get(&#39;numAssocEntities&#39;),
                    &#39;rpoInMinutes&#39;: plan.get(&#39;rpoInMinutes&#39;,0),
                    &#39;planStatusFlag&#39;: plan.get(&#39;planStatusFlag&#39;),
                    &#39;companyName&#39;: company,
                    &#39;tags&#39;: (plan.get(&#39;plan&#39;) or {}).get(&#39;tags&#39;) or []
                }
                if &#39;storageResourcePoolMaps&#39; in plan and &#39;resources&#39; in plan.get(&#39;storageResourcePoolMaps&#39;, {})[0]:
                    plan_config[&#39;resourcePool&#39;] = [
                        resource.get(&#39;resourcePool&#39;, {}).get(&#39;resourcePoolName&#39;)
                        for resource in plan.get(&#39;storageResourcePoolMaps&#39;, {})[0].get(&#39;resources&#39;)
                    ]
                # Check if plan name already exists for a different company
                unique_name = name
                if name in plans_summary and plans_summary[name].get(&#39;companyName&#39;) != company:
                    unique_name = f&#34;{name}_({company})&#34;
                plans_summary[unique_name] = plan_config

            return plans_summary
        else:
            raise SDKException(&#34;Plan&#34;, &#34;102&#34;, &#34;Failed to get plans summary&#34;)

    @property
    def all_plans(self):
        &#34;&#34;&#34;Returns the dictionary consisting of all the plans added to the Commcell.

            dict - consists of all the plans configured on the commcell

                {
                    &#34;plan1_name&#34;: plan1_id,

                    &#34;plan2_name&#34;: plan2_id
                }

        &#34;&#34;&#34;
        return self._plans

    @property
    def all_plans_cache(self):
        &#34;&#34;&#34;Returns the dictionary consisting of all the plans cache present in mongoDB

                    dict - consists of all the plans configured on the commcell

                        {
                        &#34;plan1_name&#34;:
                         {
                         id : &lt;plan&#39;s id&gt;,
                         Type : &lt;type of plan&gt;,
                         subtype : &lt;sub type of plan&gt;,
                         status: &lt;status of the plan&gt;,
                         numCopies: &lt;number of copies&gt;,
                         numAssocEntities: &lt;associated Entities Count&gt;,
                         RPO: &lt;rpo in minutes&gt;,
                         planStatusFlag: &lt;status of plan&gt;,
                         company: &lt;name of the company plan belongs to&gt;
                         },

                        &#34;plan2_name&#34;:
                         {
                         id : &lt;plan&#39;s id&gt;,
                         Type : &lt;type of plan&gt;,
                         subtype : &lt;sub type of plan&gt;,
                         status: &lt;status of the plan&gt;,
                         numCopies: &lt;number of copies&gt;,
                         numAssocEntities: &lt;associated Entities Count&gt;,
                         RPO: &lt;rpo in minutes&gt;,
                         planStatusFlag: &lt;status of plan&gt;,
                         company: &lt;name of the company plan belongs to&gt;
                         },
                    }

                &#34;&#34;&#34;
        if not self._plans_cache:
            self._plans_cache = self.get_plans_cache()
        return self._plans_cache

    def filter_plans(self, plan_type, company_name=None):
        &#34;&#34;&#34;
        Returns the dictionary consisting of specified type and company plans.

        Args:
            plan_type (str)      --      Type of plan [&#39;DLO&#39;, &#39;Server&#39;, &#39;Laptop&#39;, &#39;Database&#39;, &#39;FSServer&#39;, &#39;FSIBMiVTL&#39;, &#39;Snap&#39;, &#39;VSAServer&#39;, &#39;VSAReplication&#39;, 
                                                        &#39;ExchangeUser&#39;, &#39;ExchangeJournal&#39;, &#39;Office365&#39;, &#39;Dynamics365&#39;, &#39;DataClassification&#39;, &#39;Archiver&#39;]
            company_name (str)    --     To filter plans based on the company. For Commcell, company_name = &#39;Commcell&#39;. Default will return all plans

        Returns:
            dict - consists of all the plans with specified types configured on the commcell
                {
                    &#34;plan1_name&#34;: plan1_id,
                    &#34;plan2_name&#34;: plan2_id
                }

        Raises:
            SDKException:
                if input data type is not valid
                if an invalid plan type is passed as a parameter
                if failed to get the response
        &#34;&#34;&#34;
        if not isinstance(plan_type, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        
        plan_type_lower = plan_type.lower()
        
        if plan_type_lower not in [&#34;dlo&#34;, &#34;server&#34;, &#34;laptop&#34;, &#34;database&#34;, &#34;fsserver&#34;, &#34;fsibmivtl&#34;, &#34;snap&#34;, 
                                    &#34;vsaserver&#34;, &#34;vsareplication&#34;, &#34;exchangeuser&#34;, &#34;exchangejournal&#34;, 
                                    &#34;office365&#34;, &#34;dynamics365&#34;, &#34;dataclassification&#34;, &#34;archiver&#34;]:
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid Plan Type Passed as Parameter&#39;)

        params = f&#34;fq=plans.subtype%3Ain%3A{plan_type}&amp;fl=plans.plan.planId%2Cplans.plan.planName%2Cplans.subtype%2Cplans.type&#34;

        if company_name:
            company_id = (
                self._commcell_object.organizations.get(company_name).organization_id 
                if company_name != &#39;Commcell&#39; else 0
            )
            params += f&#34;&amp;fq=companyId%3Aeq%3A{company_id}&#34;

        template_url = self._services[&#39;PLAN_SUMMARY&#39;] % params

        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, template_url)

        if flag:
            result = dict()
            if &#39;plans&#39; in response.json():
                for plan in response.json()[&#39;plans&#39;]:
                    result[plan[&#39;plan&#39;][&#39;name&#39;]] = plan[&#39;plan&#39;][&#39;id&#39;]
            return result
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def has_plan(self, plan_name):
        &#34;&#34;&#34;Checks if a plan exists in the commcell with the input plan name.

            Args:
                plan_name   (str)   --  name of the plan

            Returns:
                bool    -   boolean output whether the plan exists in the commcell or not

            Raises:
                SDKException:
                    if type of the plan name argument is not string

        &#34;&#34;&#34;
        if not isinstance(plan_name, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)

        return self._plans and plan_name.lower() in self._plans

    def get(self, plan_name):
        &#34;&#34;&#34;Returns a plan object of the specified plan name.

            Args:
                plan_name (str)  --  name of the plan

            Returns:
                object - instance of the Plan class for the the given plan name

            Raises:
                SDKException:
                    if type of the plan name argument is not string

                    if no plan exists with the given name
        &#34;&#34;&#34;
        if not isinstance(plan_name, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            plan_name = plan_name.lower()

            if self.has_plan(plan_name):
                return Plan(
                    self._commcell_object,
                    plan_name,
                    self._plans[plan_name]
                )

            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                    plan_name)
            )

    def delete(self, plan_name):
        &#34;&#34;&#34;Deletes the plan from the commcell.

            Args:
                plan_name (str)  --  name of the plan to remove from the commcell

            Raises:
                SDKException:
                    if type of the plan name argument is not string

                    if failed to delete plan

                    if response is empty

                    if response is not success

                    if no plan exists with the given name
        &#34;&#34;&#34;
        if not isinstance(plan_name, str):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            plan_name = plan_name.lower()

            if self.has_plan(plan_name):
                plan_id = self._plans[plan_name]

                delete_plan = self._services[&#39;DELETE_PLAN&#39;] % (plan_id)

                flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, delete_plan)

                error_code = 0

                if flag:
                    if &#39;error&#39; in response.json():
                        if isinstance(response.json()[&#39;error&#39;], list):
                            error_code = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                        else:
                            error_code = response.json()[&#39;errorCode&#39;]

                    if error_code != 0:
                        o_str = &#39;Failed to delete plan&#39;
                        if isinstance(response.json()[&#39;error&#39;], list):
                            error_message = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]
                        else:
                            error_message = response.json()[&#39;errorMessage&#39;]
                        o_str += &#39;\nError: &#34;{0}&#34;&#39;.format(error_message)
                        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
                    else:
                        # initialize the plan again
                        # so the plan object has all the plan
                        self.refresh()
                        self._commcell_object.storage_policies.refresh()
                else:
                    response_string = self._update_response_(response.text)
                    raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
            else:
                raise SDKException(
                    &#39;Plan&#39;,
                    &#39;102&#39;,
                    &#39;No plan exists with name: {0}&#39;.format(plan_name)
                )

    def add_exchange_plan(self, plan_name: str, plan_sub_type: str = &#39;ExchangeUser&#39;, **kwargs):
        &#34;&#34;&#34;Adds a new exchange plan to the commcell.

            Args:
                plan_name           (str)   --  name of the new plan to add

                plan_sub_type       (str)   --  Type of plan to add - ExchangeUser or ExchangeJournal
                    Default: ExchangeUser

                kwargs              (dict)  --  Optional parameters for creating a plan
                    Accepted Values:
                        retain_msgs_received_time           (int)   -- Retain messages based on received time
                        retain_msgs_deletion_time           (int)   -- Retain messages based on deletion time
                        enable_cleanup_archive_mailbox      (bool)  -- Enable cleanup on archive mailbox
                        cleanup_msg_older_than              (int)   -- Cleanup messages older than
                        cleanup_msg_larger_than             (int)   -- Cleanup messages larger than
                        enable_content_search               (bool)  -- Enable content indexing
                        enable_archive_on_archive_mailbox   (bool)  -- Enable archive on archived mailbox
                        create_stubs                        (bool)  -- Create stubs during cleanup
                        prune_stubs                         (bool)  -- Prune stubs during cleanup
                        prune_msgs                          (bool)  -- Prune messages during cleanup
                        number_of_days_src_pruning          (int)   -- Number of days for source pruning
                        include_msgs_older_than             (int)   -- Include messages older than for archiving
                        include_msgs_larger_than            (int)   -- Inlcude messages larger than for archiving
                        exclude_folder_filter               (list)  -- Exclude folder filter
                        include_folder_filter               (list)  -- Include folder filter
                        enable_message_rules                (bool)  -- Enable message rules
                        truncate_body                       (bool)  -- Truncate body
                        truncate_body_to_size               (int)   -- Size to which body should be truncated (default: 1024)

            Returns:
                Plan object of the created plan

            Raises:
                SDKException:
                    if input parameters are incorrect

                    if Plan already exists

                    if error in creating the plan

        &#34;&#34;&#34;
        if plan_sub_type not in [&#39;ExchangeUser&#39;, &#39;ExchangeJournal&#39;]:
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;, &#34;Plan subtype should be ExchangeUser or ExchangeJournal.&#34;)
        elif self.has_plan(plan_name):
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(plan_name))
        request_json = self._get_plan_template(plan_sub_type)
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
        exch_retention = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbRetention&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;retentionPolicy&#39;]
        exch_retention[&#39;numOfDaysForMediaPruning&#39;] = kwargs.get(&#39;retain_msgs_received_time&#39;, -1)
        if plan_sub_type == &#39;ExchangeUser&#39;:
            exch_arch = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbArchiving&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;archivePolicy&#39;]
            exch_cleanup = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbCleanup&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;cleanupPolicy&#39;]
            exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsSelected&#39;].remove(&#39;Drafts&#39;)
            exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;].append(&#39;Drafts&#39;)
            if kwargs.get(&#39;enable_message_rules&#39;):
                exch_cleanup[&#39;enableMessageRules&#39;] = True
            exclude_folders = kwargs.get(&#39;exclude_folder_filter&#39;, [])
            for folder in exclude_folders:
                if folder in exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;]:
                    exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;].remove(folder)
                exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsSelected&#39;].append(folder)
            include_folders = kwargs.get(&#39;include_folder_filter&#39;, [])
            exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsSelected&#39;] = []
            for folder in include_folders:
                if folder in exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;]:
                    exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;].remove(folder)
                exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsSelected&#39;].append(folder)
            if kwargs.get(&#39;truncate_body&#39;):
                exch_cleanup[&#39;truncateBody&#39;] = True
                exch_cleanup[&#39;truncateBodyToSize&#39;] = kwargs.get(&#39;truncate_body_to_size&#39;, 1024)
            exch_cleanup[&#39;archiveMailbox&#39;] = kwargs.get(&#39;enable_cleanup_archive_mailbox&#39;, False)
            exch_cleanup[&#39;collectMsgsDaysAfter&#39;] = kwargs.get(&#39;cleanup_msg_older_than&#39;, 0)
            exch_cleanup[&#39;collectMsgsLargerThan&#39;] = kwargs.get(&#39;cleanup_msg_larger_than&#39;, 0)
            exch_cleanup[&#39;skipUnreadMsgs&#39;] = kwargs.get(&#39;skip_unread_msgs&#39;, False)
            exch_cleanup[&#39;collectMsgWithAttach&#39;] = kwargs.get(&#39;collect_msg_with_attach&#39;, False)
            exch_cleanup[&#39;createStubs&#39;] = kwargs.get(&#39;create_stubs&#39;, True)
            exch_cleanup[&#39;pruneStubs&#39;] = kwargs.get(&#39;prune_stubs&#39;, False)
            exch_cleanup[&#39;pruneMsgs&#39;] = kwargs.get(&#39;prune_msgs&#39;, False)
            exch_cleanup[&#39;numOfDaysForSourcePruning&#39;] = kwargs.get(&#39;number_of_days_src_pruning&#39;, 0)
            exch_arch[&#39;backupDeletedItemRetention&#39;] = kwargs.get(&#39;backup_deleted_item_retention&#39;, False)
            if &#39;includeDiscoveryHoldsFolder&#39; in kwargs:
                exch_arch[&#39;includeDiscoveryHoldsFolder&#39;] = kwargs.get(&#39;include_discovery_holds_folder&#39;)
            if &#39;includePurgesFolder&#39; in kwargs:
                exch_arch[&#39;includePurgesFolder&#39;] = kwargs.get(&#39;include_purges_folder&#39;)
            if &#39;includeVersionsFolder&#39; in kwargs:
                exch_arch[&#39;includeVersionsFolder&#39;] = kwargs.get(&#39;include_versions_folder&#39;)
            exch_arch[&#39;includeOnlyMsgsWithAttachemts&#39;] = kwargs.get(&#39;include_only_msgs_with_attachemts&#39;, False)
            exch_arch[&#39;includeMsgsOlderThan&#39;] = kwargs.get(&#39;include_msgs_older_than&#39;, 0)
            exch_arch[&#39;includeMsgsLargerThan&#39;] = kwargs.get(&#39;include_msgs_larger_than&#39;, 0)
            exch_arch[&#39;archiveMailbox&#39;] = kwargs.get(&#39;enable_archive_on_archive_mailbox&#39;, False)
            if &#39;retain_msgs_deletion_time&#39; in kwargs and kwargs.get(&#39;retain_msgs_deletion_time&#39;) &gt; 0:
                exch_retention[&#39;type&#39;] = 1
                exch_retention[&#39;numOfDaysForMediaPruning&#39;] = kwargs.get(&#39;retain_msgs_deletion_time&#39;, 0)
        else:
            exch_arch = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbJournal&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;journalPolicy&#39;]
        exch_arch[&#39;contentIndexProps&#39;][&#39;enableContentIndex&#39;] = kwargs.get(&#39;enable_content_search&#39;, False)

        headers = self._commcell_object._headers.copy()
        headers[&#39;LookupNames&#39;] = &#39;False&#39;

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._PLANS, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = None

                if &#39;errors&#39; in response_value:
                    error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                if error_code &gt; 1:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                    self.refresh()
                    self._commcell_object.storage_policies.refresh()
                    return self.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def create_server_plan(
        self, plan_name: str, backup_destinations: Union[List[dict], dict], schedules: Union[List[dict], dict]=None, **additional_params
    ) -&gt; object:
        &#34;&#34;&#34;
            Method to create a server plan using V4 API

            Args:
                plan_name (str)             --  Name of the plan to create

                backup_destinations (list/dict)  --  List of dictionaries representing backup destinations.
                Each dictionary should contain the following keys:
                    - &#39;storage_name&#39; (str): Name of the storage.
                    - &#39;retentionPeriodDays&#39; (int): Retention days for the copy (Default: 30 days)
                    - &#39;backupDestinationName&#39; (str): Name of the copy (Default: &#39;Primary&#39;)
                    - &#39;region_name&#39; (str, optional): Name of the region
                    To create elastic plans, region_name should be specified for all the copies

                Examples:
                # specify just storage and rest use default values
                {&#34;storage_name&#34;: &#34;Backup Storage&#34;}

                # specify storage name and retention period 
                {&#34;storage_name&#34;: &#34;Backup Storage&#34;, &#34;retentionPeriodDays&#34;: 30}

                # create plan with aux copies
                [
                    {&#34;storage_name&#34;: &#34;Backup Storage 1&#34;},
                    {&#34;storage_name&#34;: &#34;Backup Storage 2&#34;, &#34;backupDestinationName&#34;: &#34;Aux Copy 1&#34;},
                ]

                # create elastic plan
                {&#34;storage_name&#34;: &#34;Backup Storage&#34;, &#34;region_name&#34;: &#34;asia&#34;}

                # create elastic plan with multiple regions and multiple copies in each region
                [
                    {&#34;storage_name&#34;: &#34;Backup Storage 1&#34;, &#34;region_name&#34;: &#34;asia&#34;},
                    {&#34;storage_name&#34;: &#34;Backup Storage 2&#34;, &#34;region_name&#34;: &#34;asia&#34;, &#34;backupDestinationName&#34;: &#34;Aux Copy Name&#34;},
                    {&#34;storage_name&#34;: &#34;Backup Storage 3&#34;, &#34;region_name&#34;: &#34;africa&#34;},
                    {&#34;storage_name&#34;: &#34;Backup Storage 4&#34;, &#34;region_name&#34;: &#34;africa&#34;, &#34;backupDestinationName&#34;: &#34;Aux Copy Name&#34;}
                ]

                Note: Additional properties can be sent in the input to update the payload with the same exact key names. Refer API documentation for more details or use Command Center equivalent API.
                    
                schedules (list or dict, optional)  --  List of dictionaries representing backup schedules.
                Each dictionary should contain the following keys:
                    - backupType (str): Type of backup schedule
                    - forDatabasesOnly (bool): Indicates if the schedule is for databases only (Default: False)
                    - Additional properties to update the default schedule details.

                Examples:

                # create plan with default schedules
                None

                # create plan with no schedules
                []

                # create plan with schedules based on backup type and rest use default values
                {&#34;backupType&#34;: &#34;INCREMENTAL&#34;}
                {&#34;backupType&#34;: &#34;FULL&#34;}
                {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;}

                # specify agents for schedules
                {&#34;backupType&#34;: &#34;INCREMENTAL&#34;, &#34;forDatabasesOnly&#34;: False}
                {&#34;backupType&#34;: &#34;FULL&#34;, &#34;forDatabasesOnly&#34;: True}

                # create plan with multiple schedules
                [
                    {&#34;backupType&#34;: &#34;INCREMENTAL&#34;},
                    {&#34;backupType&#34;: &#34;FULL&#34;, &#34;forDatabasesOnly&#34;: True},
                    {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;}
                ]

                # advance properties for schedules
                {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;, &#34;scheduleOption&#34;: {&#34;useDiskCacheForLogBackups&#34;: True}}

                # specify pattern and start time for schedule
                {
                    &#34;backupType&#34;: &#34;INCREMENTAL&#34;,
                    &#34;schedulePattern&#34;: {
                        &#34;scheduleFrequencyType&#34;: &#34;DAILY&#34;,
                        &#34;startTime&#34;: 75600,
                        &#34;frequency&#34;: 1
                    }
                }

                Note: Additional properties can be sent in the input to update the payload with the same exact key names. Refer API documentation for more details or use Command Center equivalent API.
                    
                additional_params (dict)    --  Additional parameters for creating a plan
                    Accepted Values:
                        rpo_backup_window (list, optional): Backup window for RPO schedules.
                        full_backup_window (list, optional): Backup window for full backup schedules.
                        enable_backup_copy (bool, optional): Enable backup copy.
                        backup_copy_rpo_mins (int, optional): RPO for backup copy in minutes.
                        snap_retention_days (int, optional): Retention period in days.
                        snap_recovery_points (int, optional): Snap recovery point.
                        gcm_options (dict, optional): Global Configuration Manager options
                            commcells (list): List of commcell IDs to apply the plan (If not specified, applies to all commcells)

                        For Global Plans, backup_destinations input should be in the following format:

                        Example #1: For Single Copy
                            backup_destinations = {
                                &#34;storageTemplateTags&#34;: [
                                    {
                                        &#34;name&#34;: &#34;Tag Name&#34;,
                                        &#34;value&#34;: &#34;Tag Value&#34;
                                    }
                                ]
                            }

                        Example #2: For Multiple Copies
                        backup_destinations = [
                            {
                                &#39;storageTemplateTags&#39;: [
                                    {
                                        &#39;name&#39;: &#39;Tag Name 1&#39;, 
                                        &#39;value&#39;: &#39;Tag Value 1&#39;
                                    }
                                ]
                            }, 
                            {
                                &#39;backupDestinationName&#39;: &#39;Aux Copy Name&#39;, 
                                &#39;storageTemplateTags&#39;: [
                                    {
                                        &#39;name&#39;: &#39;Tag Name 2&#39;, 
                                        &#39;value&#39;: &#39;Tag Value 2&#39;
                                    }
                                ]
                            }
                        ]

        &#34;&#34;&#34;
        if schedules is None:
            schedules = [
                {&#39;backupType&#39;: &#39;INCREMENTAL&#39;},
                {&#39;backupType&#39;: &#39;TRANSACTIONLOG&#39;},
            ] # default schedules

        if isinstance(backup_destinations, dict):
            backup_destinations = [backup_destinations]

        if isinstance(schedules, dict):
            schedules = [schedules]

        request_json = _PayloadGeneratorPlanV4(self._commcell_object).get_create_server_plan_payload(
            plan_name, backup_destinations, schedules, **additional_params
        )

        if gcm_options := additional_params.get(&#39;gcm_options&#39;):
            service_commcell_ids = gcm_options.get(&#39;commcells&#39;, [])  # [{&#39;id&#39;: 1}, {&#39;id&#39;: 2}]
            apply_on_all_commcells = False if service_commcell_ids else True
            request_json = {
            &#34;globalConfigInfo&#34;: {
                &#34;commcells&#34;: service_commcell_ids,
                &#34;scope&#34;: &#34;&#34;,
                &#34;scopeFilterQuery&#34;: &#34;&#34;,
                &#34;applyOnAllCommCells&#34;: apply_on_all_commcells
            },
            &#34;plan&#34;: request_json
            }

        endpoint = self._V4_GLOBAL_PLANS if gcm_options else self._V4_PLANS
        flag, response = self._cvpysdk_object.make_request(&#39;POST&#39;, endpoint, request_json)

        if flag:
            if response.json():
                response_value = response.json()
                if &#39;errors&#39; in response_value:
                    error_message = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorMessage&#39;)
                    error_code = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorCode&#39;, 0)
                else:
                    error_message = response_value.get(&#39;errorMessage&#39;)
                    error_code = response_value.get(&#39;errorCode&#39;, 0)

                # corner case condition
                if error_code == 587207454:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Successfully created plan {response_value[&#34;plan&#34;][&#34;name&#34;]} &#39;
                                                      f&#39;with error: {error_message}&#39;)
                if error_code != 0:
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Failed to create new V4 Server Plan\nError: &#34;{error_message}&#34;&#39;)
                
                plan_name = response_value[&#39;plan&#39;][&#39;name&#39;]

                self.refresh()
                self._commcell_object.policies.refresh()

                # refresh storage policies and schedule policies, if refreshing policies is not enough
                # self._commcell_object.storage_policies.refresh()
                # self._commcell_object.schedule_policies.refresh()

                return self.get(plan_name)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def add(self,
            plan_name,
            plan_sub_type,
            storage_pool_name=None,
            sla_in_minutes=1440,
            override_entities=None):
        &#34;&#34;&#34;Adds a new Plan to the CommCell.

        Args:
            plan_name           (str)   --  name of the new plan to add

            plan_sub_type       (str)   --  Type of plan to add

                &#34;Server&#34;    -   Server Plans

                &#34;FSServer&#34;  -   File System Plans

                &#34;Laptop&#34;    -   Laptop Plans

                &#34;ExchangeUser&#34;  -   Exchange Mailbox Plan


            storage_pool_name   (str)   --  name of the storage pool to be used for the plan

            sla_in_minutes      (int)   --  Backup SLA in hours

                default: 1440

            override_entities   (dict)  --  Specify the entities with respective
                                            inheritance values.

                default: None

                    {
                        &#39;privateEntities&#39;: [1, 4],

                        &#39;enforcedEntities&#39;: [256, 512, 1024]
                    }
                    - where,
                            privateEntities are set when respective entity overriding is required
                            enforcedEntities are set when respective entity overriding is not
                            allowed
                            left blank if overriding is optional

                    - entity IDs,
                            1    - Storage
                            4    - RPO/Schedules
                            256  - Windows content
                            512  - Unix content
                            1024 - Mac content

        Returns:
            object  -   instance of the Plan class created by this method

        Raises:
            SDKException:
                if input parameters are incorrect

                if Plan already exists

        &#34;&#34;&#34;
        if not (isinstance(plan_name, str) and
                isinstance(plan_sub_type, str)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        else:
            if self.has_plan(plan_name):
                raise SDKException(
                    &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(plan_name)
                )
        storage_pool_obj = self._commcell_object.storage_pools.get(
            storage_pool_name)
        is_dedupe = True
        if &#39;dedupDBDetailsList&#39; not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
            is_dedupe = False

        request_json = self._get_plan_template(plan_sub_type, &#34;MSP&#34;)
        if plan_sub_type == &#34;Laptop&#34;:
            del request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;accessPolicies&#39;]
            
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;rpoInMinutes&#39;] = sla_in_minutes
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name

        template_schedules = [schedule[&#39;subTask&#39;][&#39;subTaskName&#39;] for schedule in request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;]]
        if &#39;Synthetic Fulls&#39; in template_schedules:
            synth_full_index = template_schedules.index(&#39;Synthetic Fulls&#39;)
            request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][synth_full_index][&#39;options&#39;][&#39;commonOpts&#39;][
                &#39;automaticSchedulePattern&#39;].update({
                    &#39;minBackupInterval&#39;: 0,
                    &#39;maxBackupIntervalMinutes&#39;: 0,
                    &#39;minSyncInterval&#39;: 0,
                    &#39;minSyncIntervalMinutes&#39;: 0
                })
            request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][synth_full_index][&#39;options&#39;][&#39;commonOpts&#39;][
                &#39;automaticSchedulePattern&#39;][&#39;ignoreOpWindowPastMaxInterval&#39;] = True
        del request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;]
        request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
            &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
        }
        if is_dedupe:
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalDedupStore&#39;] = 1
        else:
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;enableDeduplication&#39;]
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;enableClientSideDedup&#39;]
            del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
                &#39;useGlobalStoragePolicy&#39;: 1
                }

        # Configurations for database and snap addons
        if plan_sub_type == &#34;Server&#34; and &#39;database&#39; in request_json[&#39;plan&#39;]:
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalDedupStore&#39;] = 1
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0].pop(
                &#39;DDBPartitionInfo&#39;, None
            )
            request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
                &#39;useGlobalPolicy&#39;] = {
                    &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
                }
            
            # From SP36, snap copy wont be created by default during plan creation or present in the template
            if len(request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;]) &gt; 1:
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                    &#39;useGlobalStoragePolicy&#39;: 1
                }
                request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                    &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
                }

        # Enable full backup schedule
        if plan_sub_type != &#34;Laptop&#34;:
            for subtask in request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;]:
                if &#39;flags&#39; in subtask[&#39;subTask&#39;] and subtask[&#39;subTask&#39;][&#39;flags&#39;] == 65536:
                    import copy
                    full_schedule = copy.deepcopy(subtask)
                    del copy
                    full_schedule[&#39;subTask&#39;].update({
                        &#39;subTaskName&#39;: &#39;Full backup schedule&#39;,
                        &#39;flags&#39;: 4194304
                    })
                    full_schedule[&#39;pattern&#39;].update({
                        &#39;freq_type&#39;: 4,
                        &#39;freq_interval&#39;: 1,
                        &#39;name&#39;: &#39;Full backup schedule&#39;,
                        &#39;active_end_time&#39;: 0
                    })
                    full_schedule[&#39;options&#39;][&#39;backupOpts&#39;][&#39;backupLevel&#39;] = &#39;FULL&#39;
                    request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;].append(full_schedule)
                    break

        if isinstance(override_entities, dict):
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: False
            }

            if &#39;enforcedEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = override_entities[
                    &#39;enforcedEntities&#39;]

            if &#39;privateEntities&#39; in override_entities:
                request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = override_entities[
                    &#39;privateEntities&#39;]
        else:
            request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
            request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
                &#39;isSealed&#39;: True
            }

        headers = self._commcell_object._headers.copy()
        headers[&#39;LookupNames&#39;] = &#39;False&#39;

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._PLANS, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = None

                if &#39;errors&#39; in response_value:
                    error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                if error_code &gt; 1:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                    # initialize the plans again
                    # so that the plans object has all the plans
                    self.refresh()
                    # with plan delete storage policy associated might be deleted
                    # initialize storage policy again
                    self._commcell_object.storage_policies.refresh()

                    return self.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def get_eligible_plans(self, entities):
        &#34;&#34;&#34;Returns dict of plans that are eligible for the specified entities

            Args:
                entities    (dict)  - dictionary containing entities as keys and
                                        their respective IDs as values
                    {
                        &#39;clientId&#39;: id,
                        &#39;appId&#39;: id,
                        &#39;backupsetId&#39;: id
                    }

            Returns:
                dict                - dict of eligible plans

            Raises:
                SDKException:
                    if there is an error in the response
        &#34;&#34;&#34;
        query = &#39;&#39;
        for i in entities:
            query += &#39;{0}={1}&amp;&#39;.format(i, entities[i])
        requset_url = self._services[&#39;ELIGIBLE_PLANS&#39;] % query[0:-1]
        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, requset_url)
        del query

        if flag:
            plans = {}

            if response.json() and &#39;plans&#39; in response.json():
                response_value = response.json()[&#39;plans&#39;]

                for temp in response_value:
                    temp_name = temp[&#39;plan&#39;][&#39;planName&#39;].lower()
                    temp_id = str(temp[&#39;plan&#39;][&#39;planId&#39;]).lower()
                    plans[temp_name] = temp_id

            return plans
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def get_supported_solutions(self):
        &#34;&#34;&#34;Method to get supported solutions for plans&#34;&#34;&#34;
        flag, response = self._cvpysdk_object.make_request(
            &#39;GET&#39;,
            self._services[&#39;PLAN_SUPPORTED_SOLUTIONS&#39;]
        )

        if not flag:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, self._update_response_(response.text))
        
        if response.json() and &#39;id&#39; in response.json():
            return {solution[&#39;name&#39;]: solution[&#39;id&#39;] for solution in response.json()[&#39;id&#39;]}
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        
    def refresh(self, **kwargs):
        &#34;&#34;&#34;
        Refresh the list of plans on this commcell.

            Args:
                **kwargs (dict):
                    mongodb (bool)  -- Flag to fetch plans cache from MongoDB (default: False).
                    hard (bool)     -- Flag to hard refresh MongoDB cache for this entity (default: False).
        &#34;&#34;&#34;
        mongodb = kwargs.get(&#39;mongodb&#39;, False)
        hard = kwargs.get(&#39;hard&#39;, False)

        self._plans = self._get_plans()
        if mongodb:
            self._plans_cache = self.get_plans_cache(hard=hard)

    def add_data_classification_plan(self, plan_name, index_server, target_app=TargetApps.FSO, **kwargs):
        &#34;&#34;&#34;Adds data classification plan to the commcell

            Args:

                plan_name           (str)       --  Name of plan

                index_server        (str)       --  Index server name


                target_app          (enum)      --  Target app for this plan
                                                        cvpysdk.activateapps.constants.TargetApps

                **kwargs

                    index_content       (bool)      --  Speifies whether to index content or not to index server

                    content_analyzer    (list)      --  list of Content analyzer client name

                    entity_list         (list)      --  list of entities which needs to be extracted

                    classifier_list     (list)      --  list of classifier which needs to be classified

                    enable_ocr          (bool)      --  specifies whether OCR is enabled or not

                    ocr_language        (int)       --  Language to be used when doing OCR
                                                            Default : English (Value-1)

                     Supported Languages:

                                    ENGLISH = 1,
                                    HEBREW = 2,
                                    SPANISH = 3,
                                    FRENCH = 4,
                                    ITALIAN = 5,
                                    DANISH = 6

                    include_docs        (str)       --  Include documents type separated by comma

                    exclude_path        (list)      --  List of paths which needs to be excluded

                    min_doc_size        (int)       --  Minimum document size in MB

                    max_doc_size        (int)       --  Maximum document size in MB

            Returns:

                object  - Plan object

            Raises:

                SDKException:

                        if input is not valid

                        if failed to create plan

                        if failed to find entities/classifier details

        &#34;&#34;&#34;
        extraction_policy_list = []
        if not (isinstance(plan_name, str)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        request_json = self._get_plan_template(&#34;DataClassification&#34;, &#34;MSP&#34;)
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;DC Plan Created from CvPySDK.&#34;
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
        request_json[&#39;plan&#39;][&#39;options&#39;] = {
            &#34;enableThreatAnalysis&#34;: False,
            &#34;targetApps&#34;: [
                target_app.value
            ]
        }
        if index_server is not None:
            # change to support SaaS and unification project
            index_server_client_id = self._commcell_object.index_servers.get(index_server).index_server_client_id
            request_json[&#39;plan&#39;][&#39;eDiscoveryInfo&#39;][&#39;analyticsIndexServer&#39;] = {
                &#39;clientId&#39;: index_server_client_id
            }
        if target_app.value == TargetApps.FSO.value:
            del request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;]
            request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;opType&#39;] = PlanConstants.INDEXING_ONLY_METADATA
        elif target_app.value == TargetApps.SDG.value:
            if &#39;content_analyzer&#39; in kwargs:
                # change to support SaaS and unification project
                ca_list = []
                for ca in kwargs.get(&#39;content_analyzer&#39;, []):
                    ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                    ca_list.append({
                        &#39;clientId&#39;: ca_client_id
                    })
                request_json[&#39;plan&#39;][&#39;eDiscoveryInfo&#39;][&#39;contentAnalyzerClient&#39;] = ca_list
            if &#39;entity_list&#39; not in kwargs and &#39;classifier_list&#39; not in kwargs:
                raise SDKException(&#39;Plan&#39;, &#39;104&#39;)
            activate_obj = self._commcell_object.activate
            if &#39;entity_list&#39; in kwargs or &#39;classifier_list&#39; in kwargs:
                entity_mgr_obj = activate_obj.entity_manager()
                # classifier is also an activate entity with type alone different so append this to entity list itself
                entity_list = []
                for entity in kwargs.get(&#39;entity_list&#39;, []):
                    entity_list.append(entity)
                for entity in kwargs.get(&#39;classifier_list&#39;, []):
                    entity_list.append(entity)
                for entity in entity_list:
                    entity_obj = entity_mgr_obj.get(entity)
                    extraction_policy_list.append(entity_obj.container_details)

            request_json[&#39;plan&#39;][&#39;eePolicy&#39;][&#39;policyType&#39;] = 3
            request_json[&#39;plan&#39;][&#39;eePolicy&#39;][&#39;flags&#39;] = 8
            request_json[&#39;plan&#39;][&#39;eePolicy&#39;][&#39;detail&#39;] = {
                &#34;eePolicy&#34;: {
                    &#34;copyPrecedence&#34;: 0,
                    &#34;extractionPolicyType&#34;: 6,  # container entities
                    &#34;extractionPolicy&#34;: {
                        &#34;extractionPolicyList&#34;: extraction_policy_list
                    }

                }
            }
            request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;opType&#39;] = kwargs.get(
                &#39;index_content&#39;, PlanConstants.INDEXING_ONLY_METADATA)
            if &#39;enable_ocr&#39; in kwargs:
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;enableImageExtraction&#39;] = kwargs.get(
                    &#39;enable_ocr&#39;, False)
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;ocrLanguages&#39;] = [kwargs.get(&#39;ocr_language&#39;, 1)]
            if &#39;include_docs&#39; in kwargs:
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
                    &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
            if &#39;min_doc_size&#39; in kwargs:
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
                    &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
            if &#39;max_doc_size&#39; in kwargs:
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                    &#39;maxDocSize&#39;] = kwargs.get(&#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
            if &#39;exclude_path&#39; in kwargs:
                request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                    &#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, PlanConstants.DEFAULT_EXCLUDE_LIST)

        headers = self._commcell_object._headers.copy()
        headers[&#39;LookupNames&#39;] = &#39;False&#39;

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._PLANS, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = None

                if &#39;errors&#39; in response_value:
                    error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

                if error_code &gt; 1:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]
                    # initialize the plans again
                    self.refresh()

                    return self.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def add_risk_analysis_dc_plan(self, plan_name, app_type=PlanConstants.RAPlanAppType.CLASSIFIED,
                                  content_analyzer=None, index_server=None, **kwargs):
        &#34;&#34;&#34;Adds Risk Analysis data classification plan to the commcell
            Args:
                plan_name         (str)             --  Name of plan
                app_type          (RAPlanAppType)   --  Application Type of the plan
                content_analyzer  (list)            --  list of Content analyzer client name
                index_server      (str)             --  Index server name
                **kwargs
                    entity_list     (list)          --  list of entities which needs to be extracted
                    classifier_list (list)          --  list of classifier which needs to be classified
                    index_content   (RAPlanType)    --  Specifies whether to index content or not to index server
                    enable_ocr      (bool)          --  specifies whether OCR is enabled or not
                    ocr_language    (int)           --  Language to be used when doing OCR
                                                                Default : English (Value-1)
                        Supported Languages:
                                    ENGLISH = 1,
                                    HEBREW = 2,
                                    SPANISH = 3,
                                    FRENCH = 4,
                                    ITALIAN = 5,
                                    DANISH = 6
                    include_docs        (str)       --  Include documents type separated by comma
                    exclude_path        (list)      --  List of paths which needs to be excluded
                    min_doc_size        (int)       --  Minimum document size in MB
                    max_doc_size        (int)       --  Maximum document size in MB
            Returns:
                object  - Plan object
            Raises:
                SDKException:
                        if input is not valid
                        if failed to create plan
                        if failed to find entities/classifier details
        &#34;&#34;&#34;
        if not (isinstance(plan_name, str)):
            raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
        request_json = copy.deepcopy(PlanConstants.CREATE_V4_DC_PLAN_REQ)

        request_json[&#39;name&#39;] = plan_name
        request_json[&#39;application&#39;] = app_type.value
        request_json[&#39;threatAnalysis&#39;] = False

        if index_server is not None:
            # change to support SaaS and unification project
            index_server_client_id = self._commcell_object.index_servers.get(index_server).index_server_client_id
            request_json[&#39;indexServer&#39;] = {
                &#39;id&#39;: index_server_client_id
            }
        if content_analyzer is not None:
            # change to support SaaS and unification project
            ca_list = []
            for ca in content_analyzer:
                ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                ca_list.append({
                    &#39;id&#39;: ca_client_id
                })
            request_json[&#39;contentAnalyzer&#39;] = ca_list
        if &#39;entity_list&#39; not in kwargs and &#39;classifier_list&#39; not in kwargs:
            raise SDKException(&#39;Plan&#39;, &#39;104&#39;)
        activate_obj = self._commcell_object.activate
        if &#39;entity_list&#39; in kwargs or &#39;classifier_list&#39; in kwargs:
            entity_mgr_obj = activate_obj.entity_manager()
            entity_list = []
            classifier_list = []
            entity_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;entity_list&#39;, []))
            for entity_id in entity_ids:
                entity_list.append({&#34;id&#34;: entity_id})
            request_json[&#39;entityDetection&#39;][&#34;entities&#34;] = entity_list

            classifier_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;classifier_list&#39;, []))
            for classifier_id in classifier_ids:
                classifier_list.append({&#34;id&#34;: classifier_id})
            request_json[&#39;entityDetection&#39;][&#34;classifiers&#34;] = classifier_list
        request_json[&#39;contentIndexing&#39;][&#34;searchType&#34;] = kwargs.get(
            &#39;index_content&#39;, PlanConstants.RAPlanSearchType.SEARCH_TYPE_ONLY_METADATA).value
        request_json[&#39;contentIndexing&#39;][&#34;extractTextFromImage&#34;] = kwargs.get(&#39;enable_ocr&#39;, False)
        if &#39;enable_ocr&#39; in kwargs:
            request_json[&#39;contentIndexing&#39;][&#34;contentLanguage&#34;] = kwargs.get(&#39;ocr_language&#39;, 1)
        request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
            &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
        request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
            &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
        request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;maxDocSize&#39;] = kwargs.get(
            &#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
        request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, [])

        headers = self._commcell_object._headers.copy()

        flag, response = self._cvpysdk_object.make_request(
            &#39;POST&#39;, self._V4_DC_PLANS, request_json, headers=headers
        )

        if flag:
            if response.json():
                response_value = response.json()
                error_message = None
                error_code = 0

                if &#39;errors&#39; in response_value:
                    error_code = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorCode&#39;, 0)
                    error_message = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorMessage&#39;)

                if error_code &gt; 1:
                    o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                        error_message
                    )
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

                if &#39;plan&#39; in response_value:
                    plan_name = response_value[&#39;plan&#39;][&#39;name&#39;]
                    # initialize the plans again
                    self.refresh()

                    return self.get(plan_name)
                else:
                    o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                             &#39;Please check the documentation for &#39;
                             &#39;more details on the error&#39;).format(error_code)

                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Response&#39;, 102)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def get_plans_summary(self) -&gt; dict:

        &#34;&#34;&#34;Returns plan summary in response

        Returns:
            list - plans summary

        **NOTE - THE FUNCTION WOULD BE DEPRECATED IN SP40 AS GET_PLANS_CACHE() WILL RETURN THE SIMILAR RESPONSE**
        &#34;&#34;&#34;
        params = &#34;fl=plans.missingEntities%2Cplans.numAssocEntities%2Cplans.numCopies%2Cplans.parent&#34; \
                 &#34;%2Cplans.permissions%2Cplans.plan.planId%2Cplans.plan.planName%2Cplans.planStatusFlag%2Cplans.restrictions%2C&#34; \
                 &#34;plans.rpoInMinutes%2Cplans.subtype%2Cplans.type%2Cplans.targetApps%2Cplans.storageResourcePoolMaps.resources.resourcePool&#34; \
                 &#34;&amp;hardRefresh=true&#34;
        request_url = self._services[&#39;PLAN_SUMMARY&#39;] % params

        flags,response = self._cvpysdk_object.make_request(&#39;GET&#39;,request_url)

        if flags:
            if response.json():
                plans_summary = {entry.get(&#34;plan&#34;, {}).get(&#34;name&#34;, None): entry.get(&#34;associatedEntities&#34;, None)
                                 for entry in response.json()[&#34;plans&#34;]}
                return plans_summary
            else:
                raise SDKException(&#34;Plan&#34;, &#34;102&#34;, &#34;Failed to get plans summary&#34;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def add_office365_plan(self, plan_name)-&gt;None:
        &#34;&#34;&#34;
        Creates Office 365 plan
        Args:
            plan_name (str) : name of the plan to be created
        &#34;&#34;&#34;
        if not isinstance(plan_name, str):
            raise SDKException(&#39;Plan&#39;,&#39;102&#39;,&#39;Plan name should be passed as String&#39;)
        plan_sub_type = &#34;Office365&#34;
        plan_type = &#34;EXCHANGE&#34;
        office365_plan_template = self._get_plan_template(plan_type=plan_type,plan_sub_type=plan_sub_type)
        office365_plan_template[&#34;plan&#34;][&#34;summary&#34;][&#34;plan&#34;][&#34;planName&#34;] = plan_name
        flag, response = self._cvpysdk_object.make_request(&#34;POST&#34;, self._PLANS ,office365_plan_template)
        if flag:
            if response:
                if response.status_code == 200:
                    self.refresh()
                elif response.status_code == 400:
                    raise SDKException(&#34;Plan&#34;,&#34;102&#34;,&#34;Bad request&#34;)
                elif response.status_code == 401:
                    raise SDKException(&#34;Plan&#34;, &#34;102&#34;, &#34;User is unauthorized to perform create operation&#34;)
            else:
                raise SDKException(&#34;Plan&#34;,&#34;102&#34;,&#34;Response received is empty&#34;)
        else:
            response_string = self._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def all_plans_prop(self)-&gt;list[dict]:
        &#34;&#34;&#34;
        Returns complete GET API response
        &#34;&#34;&#34;
        self._all_plans_props = self._get_plans(full_response=True).get(&#34;plans&#34;,[])
        return self._all_plans_props</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="cvpysdk.plan.Plans.all_plans"><code class="name">var <span class="ident">all_plans</span></code></dt>
<dd>
<div class="desc"><p>Returns the dictionary consisting of all the plans added to the Commcell.</p>
<p>dict - consists of all the plans configured on the commcell</p>
<pre><code>{
    "plan1_name": plan1_id,

    "plan2_name": plan2_id
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L826-L839" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def all_plans(self):
    &#34;&#34;&#34;Returns the dictionary consisting of all the plans added to the Commcell.

        dict - consists of all the plans configured on the commcell

            {
                &#34;plan1_name&#34;: plan1_id,

                &#34;plan2_name&#34;: plan2_id
            }

    &#34;&#34;&#34;
    return self._plans</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.all_plans_cache"><code class="name">var <span class="ident">all_plans_cache</span></code></dt>
<dd>
<div class="desc"><p>Returns the dictionary consisting of all the plans cache present in mongoDB</p>
<p>dict - consists of all the plans configured on the commcell</p>
<pre><code>{
"plan1_name":
 {
 id : &lt;plan's id&gt;,
 Type : &lt;type of plan&gt;,
 subtype : &lt;sub type of plan&gt;,
 status: &lt;status of the plan&gt;,
 numCopies: &lt;number of copies&gt;,
 numAssocEntities: &lt;associated Entities Count&gt;,
 RPO: &lt;rpo in minutes&gt;,
 planStatusFlag: &lt;status of plan&gt;,
 company: &lt;name of the company plan belongs to&gt;
 },

"plan2_name":
 {
 id : &lt;plan's id&gt;,
 Type : &lt;type of plan&gt;,
 subtype : &lt;sub type of plan&gt;,
 status: &lt;status of the plan&gt;,
 numCopies: &lt;number of copies&gt;,
 numAssocEntities: &lt;associated Entities Count&gt;,
 RPO: &lt;rpo in minutes&gt;,
 planStatusFlag: &lt;status of plan&gt;,
 company: &lt;name of the company plan belongs to&gt;
 },
</code></pre>
<p>}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L841-L878" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def all_plans_cache(self):
    &#34;&#34;&#34;Returns the dictionary consisting of all the plans cache present in mongoDB

                dict - consists of all the plans configured on the commcell

                    {
                    &#34;plan1_name&#34;:
                     {
                     id : &lt;plan&#39;s id&gt;,
                     Type : &lt;type of plan&gt;,
                     subtype : &lt;sub type of plan&gt;,
                     status: &lt;status of the plan&gt;,
                     numCopies: &lt;number of copies&gt;,
                     numAssocEntities: &lt;associated Entities Count&gt;,
                     RPO: &lt;rpo in minutes&gt;,
                     planStatusFlag: &lt;status of plan&gt;,
                     company: &lt;name of the company plan belongs to&gt;
                     },

                    &#34;plan2_name&#34;:
                     {
                     id : &lt;plan&#39;s id&gt;,
                     Type : &lt;type of plan&gt;,
                     subtype : &lt;sub type of plan&gt;,
                     status: &lt;status of the plan&gt;,
                     numCopies: &lt;number of copies&gt;,
                     numAssocEntities: &lt;associated Entities Count&gt;,
                     RPO: &lt;rpo in minutes&gt;,
                     planStatusFlag: &lt;status of plan&gt;,
                     company: &lt;name of the company plan belongs to&gt;
                     },
                }

            &#34;&#34;&#34;
    if not self._plans_cache:
        self._plans_cache = self.get_plans_cache()
    return self._plans_cache</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.all_plans_prop"><code class="name">var <span class="ident">all_plans_prop</span> :Â list[dict]</code></dt>
<dd>
<div class="desc"><p>Returns complete GET API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2037-L2043" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def all_plans_prop(self)-&gt;list[dict]:
    &#34;&#34;&#34;
    Returns complete GET API response
    &#34;&#34;&#34;
    self._all_plans_props = self._get_plans(full_response=True).get(&#34;plans&#34;,[])
    return self._all_plans_props</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cvpysdk.plan.Plans.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, plan_name, plan_sub_type, storage_pool_name=None, sla_in_minutes=1440, override_entities=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new Plan to the CommCell.</p>
<h2 id="args">Args</h2>
<p>plan_name
(str)
&ndash;
name of the new plan to add</p>
<p>plan_sub_type
(str)
&ndash;
Type of plan to add</p>
<pre><code>"Server"    -   Server Plans

"FSServer"  -   File System Plans

"Laptop"    -   Laptop Plans

"ExchangeUser"  -   Exchange Mailbox Plan
</code></pre>
<p>storage_pool_name
(str)
&ndash;
name of the storage pool to be used for the plan</p>
<p>sla_in_minutes
(int)
&ndash;
Backup SLA in hours</p>
<pre><code>default: 1440
</code></pre>
<p>override_entities
(dict)
&ndash;
Specify the entities with respective
inheritance values.</p>
<pre><code>default: None

    {
        'privateEntities': [1, 4],

        'enforcedEntities': [256, 512, 1024]
    }
    - where,
            privateEntities are set when respective entity overriding is required
            enforcedEntities are set when respective entity overriding is not
            allowed
            left blank if overriding is optional

    - entity IDs,
            1    - Storage
            4    - RPO/Schedules
            256  - Windows content
            512  - Unix content
            1024 - Mac content
</code></pre>
<h2 id="returns">Returns</h2>
<p>object
-
instance of the Plan class created by this method</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if input parameters are incorrect</p>
<pre><code>if Plan already exists
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L1385-L1603" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add(self,
        plan_name,
        plan_sub_type,
        storage_pool_name=None,
        sla_in_minutes=1440,
        override_entities=None):
    &#34;&#34;&#34;Adds a new Plan to the CommCell.

    Args:
        plan_name           (str)   --  name of the new plan to add

        plan_sub_type       (str)   --  Type of plan to add

            &#34;Server&#34;    -   Server Plans

            &#34;FSServer&#34;  -   File System Plans

            &#34;Laptop&#34;    -   Laptop Plans

            &#34;ExchangeUser&#34;  -   Exchange Mailbox Plan


        storage_pool_name   (str)   --  name of the storage pool to be used for the plan

        sla_in_minutes      (int)   --  Backup SLA in hours

            default: 1440

        override_entities   (dict)  --  Specify the entities with respective
                                        inheritance values.

            default: None

                {
                    &#39;privateEntities&#39;: [1, 4],

                    &#39;enforcedEntities&#39;: [256, 512, 1024]
                }
                - where,
                        privateEntities are set when respective entity overriding is required
                        enforcedEntities are set when respective entity overriding is not
                        allowed
                        left blank if overriding is optional

                - entity IDs,
                        1    - Storage
                        4    - RPO/Schedules
                        256  - Windows content
                        512  - Unix content
                        1024 - Mac content

    Returns:
        object  -   instance of the Plan class created by this method

    Raises:
        SDKException:
            if input parameters are incorrect

            if Plan already exists

    &#34;&#34;&#34;
    if not (isinstance(plan_name, str) and
            isinstance(plan_sub_type, str)):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    else:
        if self.has_plan(plan_name):
            raise SDKException(
                &#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(plan_name)
            )
    storage_pool_obj = self._commcell_object.storage_pools.get(
        storage_pool_name)
    is_dedupe = True
    if &#39;dedupDBDetailsList&#39; not in storage_pool_obj._storage_pool_properties[&#39;storagePoolDetails&#39;]:
        is_dedupe = False

    request_json = self._get_plan_template(plan_sub_type, &#34;MSP&#34;)
    if plan_sub_type == &#34;Laptop&#34;:
        del request_json[&#39;plan&#39;][&#39;laptop&#39;][&#39;accessPolicies&#39;]
        
    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;rpoInMinutes&#39;] = sla_in_minutes
    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;Created from CvPySDK.&#34;
    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name

    template_schedules = [schedule[&#39;subTask&#39;][&#39;subTaskName&#39;] for schedule in request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;]]
    if &#39;Synthetic Fulls&#39; in template_schedules:
        synth_full_index = template_schedules.index(&#39;Synthetic Fulls&#39;)
        request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][synth_full_index][&#39;options&#39;][&#39;commonOpts&#39;][
            &#39;automaticSchedulePattern&#39;].update({
                &#39;minBackupInterval&#39;: 0,
                &#39;maxBackupIntervalMinutes&#39;: 0,
                &#39;minSyncInterval&#39;: 0,
                &#39;minSyncIntervalMinutes&#39;: 0
            })
        request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;][synth_full_index][&#39;options&#39;][&#39;commonOpts&#39;][
            &#39;automaticSchedulePattern&#39;][&#39;ignoreOpWindowPastMaxInterval&#39;] = True
    del request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;task&#39;][&#39;taskName&#39;]
    request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;useGlobalPolicy&#39;] = {
        &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
    }
    if is_dedupe:
        request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
            &#39;useGlobalDedupStore&#39;] = 1
    else:
        del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;storagePolicyFlags&#39;]
        del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
            &#39;enableDeduplication&#39;]
        del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
            &#39;enableClientSideDedup&#39;]
        del request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;DDBPartitionInfo&#39;]
        request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][0][&#39;extendedFlags&#39;] = {
            &#39;useGlobalStoragePolicy&#39;: 1
            }

    # Configurations for database and snap addons
    if plan_sub_type == &#34;Server&#34; and &#39;database&#39; in request_json[&#39;plan&#39;]:
        request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
            &#39;useGlobalDedupStore&#39;] = 1
        request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0].pop(
            &#39;DDBPartitionInfo&#39;, None
        )
        request_json[&#39;plan&#39;][&#39;database&#39;][&#39;storageLog&#39;][&#39;copy&#39;][0][&#39;dedupeFlags&#39;][
            &#39;useGlobalPolicy&#39;] = {
                &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
            }
        
        # From SP36, snap copy wont be created by default during plan creation or present in the template
        if len(request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;]) &gt; 1:
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;extendedFlags&#39;] = {
                &#39;useGlobalStoragePolicy&#39;: 1
            }
            request_json[&#39;plan&#39;][&#39;storage&#39;][&#39;copy&#39;][1][&#39;useGlobalPolicy&#39;] = {
                &#34;storagePolicyId&#34;: int(storage_pool_obj.storage_pool_id)
            }

    # Enable full backup schedule
    if plan_sub_type != &#34;Laptop&#34;:
        for subtask in request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;]:
            if &#39;flags&#39; in subtask[&#39;subTask&#39;] and subtask[&#39;subTask&#39;][&#39;flags&#39;] == 65536:
                import copy
                full_schedule = copy.deepcopy(subtask)
                del copy
                full_schedule[&#39;subTask&#39;].update({
                    &#39;subTaskName&#39;: &#39;Full backup schedule&#39;,
                    &#39;flags&#39;: 4194304
                })
                full_schedule[&#39;pattern&#39;].update({
                    &#39;freq_type&#39;: 4,
                    &#39;freq_interval&#39;: 1,
                    &#39;name&#39;: &#39;Full backup schedule&#39;,
                    &#39;active_end_time&#39;: 0
                })
                full_schedule[&#39;options&#39;][&#39;backupOpts&#39;][&#39;backupLevel&#39;] = &#39;FULL&#39;
                request_json[&#39;plan&#39;][&#39;schedule&#39;][&#39;subTasks&#39;].append(full_schedule)
                break

    if isinstance(override_entities, dict):
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 0
        request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
            &#39;isSealed&#39;: False
        }

        if &#39;enforcedEntities&#39; in override_entities:
            request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;enforcedEntities&#39;] = override_entities[
                &#39;enforcedEntities&#39;]

        if &#39;privateEntities&#39; in override_entities:
            request_json[&#39;plan&#39;][&#39;inheritance&#39;][&#39;privateEntities&#39;] = override_entities[
                &#39;privateEntities&#39;]
    else:
        request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;restrictions&#39;] = 1
        request_json[&#39;plan&#39;][&#39;inheritance&#39;] = {
            &#39;isSealed&#39;: True
        }

    headers = self._commcell_object._headers.copy()
    headers[&#39;LookupNames&#39;] = &#39;False&#39;

    flag, response = self._cvpysdk_object.make_request(
        &#39;POST&#39;, self._PLANS, request_json, headers=headers
    )

    if flag:
        if response.json():
            response_value = response.json()
            error_message = None
            error_code = None

            if &#39;errors&#39; in response_value:
                error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

            if error_code &gt; 1:
                o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                    error_message
                )
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

            if &#39;plan&#39; in response_value:
                plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                # initialize the plans again
                # so that the plans object has all the plans
                self.refresh()
                # with plan delete storage policy associated might be deleted
                # initialize storage policy again
                self._commcell_object.storage_policies.refresh()

                return self.get(plan_name)
            else:
                o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                         &#39;Please check the documentation for &#39;
                         &#39;more details on the error&#39;).format(error_code)

                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
        else:
            raise SDKException(&#39;Response&#39;, 102)
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.add_data_classification_plan"><code class="name flex">
<span>def <span class="ident">add_data_classification_plan</span></span>(<span>self, plan_name, index_server, target_app=TargetApps.FSO, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds data classification plan to the commcell</p>
<h2 id="args">Args</h2>
<p>plan_name
(str)
&ndash;
Name of plan</p>
<p>index_server
(str)
&ndash;
Index server name</p>
<p>target_app
(enum)
&ndash;
Target app for this plan
cvpysdk.activateapps.constants.TargetApps</p>
<p>**kwargs</p>
<pre><code>index_content       (bool)      --  Speifies whether to index content or not to index server

content_analyzer    (list)      --  list of Content analyzer client name

entity_list         (list)      --  list of entities which needs to be extracted

classifier_list     (list)      --  list of classifier which needs to be classified

enable_ocr          (bool)      --  specifies whether OCR is enabled or not

ocr_language        (int)       --  Language to be used when doing OCR
                                        Default : English (Value-1)

 Supported Languages:

                ENGLISH = 1,
                HEBREW = 2,
                SPANISH = 3,
                FRENCH = 4,
                ITALIAN = 5,
                DANISH = 6

include_docs        (str)       --  Include documents type separated by comma

exclude_path        (list)      --  List of paths which needs to be excluded

min_doc_size        (int)       --  Minimum document size in MB

max_doc_size        (int)       --  Maximum document size in MB
</code></pre>
<h2 id="returns">Returns</h2>
<p>object
- Plan object</p>
<h2 id="raises">Raises</h2>
<p>SDKException:</p>
<pre><code>    if input is not valid

    if failed to create plan

    if failed to find entities/classifier details
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L1678-L1854" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_data_classification_plan(self, plan_name, index_server, target_app=TargetApps.FSO, **kwargs):
    &#34;&#34;&#34;Adds data classification plan to the commcell

        Args:

            plan_name           (str)       --  Name of plan

            index_server        (str)       --  Index server name


            target_app          (enum)      --  Target app for this plan
                                                    cvpysdk.activateapps.constants.TargetApps

            **kwargs

                index_content       (bool)      --  Speifies whether to index content or not to index server

                content_analyzer    (list)      --  list of Content analyzer client name

                entity_list         (list)      --  list of entities which needs to be extracted

                classifier_list     (list)      --  list of classifier which needs to be classified

                enable_ocr          (bool)      --  specifies whether OCR is enabled or not

                ocr_language        (int)       --  Language to be used when doing OCR
                                                        Default : English (Value-1)

                 Supported Languages:

                                ENGLISH = 1,
                                HEBREW = 2,
                                SPANISH = 3,
                                FRENCH = 4,
                                ITALIAN = 5,
                                DANISH = 6

                include_docs        (str)       --  Include documents type separated by comma

                exclude_path        (list)      --  List of paths which needs to be excluded

                min_doc_size        (int)       --  Minimum document size in MB

                max_doc_size        (int)       --  Maximum document size in MB

        Returns:

            object  - Plan object

        Raises:

            SDKException:

                    if input is not valid

                    if failed to create plan

                    if failed to find entities/classifier details

    &#34;&#34;&#34;
    extraction_policy_list = []
    if not (isinstance(plan_name, str)):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    request_json = self._get_plan_template(&#34;DataClassification&#34;, &#34;MSP&#34;)
    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;description&#39;] = &#34;DC Plan Created from CvPySDK.&#34;
    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
    request_json[&#39;plan&#39;][&#39;options&#39;] = {
        &#34;enableThreatAnalysis&#34;: False,
        &#34;targetApps&#34;: [
            target_app.value
        ]
    }
    if index_server is not None:
        # change to support SaaS and unification project
        index_server_client_id = self._commcell_object.index_servers.get(index_server).index_server_client_id
        request_json[&#39;plan&#39;][&#39;eDiscoveryInfo&#39;][&#39;analyticsIndexServer&#39;] = {
            &#39;clientId&#39;: index_server_client_id
        }
    if target_app.value == TargetApps.FSO.value:
        del request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;]
        request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;opType&#39;] = PlanConstants.INDEXING_ONLY_METADATA
    elif target_app.value == TargetApps.SDG.value:
        if &#39;content_analyzer&#39; in kwargs:
            # change to support SaaS and unification project
            ca_list = []
            for ca in kwargs.get(&#39;content_analyzer&#39;, []):
                ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
                ca_list.append({
                    &#39;clientId&#39;: ca_client_id
                })
            request_json[&#39;plan&#39;][&#39;eDiscoveryInfo&#39;][&#39;contentAnalyzerClient&#39;] = ca_list
        if &#39;entity_list&#39; not in kwargs and &#39;classifier_list&#39; not in kwargs:
            raise SDKException(&#39;Plan&#39;, &#39;104&#39;)
        activate_obj = self._commcell_object.activate
        if &#39;entity_list&#39; in kwargs or &#39;classifier_list&#39; in kwargs:
            entity_mgr_obj = activate_obj.entity_manager()
            # classifier is also an activate entity with type alone different so append this to entity list itself
            entity_list = []
            for entity in kwargs.get(&#39;entity_list&#39;, []):
                entity_list.append(entity)
            for entity in kwargs.get(&#39;classifier_list&#39;, []):
                entity_list.append(entity)
            for entity in entity_list:
                entity_obj = entity_mgr_obj.get(entity)
                extraction_policy_list.append(entity_obj.container_details)

        request_json[&#39;plan&#39;][&#39;eePolicy&#39;][&#39;policyType&#39;] = 3
        request_json[&#39;plan&#39;][&#39;eePolicy&#39;][&#39;flags&#39;] = 8
        request_json[&#39;plan&#39;][&#39;eePolicy&#39;][&#39;detail&#39;] = {
            &#34;eePolicy&#34;: {
                &#34;copyPrecedence&#34;: 0,
                &#34;extractionPolicyType&#34;: 6,  # container entities
                &#34;extractionPolicy&#34;: {
                    &#34;extractionPolicyList&#34;: extraction_policy_list
                }

            }
        }
        request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;opType&#39;] = kwargs.get(
            &#39;index_content&#39;, PlanConstants.INDEXING_ONLY_METADATA)
        if &#39;enable_ocr&#39; in kwargs:
            request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;enableImageExtraction&#39;] = kwargs.get(
                &#39;enable_ocr&#39;, False)
            request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;ocrLanguages&#39;] = [kwargs.get(&#39;ocr_language&#39;, 1)]
        if &#39;include_docs&#39; in kwargs:
            request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
                &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
        if &#39;min_doc_size&#39; in kwargs:
            request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
                &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
        if &#39;max_doc_size&#39; in kwargs:
            request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                &#39;maxDocSize&#39;] = kwargs.get(&#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
        if &#39;exclude_path&#39; in kwargs:
            request_json[&#39;plan&#39;][&#39;ciPolicy&#39;][&#39;detail&#39;][&#39;ciPolicy&#39;][&#39;filters&#39;][&#39;fileFilters&#39;][
                &#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, PlanConstants.DEFAULT_EXCLUDE_LIST)

    headers = self._commcell_object._headers.copy()
    headers[&#39;LookupNames&#39;] = &#39;False&#39;

    flag, response = self._cvpysdk_object.make_request(
        &#39;POST&#39;, self._PLANS, request_json, headers=headers
    )

    if flag:
        if response.json():
            response_value = response.json()
            error_message = None
            error_code = None

            if &#39;errors&#39; in response_value:
                error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

            if error_code &gt; 1:
                o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                    error_message
                )
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

            if &#39;plan&#39; in response_value:
                plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]
                # initialize the plans again
                self.refresh()

                return self.get(plan_name)
            else:
                o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                         &#39;Please check the documentation for &#39;
                         &#39;more details on the error&#39;).format(error_code)

                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
        else:
            raise SDKException(&#39;Response&#39;, 102)
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.add_exchange_plan"><code class="name flex">
<span>def <span class="ident">add_exchange_plan</span></span>(<span>self, plan_name:Â str, plan_sub_type:Â strÂ =Â 'ExchangeUser', **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new exchange plan to the commcell.</p>
<h2 id="args">Args</h2>
<p>plan_name
(str)
&ndash;
name of the new plan to add</p>
<p>plan_sub_type
(str)
&ndash;
Type of plan to add - ExchangeUser or ExchangeJournal
Default: ExchangeUser</p>
<p>kwargs
(dict)
&ndash;
Optional parameters for creating a plan
Accepted Values:
retain_msgs_received_time
(int)
&ndash; Retain messages based on received time
retain_msgs_deletion_time
(int)
&ndash; Retain messages based on deletion time
enable_cleanup_archive_mailbox
(bool)
&ndash; Enable cleanup on archive mailbox
cleanup_msg_older_than
(int)
&ndash; Cleanup messages older than
cleanup_msg_larger_than
(int)
&ndash; Cleanup messages larger than
enable_content_search
(bool)
&ndash; Enable content indexing
enable_archive_on_archive_mailbox
(bool)
&ndash; Enable archive on archived mailbox
create_stubs
(bool)
&ndash; Create stubs during cleanup
prune_stubs
(bool)
&ndash; Prune stubs during cleanup
prune_msgs
(bool)
&ndash; Prune messages during cleanup
number_of_days_src_pruning
(int)
&ndash; Number of days for source pruning
include_msgs_older_than
(int)
&ndash; Include messages older than for archiving
include_msgs_larger_than
(int)
&ndash; Inlcude messages larger than for archiving
exclude_folder_filter
(list)
&ndash; Exclude folder filter
include_folder_filter
(list)
&ndash; Include folder filter
enable_message_rules
(bool)
&ndash; Enable message rules
truncate_body
(bool)
&ndash; Truncate body
truncate_body_to_size
(int)
&ndash; Size to which body should be truncated (default: 1024)</p>
<h2 id="returns">Returns</h2>
<p>Plan object of the created plan</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if input parameters are incorrect</p>
<pre><code>if Plan already exists

if error in creating the plan
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L1048-L1185" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_exchange_plan(self, plan_name: str, plan_sub_type: str = &#39;ExchangeUser&#39;, **kwargs):
    &#34;&#34;&#34;Adds a new exchange plan to the commcell.

        Args:
            plan_name           (str)   --  name of the new plan to add

            plan_sub_type       (str)   --  Type of plan to add - ExchangeUser or ExchangeJournal
                Default: ExchangeUser

            kwargs              (dict)  --  Optional parameters for creating a plan
                Accepted Values:
                    retain_msgs_received_time           (int)   -- Retain messages based on received time
                    retain_msgs_deletion_time           (int)   -- Retain messages based on deletion time
                    enable_cleanup_archive_mailbox      (bool)  -- Enable cleanup on archive mailbox
                    cleanup_msg_older_than              (int)   -- Cleanup messages older than
                    cleanup_msg_larger_than             (int)   -- Cleanup messages larger than
                    enable_content_search               (bool)  -- Enable content indexing
                    enable_archive_on_archive_mailbox   (bool)  -- Enable archive on archived mailbox
                    create_stubs                        (bool)  -- Create stubs during cleanup
                    prune_stubs                         (bool)  -- Prune stubs during cleanup
                    prune_msgs                          (bool)  -- Prune messages during cleanup
                    number_of_days_src_pruning          (int)   -- Number of days for source pruning
                    include_msgs_older_than             (int)   -- Include messages older than for archiving
                    include_msgs_larger_than            (int)   -- Inlcude messages larger than for archiving
                    exclude_folder_filter               (list)  -- Exclude folder filter
                    include_folder_filter               (list)  -- Include folder filter
                    enable_message_rules                (bool)  -- Enable message rules
                    truncate_body                       (bool)  -- Truncate body
                    truncate_body_to_size               (int)   -- Size to which body should be truncated (default: 1024)

        Returns:
            Plan object of the created plan

        Raises:
            SDKException:
                if input parameters are incorrect

                if Plan already exists

                if error in creating the plan

    &#34;&#34;&#34;
    if plan_sub_type not in [&#39;ExchangeUser&#39;, &#39;ExchangeJournal&#39;]:
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;, &#34;Plan subtype should be ExchangeUser or ExchangeJournal.&#34;)
    elif self.has_plan(plan_name):
            raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Plan &#34;{0}&#34; already exists&#39;.format(plan_name))
    request_json = self._get_plan_template(plan_sub_type)
    request_json[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;] = plan_name
    exch_retention = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbRetention&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;retentionPolicy&#39;]
    exch_retention[&#39;numOfDaysForMediaPruning&#39;] = kwargs.get(&#39;retain_msgs_received_time&#39;, -1)
    if plan_sub_type == &#39;ExchangeUser&#39;:
        exch_arch = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbArchiving&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;archivePolicy&#39;]
        exch_cleanup = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbCleanup&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;cleanupPolicy&#39;]
        exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsSelected&#39;].remove(&#39;Drafts&#39;)
        exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;].append(&#39;Drafts&#39;)
        if kwargs.get(&#39;enable_message_rules&#39;):
            exch_cleanup[&#39;enableMessageRules&#39;] = True
        exclude_folders = kwargs.get(&#39;exclude_folder_filter&#39;, [])
        for folder in exclude_folders:
            if folder in exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;]:
                exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;].remove(folder)
            exch_cleanup[&#39;excludeFolderFilter&#39;][&#39;folderPatternsSelected&#39;].append(folder)
        include_folders = kwargs.get(&#39;include_folder_filter&#39;, [])
        exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsSelected&#39;] = []
        for folder in include_folders:
            if folder in exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;]:
                exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsAvailable&#39;].remove(folder)
            exch_cleanup[&#39;includeFolderFilter&#39;][&#39;folderPatternsSelected&#39;].append(folder)
        if kwargs.get(&#39;truncate_body&#39;):
            exch_cleanup[&#39;truncateBody&#39;] = True
            exch_cleanup[&#39;truncateBodyToSize&#39;] = kwargs.get(&#39;truncate_body_to_size&#39;, 1024)
        exch_cleanup[&#39;archiveMailbox&#39;] = kwargs.get(&#39;enable_cleanup_archive_mailbox&#39;, False)
        exch_cleanup[&#39;collectMsgsDaysAfter&#39;] = kwargs.get(&#39;cleanup_msg_older_than&#39;, 0)
        exch_cleanup[&#39;collectMsgsLargerThan&#39;] = kwargs.get(&#39;cleanup_msg_larger_than&#39;, 0)
        exch_cleanup[&#39;skipUnreadMsgs&#39;] = kwargs.get(&#39;skip_unread_msgs&#39;, False)
        exch_cleanup[&#39;collectMsgWithAttach&#39;] = kwargs.get(&#39;collect_msg_with_attach&#39;, False)
        exch_cleanup[&#39;createStubs&#39;] = kwargs.get(&#39;create_stubs&#39;, True)
        exch_cleanup[&#39;pruneStubs&#39;] = kwargs.get(&#39;prune_stubs&#39;, False)
        exch_cleanup[&#39;pruneMsgs&#39;] = kwargs.get(&#39;prune_msgs&#39;, False)
        exch_cleanup[&#39;numOfDaysForSourcePruning&#39;] = kwargs.get(&#39;number_of_days_src_pruning&#39;, 0)
        exch_arch[&#39;backupDeletedItemRetention&#39;] = kwargs.get(&#39;backup_deleted_item_retention&#39;, False)
        if &#39;includeDiscoveryHoldsFolder&#39; in kwargs:
            exch_arch[&#39;includeDiscoveryHoldsFolder&#39;] = kwargs.get(&#39;include_discovery_holds_folder&#39;)
        if &#39;includePurgesFolder&#39; in kwargs:
            exch_arch[&#39;includePurgesFolder&#39;] = kwargs.get(&#39;include_purges_folder&#39;)
        if &#39;includeVersionsFolder&#39; in kwargs:
            exch_arch[&#39;includeVersionsFolder&#39;] = kwargs.get(&#39;include_versions_folder&#39;)
        exch_arch[&#39;includeOnlyMsgsWithAttachemts&#39;] = kwargs.get(&#39;include_only_msgs_with_attachemts&#39;, False)
        exch_arch[&#39;includeMsgsOlderThan&#39;] = kwargs.get(&#39;include_msgs_older_than&#39;, 0)
        exch_arch[&#39;includeMsgsLargerThan&#39;] = kwargs.get(&#39;include_msgs_larger_than&#39;, 0)
        exch_arch[&#39;archiveMailbox&#39;] = kwargs.get(&#39;enable_archive_on_archive_mailbox&#39;, False)
        if &#39;retain_msgs_deletion_time&#39; in kwargs and kwargs.get(&#39;retain_msgs_deletion_time&#39;) &gt; 0:
            exch_retention[&#39;type&#39;] = 1
            exch_retention[&#39;numOfDaysForMediaPruning&#39;] = kwargs.get(&#39;retain_msgs_deletion_time&#39;, 0)
    else:
        exch_arch = request_json[&#39;plan&#39;][&#39;exchange&#39;][&#39;mbJournal&#39;][&#39;detail&#39;][&#39;emailPolicy&#39;][&#39;journalPolicy&#39;]
    exch_arch[&#39;contentIndexProps&#39;][&#39;enableContentIndex&#39;] = kwargs.get(&#39;enable_content_search&#39;, False)

    headers = self._commcell_object._headers.copy()
    headers[&#39;LookupNames&#39;] = &#39;False&#39;

    flag, response = self._cvpysdk_object.make_request(
        &#39;POST&#39;, self._PLANS, request_json, headers=headers
    )

    if flag:
        if response.json():
            response_value = response.json()
            error_message = None
            error_code = None

            if &#39;errors&#39; in response_value:
                error_code = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                error_message = response_value[&#39;errors&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]

            if error_code &gt; 1:
                o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                    error_message
                )
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

            if &#39;plan&#39; in response_value:
                plan_name = response_value[&#39;plan&#39;][&#39;summary&#39;][&#39;plan&#39;][&#39;planName&#39;]

                self.refresh()
                self._commcell_object.storage_policies.refresh()
                return self.get(plan_name)
            else:
                o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                         &#39;Please check the documentation for &#39;
                         &#39;more details on the error&#39;).format(error_code)

                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
        else:
            raise SDKException(&#39;Response&#39;, 102)
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.add_office365_plan"><code class="name flex">
<span>def <span class="ident">add_office365_plan</span></span>(<span>self, plan_name) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Creates Office 365 plan</p>
<h2 id="args">Args</h2>
<p>plan_name (str) : name of the plan to be created</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L2010-L2035" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_office365_plan(self, plan_name)-&gt;None:
    &#34;&#34;&#34;
    Creates Office 365 plan
    Args:
        plan_name (str) : name of the plan to be created
    &#34;&#34;&#34;
    if not isinstance(plan_name, str):
        raise SDKException(&#39;Plan&#39;,&#39;102&#39;,&#39;Plan name should be passed as String&#39;)
    plan_sub_type = &#34;Office365&#34;
    plan_type = &#34;EXCHANGE&#34;
    office365_plan_template = self._get_plan_template(plan_type=plan_type,plan_sub_type=plan_sub_type)
    office365_plan_template[&#34;plan&#34;][&#34;summary&#34;][&#34;plan&#34;][&#34;planName&#34;] = plan_name
    flag, response = self._cvpysdk_object.make_request(&#34;POST&#34;, self._PLANS ,office365_plan_template)
    if flag:
        if response:
            if response.status_code == 200:
                self.refresh()
            elif response.status_code == 400:
                raise SDKException(&#34;Plan&#34;,&#34;102&#34;,&#34;Bad request&#34;)
            elif response.status_code == 401:
                raise SDKException(&#34;Plan&#34;, &#34;102&#34;, &#34;User is unauthorized to perform create operation&#34;)
        else:
            raise SDKException(&#34;Plan&#34;,&#34;102&#34;,&#34;Response received is empty&#34;)
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.add_risk_analysis_dc_plan"><code class="name flex">
<span>def <span class="ident">add_risk_analysis_dc_plan</span></span>(<span>self, plan_name, app_type=RAPlanAppType.CLASSIFIED, content_analyzer=None, index_server=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds Risk Analysis data classification plan to the commcell</p>
<h2 id="args">Args</h2>
<p>plan_name
(str)
&ndash;
Name of plan
app_type
(RAPlanAppType)
&ndash;
Application Type of the plan
content_analyzer
(list)
&ndash;
list of Content analyzer client name
index_server
(str)
&ndash;
Index server name
**kwargs
entity_list
(list)
&ndash;
list of entities which needs to be extracted
classifier_list (list)
&ndash;
list of classifier which needs to be classified
index_content
(RAPlanType)
&ndash;
Specifies whether to index content or not to index server
enable_ocr
(bool)
&ndash;
specifies whether OCR is enabled or not
ocr_language
(int)
&ndash;
Language to be used when doing OCR
Default : English (Value-1)
Supported Languages:
ENGLISH = 1,
HEBREW = 2,
SPANISH = 3,
FRENCH = 4,
ITALIAN = 5,
DANISH = 6
include_docs
(str)
&ndash;
Include documents type separated by comma
exclude_path
(list)
&ndash;
List of paths which needs to be excluded
min_doc_size
(int)
&ndash;
Minimum document size in MB
max_doc_size
(int)
&ndash;
Maximum document size in MB</p>
<h2 id="returns">Returns</h2>
<p>object
- Plan object</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if input is not valid
if failed to create plan
if failed to find entities/classifier details</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L1856-L1980" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_risk_analysis_dc_plan(self, plan_name, app_type=PlanConstants.RAPlanAppType.CLASSIFIED,
                              content_analyzer=None, index_server=None, **kwargs):
    &#34;&#34;&#34;Adds Risk Analysis data classification plan to the commcell
        Args:
            plan_name         (str)             --  Name of plan
            app_type          (RAPlanAppType)   --  Application Type of the plan
            content_analyzer  (list)            --  list of Content analyzer client name
            index_server      (str)             --  Index server name
            **kwargs
                entity_list     (list)          --  list of entities which needs to be extracted
                classifier_list (list)          --  list of classifier which needs to be classified
                index_content   (RAPlanType)    --  Specifies whether to index content or not to index server
                enable_ocr      (bool)          --  specifies whether OCR is enabled or not
                ocr_language    (int)           --  Language to be used when doing OCR
                                                            Default : English (Value-1)
                    Supported Languages:
                                ENGLISH = 1,
                                HEBREW = 2,
                                SPANISH = 3,
                                FRENCH = 4,
                                ITALIAN = 5,
                                DANISH = 6
                include_docs        (str)       --  Include documents type separated by comma
                exclude_path        (list)      --  List of paths which needs to be excluded
                min_doc_size        (int)       --  Minimum document size in MB
                max_doc_size        (int)       --  Maximum document size in MB
        Returns:
            object  - Plan object
        Raises:
            SDKException:
                    if input is not valid
                    if failed to create plan
                    if failed to find entities/classifier details
    &#34;&#34;&#34;
    if not (isinstance(plan_name, str)):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    request_json = copy.deepcopy(PlanConstants.CREATE_V4_DC_PLAN_REQ)

    request_json[&#39;name&#39;] = plan_name
    request_json[&#39;application&#39;] = app_type.value
    request_json[&#39;threatAnalysis&#39;] = False

    if index_server is not None:
        # change to support SaaS and unification project
        index_server_client_id = self._commcell_object.index_servers.get(index_server).index_server_client_id
        request_json[&#39;indexServer&#39;] = {
            &#39;id&#39;: index_server_client_id
        }
    if content_analyzer is not None:
        # change to support SaaS and unification project
        ca_list = []
        for ca in content_analyzer:
            ca_client_id = self._commcell_object.content_analyzers.get(ca).client_id
            ca_list.append({
                &#39;id&#39;: ca_client_id
            })
        request_json[&#39;contentAnalyzer&#39;] = ca_list
    if &#39;entity_list&#39; not in kwargs and &#39;classifier_list&#39; not in kwargs:
        raise SDKException(&#39;Plan&#39;, &#39;104&#39;)
    activate_obj = self._commcell_object.activate
    if &#39;entity_list&#39; in kwargs or &#39;classifier_list&#39; in kwargs:
        entity_mgr_obj = activate_obj.entity_manager()
        entity_list = []
        classifier_list = []
        entity_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;entity_list&#39;, []))
        for entity_id in entity_ids:
            entity_list.append({&#34;id&#34;: entity_id})
        request_json[&#39;entityDetection&#39;][&#34;entities&#34;] = entity_list

        classifier_ids = entity_mgr_obj.get_entity_ids(kwargs.get(&#39;classifier_list&#39;, []))
        for classifier_id in classifier_ids:
            classifier_list.append({&#34;id&#34;: classifier_id})
        request_json[&#39;entityDetection&#39;][&#34;classifiers&#34;] = classifier_list
    request_json[&#39;contentIndexing&#39;][&#34;searchType&#34;] = kwargs.get(
        &#39;index_content&#39;, PlanConstants.RAPlanSearchType.SEARCH_TYPE_ONLY_METADATA).value
    request_json[&#39;contentIndexing&#39;][&#34;extractTextFromImage&#34;] = kwargs.get(&#39;enable_ocr&#39;, False)
    if &#39;enable_ocr&#39; in kwargs:
        request_json[&#39;contentIndexing&#39;][&#34;contentLanguage&#34;] = kwargs.get(&#39;ocr_language&#39;, 1)
    request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;includeDocTypes&#39;] = kwargs.get(
        &#39;include_docs&#39;, PlanConstants.DEFAULT_INCLUDE_DOC_TYPES)
    request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;minDocSize&#39;] = kwargs.get(
        &#39;min_doc_size&#39;, PlanConstants.DEFAULT_MIN_DOC_SIZE)
    request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;maxDocSize&#39;] = kwargs.get(
        &#39;max_doc_size&#39;, PlanConstants.DEFAULT_MAX_DOC_SIZE)
    request_json[&#39;contentIndexing&#39;][&#39;fileFilters&#39;][&#39;excludePaths&#39;] = kwargs.get(&#39;exclude_path&#39;, [])

    headers = self._commcell_object._headers.copy()

    flag, response = self._cvpysdk_object.make_request(
        &#39;POST&#39;, self._V4_DC_PLANS, request_json, headers=headers
    )

    if flag:
        if response.json():
            response_value = response.json()
            error_message = None
            error_code = 0

            if &#39;errors&#39; in response_value:
                error_code = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorCode&#39;, 0)
                error_message = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorMessage&#39;)

            if error_code &gt; 1:
                o_str = &#39;Failed to create new Plan\nError: &#34;{0}&#34;&#39;.format(
                    error_message
                )
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)

            if &#39;plan&#39; in response_value:
                plan_name = response_value[&#39;plan&#39;][&#39;name&#39;]
                # initialize the plans again
                self.refresh()

                return self.get(plan_name)
            else:
                o_str = (&#39;Failed to create new plan due to error code: &#34;{0}&#34;\n&#39;
                         &#39;Please check the documentation for &#39;
                         &#39;more details on the error&#39;).format(error_code)

                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
        else:
            raise SDKException(&#39;Response&#39;, 102)
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.create_server_plan"><code class="name flex">
<span>def <span class="ident">create_server_plan</span></span>(<span>self, plan_name:Â str, backup_destinations:Â Union[List[dict],Â dict], schedules:Â Union[List[dict],Â dict]Â =Â None, **additional_params) â€‘>Â object</span>
</code></dt>
<dd>
<div class="desc"><p>Method to create a server plan using V4 API</p>
<h2 id="args">Args</h2>
<p>plan_name (str)
&ndash;
Name of the plan to create</p>
<p>backup_destinations (list/dict)
&ndash;
List of dictionaries representing backup destinations.
Each dictionary should contain the following keys:
- 'storage_name' (str): Name of the storage.
- 'retentionPeriodDays' (int): Retention days for the copy (Default: 30 days)
- 'backupDestinationName' (str): Name of the copy (Default: 'Primary')
- 'region_name' (str, optional): Name of the region
To create elastic plans, region_name should be specified for all the copies</p>
<p>Examples:</p>
<h1 id="specify-just-storage-and-rest-use-default-values">specify just storage and rest use default values</h1>
<p>{"storage_name": "Backup Storage"}</p>
<h1 id="specify-storage-name-and-retention-period">specify storage name and retention period</h1>
<p>{"storage_name": "Backup Storage", "retentionPeriodDays": 30}</p>
<h1 id="create-plan-with-aux-copies">create plan with aux copies</h1>
<p>[
{"storage_name": "Backup Storage 1"},
{"storage_name": "Backup Storage 2", "backupDestinationName": "Aux Copy 1"},
]</p>
<h1 id="create-elastic-plan">create elastic plan</h1>
<p>{"storage_name": "Backup Storage", "region_name": "asia"}</p>
<h1 id="create-elastic-plan-with-multiple-regions-and-multiple-copies-in-each-region">create elastic plan with multiple regions and multiple copies in each region</h1>
<p>[
{"storage_name": "Backup Storage 1", "region_name": "asia"},
{"storage_name": "Backup Storage 2", "region_name": "asia", "backupDestinationName": "Aux Copy Name"},
{"storage_name": "Backup Storage 3", "region_name": "africa"},
{"storage_name": "Backup Storage 4", "region_name": "africa", "backupDestinationName": "Aux Copy Name"}
]</p>
<dl>
<dt><strong><code>Note</code></strong></dt>
<dd>Additional properties can be sent in the input to update the payload with the same exact key names. Refer API documentation for more details or use Command Center equivalent API.</dd>
</dl>
<p>schedules (list or dict, optional)
&ndash;
List of dictionaries representing backup schedules.
Each dictionary should contain the following keys:
- backupType (str): Type of backup schedule
- forDatabasesOnly (bool): Indicates if the schedule is for databases only (Default: False)
- Additional properties to update the default schedule details.</p>
<p>Examples:</p>
<h1 id="create-plan-with-default-schedules">create plan with default schedules</h1>
<p>None</p>
<h1 id="create-plan-with-no-schedules">create plan with no schedules</h1>
<p>[]</p>
<h1 id="create-plan-with-schedules-based-on-backup-type-and-rest-use-default-values">create plan with schedules based on backup type and rest use default values</h1>
<p _TRANSACTIONLOG_="&quot;TRANSACTIONLOG&quot;" _backupType_:="&quot;backupType&quot;:">{"backupType": "INCREMENTAL"}
{"backupType": "FULL"}</p>
<h1 id="specify-agents-for-schedules">specify agents for schedules</h1>
<p True _FULL_="&quot;FULL&quot;," _backupType_:="&quot;backupType&quot;:" _forDatabasesOnly_:="&quot;forDatabasesOnly&quot;:">{"backupType": "INCREMENTAL", "forDatabasesOnly": False}</p>
<h1 id="create-plan-with-multiple-schedules">create plan with multiple schedules</h1>
<p>[
{"backupType": "INCREMENTAL"},
{"backupType": "FULL", "forDatabasesOnly": True},
{"backupType": "TRANSACTIONLOG"}
]</p>
<h1 id="advance-properties-for-schedules">advance properties for schedules</h1>
<p>{"backupType": "TRANSACTIONLOG", "scheduleOption": {"useDiskCacheForLogBackups": True}}</p>
<h1 id="specify-pattern-and-start-time-for-schedule">specify pattern and start time for schedule</h1>
<p>{
"backupType": "INCREMENTAL",
"schedulePattern": {
"scheduleFrequencyType": "DAILY",
"startTime": 75600,
"frequency": 1
}
}</p>
<dl>
<dt><strong><code>Note</code></strong></dt>
<dd>Additional properties can be sent in the input to update the payload with the same exact key names. Refer API documentation for more details or use Command Center equivalent API.</dd>
</dl>
<p>additional_params (dict)
&ndash;
Additional parameters for creating a plan
Accepted Values:
rpo_backup_window (list, optional): Backup window for RPO schedules.
full_backup_window (list, optional): Backup window for full backup schedules.
enable_backup_copy (bool, optional): Enable backup copy.
backup_copy_rpo_mins (int, optional): RPO for backup copy in minutes.
snap_retention_days (int, optional): Retention period in days.
snap_recovery_points (int, optional): Snap recovery point.
gcm_options (dict, optional): Global Configuration Manager options
commcells (list): List of commcell IDs to apply the plan (If not specified, applies to all commcells)</p>
<pre><code>    For Global Plans, backup_destinations input should be in the following format:

    Example #1: For Single Copy
        backup_destinations = {
            "storageTemplateTags": [
                {
                    "name": "Tag Name",
                    "value": "Tag Value"
                }
            ]
        }

    Example #2: For Multiple Copies
    backup_destinations = [
        {
            'storageTemplateTags': [
                {
                    'name': 'Tag Name 1', 
                    'value': 'Tag Value 1'
                }
            ]
        }, 
        {
            'backupDestinationName': 'Aux Copy Name', 
            'storageTemplateTags': [
                {
                    'name': 'Tag Name 2', 
                    'value': 'Tag Value 2'
                }
            ]
        }
    ]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L1187-L1383" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def create_server_plan(
    self, plan_name: str, backup_destinations: Union[List[dict], dict], schedules: Union[List[dict], dict]=None, **additional_params
) -&gt; object:
    &#34;&#34;&#34;
        Method to create a server plan using V4 API

        Args:
            plan_name (str)             --  Name of the plan to create

            backup_destinations (list/dict)  --  List of dictionaries representing backup destinations.
            Each dictionary should contain the following keys:
                - &#39;storage_name&#39; (str): Name of the storage.
                - &#39;retentionPeriodDays&#39; (int): Retention days for the copy (Default: 30 days)
                - &#39;backupDestinationName&#39; (str): Name of the copy (Default: &#39;Primary&#39;)
                - &#39;region_name&#39; (str, optional): Name of the region
                To create elastic plans, region_name should be specified for all the copies

            Examples:
            # specify just storage and rest use default values
            {&#34;storage_name&#34;: &#34;Backup Storage&#34;}

            # specify storage name and retention period 
            {&#34;storage_name&#34;: &#34;Backup Storage&#34;, &#34;retentionPeriodDays&#34;: 30}

            # create plan with aux copies
            [
                {&#34;storage_name&#34;: &#34;Backup Storage 1&#34;},
                {&#34;storage_name&#34;: &#34;Backup Storage 2&#34;, &#34;backupDestinationName&#34;: &#34;Aux Copy 1&#34;},
            ]

            # create elastic plan
            {&#34;storage_name&#34;: &#34;Backup Storage&#34;, &#34;region_name&#34;: &#34;asia&#34;}

            # create elastic plan with multiple regions and multiple copies in each region
            [
                {&#34;storage_name&#34;: &#34;Backup Storage 1&#34;, &#34;region_name&#34;: &#34;asia&#34;},
                {&#34;storage_name&#34;: &#34;Backup Storage 2&#34;, &#34;region_name&#34;: &#34;asia&#34;, &#34;backupDestinationName&#34;: &#34;Aux Copy Name&#34;},
                {&#34;storage_name&#34;: &#34;Backup Storage 3&#34;, &#34;region_name&#34;: &#34;africa&#34;},
                {&#34;storage_name&#34;: &#34;Backup Storage 4&#34;, &#34;region_name&#34;: &#34;africa&#34;, &#34;backupDestinationName&#34;: &#34;Aux Copy Name&#34;}
            ]

            Note: Additional properties can be sent in the input to update the payload with the same exact key names. Refer API documentation for more details or use Command Center equivalent API.
                
            schedules (list or dict, optional)  --  List of dictionaries representing backup schedules.
            Each dictionary should contain the following keys:
                - backupType (str): Type of backup schedule
                - forDatabasesOnly (bool): Indicates if the schedule is for databases only (Default: False)
                - Additional properties to update the default schedule details.

            Examples:

            # create plan with default schedules
            None

            # create plan with no schedules
            []

            # create plan with schedules based on backup type and rest use default values
            {&#34;backupType&#34;: &#34;INCREMENTAL&#34;}
            {&#34;backupType&#34;: &#34;FULL&#34;}
            {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;}

            # specify agents for schedules
            {&#34;backupType&#34;: &#34;INCREMENTAL&#34;, &#34;forDatabasesOnly&#34;: False}
            {&#34;backupType&#34;: &#34;FULL&#34;, &#34;forDatabasesOnly&#34;: True}

            # create plan with multiple schedules
            [
                {&#34;backupType&#34;: &#34;INCREMENTAL&#34;},
                {&#34;backupType&#34;: &#34;FULL&#34;, &#34;forDatabasesOnly&#34;: True},
                {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;}
            ]

            # advance properties for schedules
            {&#34;backupType&#34;: &#34;TRANSACTIONLOG&#34;, &#34;scheduleOption&#34;: {&#34;useDiskCacheForLogBackups&#34;: True}}

            # specify pattern and start time for schedule
            {
                &#34;backupType&#34;: &#34;INCREMENTAL&#34;,
                &#34;schedulePattern&#34;: {
                    &#34;scheduleFrequencyType&#34;: &#34;DAILY&#34;,
                    &#34;startTime&#34;: 75600,
                    &#34;frequency&#34;: 1
                }
            }

            Note: Additional properties can be sent in the input to update the payload with the same exact key names. Refer API documentation for more details or use Command Center equivalent API.
                
            additional_params (dict)    --  Additional parameters for creating a plan
                Accepted Values:
                    rpo_backup_window (list, optional): Backup window for RPO schedules.
                    full_backup_window (list, optional): Backup window for full backup schedules.
                    enable_backup_copy (bool, optional): Enable backup copy.
                    backup_copy_rpo_mins (int, optional): RPO for backup copy in minutes.
                    snap_retention_days (int, optional): Retention period in days.
                    snap_recovery_points (int, optional): Snap recovery point.
                    gcm_options (dict, optional): Global Configuration Manager options
                        commcells (list): List of commcell IDs to apply the plan (If not specified, applies to all commcells)

                    For Global Plans, backup_destinations input should be in the following format:

                    Example #1: For Single Copy
                        backup_destinations = {
                            &#34;storageTemplateTags&#34;: [
                                {
                                    &#34;name&#34;: &#34;Tag Name&#34;,
                                    &#34;value&#34;: &#34;Tag Value&#34;
                                }
                            ]
                        }

                    Example #2: For Multiple Copies
                    backup_destinations = [
                        {
                            &#39;storageTemplateTags&#39;: [
                                {
                                    &#39;name&#39;: &#39;Tag Name 1&#39;, 
                                    &#39;value&#39;: &#39;Tag Value 1&#39;
                                }
                            ]
                        }, 
                        {
                            &#39;backupDestinationName&#39;: &#39;Aux Copy Name&#39;, 
                            &#39;storageTemplateTags&#39;: [
                                {
                                    &#39;name&#39;: &#39;Tag Name 2&#39;, 
                                    &#39;value&#39;: &#39;Tag Value 2&#39;
                                }
                            ]
                        }
                    ]

    &#34;&#34;&#34;
    if schedules is None:
        schedules = [
            {&#39;backupType&#39;: &#39;INCREMENTAL&#39;},
            {&#39;backupType&#39;: &#39;TRANSACTIONLOG&#39;},
        ] # default schedules

    if isinstance(backup_destinations, dict):
        backup_destinations = [backup_destinations]

    if isinstance(schedules, dict):
        schedules = [schedules]

    request_json = _PayloadGeneratorPlanV4(self._commcell_object).get_create_server_plan_payload(
        plan_name, backup_destinations, schedules, **additional_params
    )

    if gcm_options := additional_params.get(&#39;gcm_options&#39;):
        service_commcell_ids = gcm_options.get(&#39;commcells&#39;, [])  # [{&#39;id&#39;: 1}, {&#39;id&#39;: 2}]
        apply_on_all_commcells = False if service_commcell_ids else True
        request_json = {
        &#34;globalConfigInfo&#34;: {
            &#34;commcells&#34;: service_commcell_ids,
            &#34;scope&#34;: &#34;&#34;,
            &#34;scopeFilterQuery&#34;: &#34;&#34;,
            &#34;applyOnAllCommCells&#34;: apply_on_all_commcells
        },
        &#34;plan&#34;: request_json
        }

    endpoint = self._V4_GLOBAL_PLANS if gcm_options else self._V4_PLANS
    flag, response = self._cvpysdk_object.make_request(&#39;POST&#39;, endpoint, request_json)

    if flag:
        if response.json():
            response_value = response.json()
            if &#39;errors&#39; in response_value:
                error_message = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorMessage&#39;)
                error_code = response_value.get(&#39;errors&#39;, [{}])[0].get(&#39;errorCode&#39;, 0)
            else:
                error_message = response_value.get(&#39;errorMessage&#39;)
                error_code = response_value.get(&#39;errorCode&#39;, 0)

            # corner case condition
            if error_code == 587207454:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Successfully created plan {response_value[&#34;plan&#34;][&#34;name&#34;]} &#39;
                                                  f&#39;with error: {error_message}&#39;)
            if error_code != 0:
                raise SDKException(&#39;Plan&#39;, &#39;102&#39;, f&#39;Failed to create new V4 Server Plan\nError: &#34;{error_message}&#34;&#39;)
            
            plan_name = response_value[&#39;plan&#39;][&#39;name&#39;]

            self.refresh()
            self._commcell_object.policies.refresh()

            # refresh storage policies and schedule policies, if refreshing policies is not enough
            # self._commcell_object.storage_policies.refresh()
            # self._commcell_object.schedule_policies.refresh()

            return self.get(plan_name)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, plan_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the plan from the commcell.</p>
<h2 id="args">Args</h2>
<p>plan_name (str)
&ndash;
name of the plan to remove from the commcell</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the plan name argument is not string</p>
<pre><code>if failed to delete plan

if response is empty

if response is not success

if no plan exists with the given name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L986-L1046" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delete(self, plan_name):
    &#34;&#34;&#34;Deletes the plan from the commcell.

        Args:
            plan_name (str)  --  name of the plan to remove from the commcell

        Raises:
            SDKException:
                if type of the plan name argument is not string

                if failed to delete plan

                if response is empty

                if response is not success

                if no plan exists with the given name
    &#34;&#34;&#34;
    if not isinstance(plan_name, str):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    else:
        plan_name = plan_name.lower()

        if self.has_plan(plan_name):
            plan_id = self._plans[plan_name]

            delete_plan = self._services[&#39;DELETE_PLAN&#39;] % (plan_id)

            flag, response = self._cvpysdk_object.make_request(&#39;DELETE&#39;, delete_plan)

            error_code = 0

            if flag:
                if &#39;error&#39; in response.json():
                    if isinstance(response.json()[&#39;error&#39;], list):
                        error_code = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorCode&#39;]
                    else:
                        error_code = response.json()[&#39;errorCode&#39;]

                if error_code != 0:
                    o_str = &#39;Failed to delete plan&#39;
                    if isinstance(response.json()[&#39;error&#39;], list):
                        error_message = response.json()[&#39;error&#39;][0][&#39;status&#39;][&#39;errorMessage&#39;]
                    else:
                        error_message = response.json()[&#39;errorMessage&#39;]
                    o_str += &#39;\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Plan&#39;, &#39;102&#39;, o_str)
                else:
                    # initialize the plan again
                    # so the plan object has all the plan
                    self.refresh()
                    self._commcell_object.storage_policies.refresh()
            else:
                response_string = self._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        else:
            raise SDKException(
                &#39;Plan&#39;,
                &#39;102&#39;,
                &#39;No plan exists with name: {0}&#39;.format(plan_name)
            )</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.filter_plans"><code class="name flex">
<span>def <span class="ident">filter_plans</span></span>(<span>self, plan_type, company_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the dictionary consisting of specified type and company plans.</p>
<h2 id="args">Args</h2>
<p>plan_type (str)
&ndash;
Type of plan ['DLO', 'Server', 'Laptop', 'Database', 'FSServer', 'FSIBMiVTL', 'Snap', 'VSAServer', 'VSAReplication',
'ExchangeUser', 'ExchangeJournal', 'Office365', 'Dynamics365', 'DataClassification', 'Archiver']
company_name (str)
&ndash;
To filter plans based on the company. For Commcell, company_name = 'Commcell'. Default will return all plans</p>
<h2 id="returns">Returns</h2>
<p>dict - consists of all the plans with specified types configured on the commcell
{
"plan1_name": plan1_id,
"plan2_name": plan2_id
}</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if input data type is not valid
if an invalid plan type is passed as a parameter
if failed to get the response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L880-L933" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filter_plans(self, plan_type, company_name=None):
    &#34;&#34;&#34;
    Returns the dictionary consisting of specified type and company plans.

    Args:
        plan_type (str)      --      Type of plan [&#39;DLO&#39;, &#39;Server&#39;, &#39;Laptop&#39;, &#39;Database&#39;, &#39;FSServer&#39;, &#39;FSIBMiVTL&#39;, &#39;Snap&#39;, &#39;VSAServer&#39;, &#39;VSAReplication&#39;, 
                                                    &#39;ExchangeUser&#39;, &#39;ExchangeJournal&#39;, &#39;Office365&#39;, &#39;Dynamics365&#39;, &#39;DataClassification&#39;, &#39;Archiver&#39;]
        company_name (str)    --     To filter plans based on the company. For Commcell, company_name = &#39;Commcell&#39;. Default will return all plans

    Returns:
        dict - consists of all the plans with specified types configured on the commcell
            {
                &#34;plan1_name&#34;: plan1_id,
                &#34;plan2_name&#34;: plan2_id
            }

    Raises:
        SDKException:
            if input data type is not valid
            if an invalid plan type is passed as a parameter
            if failed to get the response
    &#34;&#34;&#34;
    if not isinstance(plan_type, str):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    
    plan_type_lower = plan_type.lower()
    
    if plan_type_lower not in [&#34;dlo&#34;, &#34;server&#34;, &#34;laptop&#34;, &#34;database&#34;, &#34;fsserver&#34;, &#34;fsibmivtl&#34;, &#34;snap&#34;, 
                                &#34;vsaserver&#34;, &#34;vsareplication&#34;, &#34;exchangeuser&#34;, &#34;exchangejournal&#34;, 
                                &#34;office365&#34;, &#34;dynamics365&#34;, &#34;dataclassification&#34;, &#34;archiver&#34;]:
        raise SDKException(&#39;Plan&#39;, &#39;102&#39;, &#39;Invalid Plan Type Passed as Parameter&#39;)

    params = f&#34;fq=plans.subtype%3Ain%3A{plan_type}&amp;fl=plans.plan.planId%2Cplans.plan.planName%2Cplans.subtype%2Cplans.type&#34;

    if company_name:
        company_id = (
            self._commcell_object.organizations.get(company_name).organization_id 
            if company_name != &#39;Commcell&#39; else 0
        )
        params += f&#34;&amp;fq=companyId%3Aeq%3A{company_id}&#34;

    template_url = self._services[&#39;PLAN_SUMMARY&#39;] % params

    flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, template_url)

    if flag:
        result = dict()
        if &#39;plans&#39; in response.json():
            for plan in response.json()[&#39;plans&#39;]:
                result[plan[&#39;plan&#39;][&#39;name&#39;]] = plan[&#39;plan&#39;][&#39;id&#39;]
        return result
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, plan_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a plan object of the specified plan name.</p>
<h2 id="args">Args</h2>
<p>plan_name (str)
&ndash;
name of the plan</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Plan class for the the given plan name</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the plan name argument is not string</p>
<pre><code>if no plan exists with the given name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L954-L984" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get(self, plan_name):
    &#34;&#34;&#34;Returns a plan object of the specified plan name.

        Args:
            plan_name (str)  --  name of the plan

        Returns:
            object - instance of the Plan class for the the given plan name

        Raises:
            SDKException:
                if type of the plan name argument is not string

                if no plan exists with the given name
    &#34;&#34;&#34;
    if not isinstance(plan_name, str):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)
    else:
        plan_name = plan_name.lower()

        if self.has_plan(plan_name):
            return Plan(
                self._commcell_object,
                plan_name,
                self._plans[plan_name]
            )

        raise SDKException(
            &#39;Plan&#39;, &#39;102&#39;, &#39;No plan exists with name: {0}&#39;.format(
                plan_name)
        )</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.get_eligible_plans"><code class="name flex">
<span>def <span class="ident">get_eligible_plans</span></span>(<span>self, entities)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns dict of plans that are eligible for the specified entities</p>
<h2 id="args">Args</h2>
<p>entities
(dict)
- dictionary containing entities as keys and
their respective IDs as values
{
'clientId': id,
'appId': id,
'backupsetId': id
}</p>
<h2 id="returns">Returns</h2>
<p>dict
- dict of eligible plans</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if there is an error in the response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L1605-L1645" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_eligible_plans(self, entities):
    &#34;&#34;&#34;Returns dict of plans that are eligible for the specified entities

        Args:
            entities    (dict)  - dictionary containing entities as keys and
                                    their respective IDs as values
                {
                    &#39;clientId&#39;: id,
                    &#39;appId&#39;: id,
                    &#39;backupsetId&#39;: id
                }

        Returns:
            dict                - dict of eligible plans

        Raises:
            SDKException:
                if there is an error in the response
    &#34;&#34;&#34;
    query = &#39;&#39;
    for i in entities:
        query += &#39;{0}={1}&amp;&#39;.format(i, entities[i])
    requset_url = self._services[&#39;ELIGIBLE_PLANS&#39;] % query[0:-1]
    flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, requset_url)
    del query

    if flag:
        plans = {}

        if response.json() and &#39;plans&#39; in response.json():
            response_value = response.json()[&#39;plans&#39;]

            for temp in response_value:
                temp_name = temp[&#39;plan&#39;][&#39;planName&#39;].lower()
                temp_id = str(temp[&#39;plan&#39;][&#39;planId&#39;]).lower()
                plans[temp_name] = temp_id

        return plans
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.get_plans_cache"><code class="name flex">
<span>def <span class="ident">get_plans_cache</span></span>(<span>self, hard:Â boolÂ =Â False, **kwargs) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns plan cache in response.</p>
<h2 id="args">Args</h2>
<p>hard
(bool)
&ndash;
Flag to perform hard refresh on plans cache.
**kwargs (dict):
fl (list)
&ndash;
List of columns to return in response (default: None).
sort (list) &ndash;
Contains the name of the column on which sorting will be performed and type of sort.
Valid sort type: 1 for ascending and -1 for descending
e.g. sort = ['columnName', '1'] (default: None).
limit (list)&ndash;
Contains the start and limit parameter value.
Default ['0', '100'].
search (str)&ndash;
Contains the string to search in the commcell entity cache (default: None).
fq (list)
&ndash;
Contains the columnName, condition, and value.
e.g. fq = [['planName', 'contains', 'test'],
['numAssocEntities', 'between', '0-1']] (default: None).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary of all the properties present in response.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L743-L824" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_plans_cache(self, hard: bool = False, **kwargs) -&gt; dict:
    &#34;&#34;&#34;
    Returns plan cache in response.

    Args:
        hard  (bool)    --   Flag to perform hard refresh on plans cache.
        **kwargs (dict):
            fl (list)   --   List of columns to return in response (default: None).
            sort (list) --   Contains the name of the column on which sorting will be performed and type of sort.
                                   Valid sort type: 1 for ascending and -1 for descending
                                   e.g. sort = [&#39;columnName&#39;, &#39;1&#39;] (default: None).
            limit (list)--   Contains the start and limit parameter value.
                                    Default [&#39;0&#39;, &#39;100&#39;].
            search (str)--   Contains the string to search in the commcell entity cache (default: None).
            fq (list)   --   Contains the columnName, condition, and value.
                                    e.g. fq = [[&#39;planName&#39;, &#39;contains&#39;, &#39;test&#39;],
                                    [&#39;numAssocEntities&#39;, &#39;between&#39;, &#39;0-1&#39;]] (default: None).

    Returns:
        dict: Dictionary of all the properties present in response.
    &#34;&#34;&#34;
    # computing parameters
    fl_parameters = self._get_fl_parameters(kwargs.get(&#39;fl&#39;, None))
    fq_parameters = self._get_fq_parameters(kwargs.get(&#39;fq&#39;, None))
    limit = kwargs.get(&#39;limit&#39;, None)
    limit_parameters = f&#39;start={limit[0]}&amp;limit={limit[1]}&#39; if limit else &#39;&#39;
    hard_refresh = &#39;&amp;hardRefresh=true&#39; if hard else &#39;&#39;
    sort_parameters = self._get_sort_parameters(kwargs.get(&#39;sort&#39;, None)) if kwargs.get(&#39;sort&#39;, None) else &#39;&#39;

    # Search operation can only be performed on limited columns, so filtering out the columns on which search works
    searchable_columns = [&#34;planName&#34;,&#34;planType&#34;,&#34;planStatusFlag&#34;,&#34;companyName&#34;,&#34;description&#34;]
    search_parameter = (f&#39;&amp;search=tagName,tagValue,{&#34;,&#34;.join(self.valid_columns[col] for col in searchable_columns)}&#39;
                        f&#39;:contains:{kwargs.get(&#34;search&#34;, None)}&#39;) if kwargs.get(&#39;search&#39;, None) else &#39;&#39;

    params = [
        limit_parameters,
        sort_parameters,
        fl_parameters,
        hard_refresh,
        search_parameter,
        fq_parameters
    ]
    request_url = f&#34;{self._PLANS}?&#34; + &#34;&#34;.join(params)
    flag, response = self._cvpysdk_object.make_request(&#34;GET&#34;, request_url)

    if not flag:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    plans_summary = {}
    if response.json() and &#39;plans&#39; in response.json():
        self.filter_query_count = response.json().get(&#39;filterQueryCount&#39;,0)
        for plan in response.json()[&#39;plans&#39;]:
            name = plan.get(&#34;plan&#34;, {}).get(&#34;planName&#34;, None)
            company = plan.get(&#39;plan&#39;, {}).get(&#39;entityInfo&#39;, {}).get(&#39;companyName&#39;, None)

            plan_config = {
                &#39;planName&#39;:name,
                &#39;planId&#39;: plan.get(&#39;plan&#39;, {}).get(&#39;planId&#39;, None),
                &#39;planType&#39;: plan.get(&#39;subtype&#39;),
                &#39;description&#39;: plan.get(&#39;description&#39;),
                &#39;numCopies&#39;: plan.get(&#39;numCopies&#39;),
                &#39;numAssocEntities&#39;: plan.get(&#39;numAssocEntities&#39;),
                &#39;rpoInMinutes&#39;: plan.get(&#39;rpoInMinutes&#39;,0),
                &#39;planStatusFlag&#39;: plan.get(&#39;planStatusFlag&#39;),
                &#39;companyName&#39;: company,
                &#39;tags&#39;: (plan.get(&#39;plan&#39;) or {}).get(&#39;tags&#39;) or []
            }
            if &#39;storageResourcePoolMaps&#39; in plan and &#39;resources&#39; in plan.get(&#39;storageResourcePoolMaps&#39;, {})[0]:
                plan_config[&#39;resourcePool&#39;] = [
                    resource.get(&#39;resourcePool&#39;, {}).get(&#39;resourcePoolName&#39;)
                    for resource in plan.get(&#39;storageResourcePoolMaps&#39;, {})[0].get(&#39;resources&#39;)
                ]
            # Check if plan name already exists for a different company
            unique_name = name
            if name in plans_summary and plans_summary[name].get(&#39;companyName&#39;) != company:
                unique_name = f&#34;{name}_({company})&#34;
            plans_summary[unique_name] = plan_config

        return plans_summary
    else:
        raise SDKException(&#34;Plan&#34;, &#34;102&#34;, &#34;Failed to get plans summary&#34;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.get_plans_summary"><code class="name flex">
<span>def <span class="ident">get_plans_summary</span></span>(<span>self) â€‘>Â dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns plan summary in response</p>
<h2 id="returns">Returns</h2>
<p>list - plans summary
<strong>NOTE - THE FUNCTION WOULD BE DEPRECATED IN SP40 AS GET_PLANS_CACHE() WILL RETURN THE SIMILAR RESPONSE</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L1982-L2008" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_plans_summary(self) -&gt; dict:

    &#34;&#34;&#34;Returns plan summary in response

    Returns:
        list - plans summary

    **NOTE - THE FUNCTION WOULD BE DEPRECATED IN SP40 AS GET_PLANS_CACHE() WILL RETURN THE SIMILAR RESPONSE**
    &#34;&#34;&#34;
    params = &#34;fl=plans.missingEntities%2Cplans.numAssocEntities%2Cplans.numCopies%2Cplans.parent&#34; \
             &#34;%2Cplans.permissions%2Cplans.plan.planId%2Cplans.plan.planName%2Cplans.planStatusFlag%2Cplans.restrictions%2C&#34; \
             &#34;plans.rpoInMinutes%2Cplans.subtype%2Cplans.type%2Cplans.targetApps%2Cplans.storageResourcePoolMaps.resources.resourcePool&#34; \
             &#34;&amp;hardRefresh=true&#34;
    request_url = self._services[&#39;PLAN_SUMMARY&#39;] % params

    flags,response = self._cvpysdk_object.make_request(&#39;GET&#39;,request_url)

    if flags:
        if response.json():
            plans_summary = {entry.get(&#34;plan&#34;, {}).get(&#34;name&#34;, None): entry.get(&#34;associatedEntities&#34;, None)
                             for entry in response.json()[&#34;plans&#34;]}
            return plans_summary
        else:
            raise SDKException(&#34;Plan&#34;, &#34;102&#34;, &#34;Failed to get plans summary&#34;)
    else:
        response_string = self._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.get_supported_solutions"><code class="name flex">
<span>def <span class="ident">get_supported_solutions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to get supported solutions for plans</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L1647-L1660" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_supported_solutions(self):
    &#34;&#34;&#34;Method to get supported solutions for plans&#34;&#34;&#34;
    flag, response = self._cvpysdk_object.make_request(
        &#39;GET&#39;,
        self._services[&#39;PLAN_SUPPORTED_SOLUTIONS&#39;]
    )

    if not flag:
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, self._update_response_(response.text))
    
    if response.json() and &#39;id&#39; in response.json():
        return {solution[&#39;name&#39;]: solution[&#39;id&#39;] for solution in response.json()[&#39;id&#39;]}
    else:
        raise SDKException(&#39;Response&#39;, &#39;102&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.has_plan"><code class="name flex">
<span>def <span class="ident">has_plan</span></span>(<span>self, plan_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a plan exists in the commcell with the input plan name.</p>
<h2 id="args">Args</h2>
<p>plan_name
(str)
&ndash;
name of the plan</p>
<h2 id="returns">Returns</h2>
<p>bool
-
boolean output whether the plan exists in the commcell or not</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the plan name argument is not string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L935-L952" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_plan(self, plan_name):
    &#34;&#34;&#34;Checks if a plan exists in the commcell with the input plan name.

        Args:
            plan_name   (str)   --  name of the plan

        Returns:
            bool    -   boolean output whether the plan exists in the commcell or not

        Raises:
            SDKException:
                if type of the plan name argument is not string

    &#34;&#34;&#34;
    if not isinstance(plan_name, str):
        raise SDKException(&#39;Plan&#39;, &#39;101&#39;)

    return self._plans and plan_name.lower() in self._plans</code></pre>
</details>
</dd>
<dt id="cvpysdk.plan.Plans.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the list of plans on this commcell.</p>
<pre><code>Args:
    **kwargs (dict):
        mongodb (bool)  -- Flag to fetch plans cache from MongoDB (default: False).
        hard (bool)     -- Flag to hard refresh MongoDB cache for this entity (default: False).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/8dccc75ff7e6a20e27c0e0820ae8e40a8208806b/cvpysdk/plan.py#L1662-L1676" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def refresh(self, **kwargs):
    &#34;&#34;&#34;
    Refresh the list of plans on this commcell.

        Args:
            **kwargs (dict):
                mongodb (bool)  -- Flag to fetch plans cache from MongoDB (default: False).
                hard (bool)     -- Flag to hard refresh MongoDB cache for this entity (default: False).
    &#34;&#34;&#34;
    mongodb = kwargs.get(&#39;mongodb&#39;, False)
    hard = kwargs.get(&#39;hard&#39;, False)

    self._plans = self._get_plans()
    if mongodb:
        self._plans_cache = self.get_plans_cache(hard=hard)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GitHub home" href="https://github.com/Commvault/cvpysdk">
<img src="https://commvault.github.io/cvpysdk/logo.png" alt="" width="100%"> Commvault Python SDK
</a> <br>
<a class="homelink" title="Go to Top Level" href="https://commvault.github.io/cvpysdk/cvpysdk/index.html"> Go to Top Level </a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#plans">Plans</a><ul>
<li><a href="#attributes">Attributes</a></li>
</ul>
</li>
<li><a href="#plan">Plan</a><ul>
<li><a href="#plan-attributes">Plan Attributes</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cvpysdk" href="index.html">cvpysdk</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cvpysdk.plan.Plan" href="#cvpysdk.plan.Plan">Plan</a></code></h4>
<ul class="">
<li><code><a title="cvpysdk.plan.Plan.add_copy" href="#cvpysdk.plan.Plan.add_copy">add_copy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.add_region" href="#cvpysdk.plan.Plan.add_region">add_region</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.add_schedule" href="#cvpysdk.plan.Plan.add_schedule">add_schedule</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.add_storage_copy" href="#cvpysdk.plan.Plan.add_storage_copy">add_storage_copy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.addons" href="#cvpysdk.plan.Plan.addons">addons</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.all_copies" href="#cvpysdk.plan.Plan.all_copies">all_copies</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.applicable_solutions" href="#cvpysdk.plan.Plan.applicable_solutions">applicable_solutions</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.associate_user" href="#cvpysdk.plan.Plan.associate_user">associate_user</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.associated_entities" href="#cvpysdk.plan.Plan.associated_entities">associated_entities</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.company" href="#cvpysdk.plan.Plan.company">company</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.content_indexing" href="#cvpysdk.plan.Plan.content_indexing">content_indexing</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.content_indexing_props" href="#cvpysdk.plan.Plan.content_indexing_props">content_indexing_props</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.data_schedule_policy" href="#cvpysdk.plan.Plan.data_schedule_policy">data_schedule_policy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.delete_copy" href="#cvpysdk.plan.Plan.delete_copy">delete_copy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.delete_schedule" href="#cvpysdk.plan.Plan.delete_schedule">delete_schedule</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.derive_and_add" href="#cvpysdk.plan.Plan.derive_and_add">derive_and_add</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.disable_full_schedule" href="#cvpysdk.plan.Plan.disable_full_schedule">disable_full_schedule</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.edit_association" href="#cvpysdk.plan.Plan.edit_association">edit_association</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.edit_copy" href="#cvpysdk.plan.Plan.edit_copy">edit_copy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.edit_plan" href="#cvpysdk.plan.Plan.edit_plan">edit_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.edit_risk_analysis_dc_plan" href="#cvpysdk.plan.Plan.edit_risk_analysis_dc_plan">edit_risk_analysis_dc_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.edit_schedule" href="#cvpysdk.plan.Plan.edit_schedule">edit_schedule</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.edit_snapshot_options" href="#cvpysdk.plan.Plan.edit_snapshot_options">edit_snapshot_options</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.enable_data_aging" href="#cvpysdk.plan.Plan.enable_data_aging">enable_data_aging</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.full_operation_window" href="#cvpysdk.plan.Plan.full_operation_window">full_operation_window</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.get_plan_properties" href="#cvpysdk.plan.Plan.get_plan_properties">get_plan_properties</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.get_schedule_properties" href="#cvpysdk.plan.Plan.get_schedule_properties">get_schedule_properties</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.get_storage_copy_details" href="#cvpysdk.plan.Plan.get_storage_copy_details">get_storage_copy_details</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.get_storage_copy_id" href="#cvpysdk.plan.Plan.get_storage_copy_id">get_storage_copy_id</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.log_schedule_policy" href="#cvpysdk.plan.Plan.log_schedule_policy">log_schedule_policy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.modify_schedule" href="#cvpysdk.plan.Plan.modify_schedule">modify_schedule</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.operation_window" href="#cvpysdk.plan.Plan.operation_window">operation_window</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.override_entities" href="#cvpysdk.plan.Plan.override_entities">override_entities</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.parent_plan" href="#cvpysdk.plan.Plan.parent_plan">parent_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.plan_id" href="#cvpysdk.plan.Plan.plan_id">plan_id</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.plan_name" href="#cvpysdk.plan.Plan.plan_name">plan_name</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.plan_type" href="#cvpysdk.plan.Plan.plan_type">plan_type</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.policy_subclient_ids" href="#cvpysdk.plan.Plan.policy_subclient_ids">policy_subclient_ids</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.properties" href="#cvpysdk.plan.Plan.properties">properties</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.refresh" href="#cvpysdk.plan.Plan.refresh">refresh</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.region_id" href="#cvpysdk.plan.Plan.region_id">region_id</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.remove_region" href="#cvpysdk.plan.Plan.remove_region">remove_region</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.resources" href="#cvpysdk.plan.Plan.resources">resources</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.schedule" href="#cvpysdk.plan.Plan.schedule">schedule</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.schedule_policies" href="#cvpysdk.plan.Plan.schedule_policies">schedule_policies</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.security_associations" href="#cvpysdk.plan.Plan.security_associations">security_associations</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.share" href="#cvpysdk.plan.Plan.share">share</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.sla_in_minutes" href="#cvpysdk.plan.Plan.sla_in_minutes">sla_in_minutes</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.snap_schedule_policy" href="#cvpysdk.plan.Plan.snap_schedule_policy">snap_schedule_policy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.storage_copies" href="#cvpysdk.plan.Plan.storage_copies">storage_copies</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.storage_policy" href="#cvpysdk.plan.Plan.storage_policy">storage_policy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.subclient_policy" href="#cvpysdk.plan.Plan.subclient_policy">subclient_policy</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.subtype" href="#cvpysdk.plan.Plan.subtype">subtype</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.update_backup_content" href="#cvpysdk.plan.Plan.update_backup_content">update_backup_content</a></code></li>
<li><code><a title="cvpysdk.plan.Plan.update_security_associations" href="#cvpysdk.plan.Plan.update_security_associations">update_security_associations</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cvpysdk.plan.PlanTypes" href="#cvpysdk.plan.PlanTypes">PlanTypes</a></code></h4>
<ul class="two-column">
<li><code><a title="cvpysdk.plan.PlanTypes.ARCHIVER" href="#cvpysdk.plan.PlanTypes.ARCHIVER">ARCHIVER</a></code></li>
<li><code><a title="cvpysdk.plan.PlanTypes.Any" href="#cvpysdk.plan.PlanTypes.Any">Any</a></code></li>
<li><code><a title="cvpysdk.plan.PlanTypes.DC" href="#cvpysdk.plan.PlanTypes.DC">DC</a></code></li>
<li><code><a title="cvpysdk.plan.PlanTypes.DLO" href="#cvpysdk.plan.PlanTypes.DLO">DLO</a></code></li>
<li><code><a title="cvpysdk.plan.PlanTypes.EDISCOVERY" href="#cvpysdk.plan.PlanTypes.EDISCOVERY">EDISCOVERY</a></code></li>
<li><code><a title="cvpysdk.plan.PlanTypes.EXCHANGE" href="#cvpysdk.plan.PlanTypes.EXCHANGE">EXCHANGE</a></code></li>
<li><code><a title="cvpysdk.plan.PlanTypes.FS" href="#cvpysdk.plan.PlanTypes.FS">FS</a></code></li>
<li><code><a title="cvpysdk.plan.PlanTypes.MSP" href="#cvpysdk.plan.PlanTypes.MSP">MSP</a></code></li>
<li><code><a title="cvpysdk.plan.PlanTypes.SNAP" href="#cvpysdk.plan.PlanTypes.SNAP">SNAP</a></code></li>
<li><code><a title="cvpysdk.plan.PlanTypes.VSA" href="#cvpysdk.plan.PlanTypes.VSA">VSA</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cvpysdk.plan.Plans" href="#cvpysdk.plan.Plans">Plans</a></code></h4>
<ul class="">
<li><code><a title="cvpysdk.plan.Plans.add" href="#cvpysdk.plan.Plans.add">add</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.add_data_classification_plan" href="#cvpysdk.plan.Plans.add_data_classification_plan">add_data_classification_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.add_exchange_plan" href="#cvpysdk.plan.Plans.add_exchange_plan">add_exchange_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.add_office365_plan" href="#cvpysdk.plan.Plans.add_office365_plan">add_office365_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.add_risk_analysis_dc_plan" href="#cvpysdk.plan.Plans.add_risk_analysis_dc_plan">add_risk_analysis_dc_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.all_plans" href="#cvpysdk.plan.Plans.all_plans">all_plans</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.all_plans_cache" href="#cvpysdk.plan.Plans.all_plans_cache">all_plans_cache</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.all_plans_prop" href="#cvpysdk.plan.Plans.all_plans_prop">all_plans_prop</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.create_server_plan" href="#cvpysdk.plan.Plans.create_server_plan">create_server_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.delete" href="#cvpysdk.plan.Plans.delete">delete</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.filter_plans" href="#cvpysdk.plan.Plans.filter_plans">filter_plans</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.get" href="#cvpysdk.plan.Plans.get">get</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.get_eligible_plans" href="#cvpysdk.plan.Plans.get_eligible_plans">get_eligible_plans</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.get_plans_cache" href="#cvpysdk.plan.Plans.get_plans_cache">get_plans_cache</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.get_plans_summary" href="#cvpysdk.plan.Plans.get_plans_summary">get_plans_summary</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.get_supported_solutions" href="#cvpysdk.plan.Plans.get_supported_solutions">get_supported_solutions</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.has_plan" href="#cvpysdk.plan.Plans.has_plan">has_plan</a></code></li>
<li><code><a title="cvpysdk.plan.Plans.refresh" href="#cvpysdk.plan.Plans.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>