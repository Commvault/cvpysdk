<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cvpysdk.subclients.virtualserver.vmware API documentation</title>
<meta name="description" content="File for operating on a Virtual Server VMWare Subclient â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em;background-color:#f8f9fa}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#FE496A;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#FD0131}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" type="image/x-icon" href="https://commvault.github.io/cvpysdk/favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cvpysdk.subclients.virtualserver.vmware</code></h1>
</header>
<section id="section-intro">
<p>File for operating on a Virtual Server VMWare Subclient.</p>
<p>VMWareVirtualServerSubclient is the only class defined in this file.</p>
<p>VMWareVirtualServerSubclient:
Derived class from VirtualServerSubClient Base
class,representing a VMware Subclient,
and to perform operations on that Subclient</p>
<h2 id="vmwarevirtualserversubclient">Vmwarevirtualserversubclient</h2>
<p><strong>init</strong>(
backupset_object,
subclient_name,
subclient_id)
&ndash;
initialize object of vmware subclient class,
associated with the VirtualServer subclient</p>
<p>full_vm_restore_in_place()
&ndash;
restores the VM specified by the user to
the same location</p>
<p>full_vm_restore_out_of_place() &ndash; restores the VM specified to the provided
VMware psuedoclient vcenter via
vcenter_client</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L1-L1016" class="git-link">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

# --------------------------------------------------------------------------
# Copyright Commvault Systems, Inc.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# --------------------------------------------------------------------------

&#34;&#34;&#34;File for operating on a Virtual Server VMWare Subclient.

VMWareVirtualServerSubclient is the only class defined in this file.

VMWareVirtualServerSubclient:   Derived class from VirtualServerSubClient Base
                                class,representing a VMware Subclient,
                                and to perform operations on that Subclient

VMWareVirtualServerSubclient:

    __init__(
        backupset_object,
        subclient_name,
        subclient_id)           --  initialize object of vmware subclient class,
                                    associated with the VirtualServer subclient

    full_vm_restore_in_place()  --  restores the VM specified by the user to
                                    the same location

    full_vm_restore_out_of_place() -- restores the VM specified to the provided
                                      VMware psuedoclient vcenter via
                                      vcenter_client

&#34;&#34;&#34;

from cvpysdk.storage import RPStore
from cvpysdk.subclients.vssubclient import VirtualServerSubclient
from cvpysdk.virtualmachinepolicies import VirtualMachinePolicy
from ...exception import SDKException


class VMWareVirtualServerSubclient(VirtualServerSubclient):
    &#34;&#34;&#34;Derived class from VirtualServerSubclient Base class.
       This represents a VMWare virtual server subclient,
       and can perform restore operations on only that subclient.

    &#34;&#34;&#34;

    def __init__(self, backupset_object, subclient_name, subclient_id=None):
        &#34;&#34;&#34;Initialize the Instance object for the given Virtual Server instance.
        Args
        class_object (backupset_object, subclient_name, subclient_id)  --  instance of the
                                         backupset class, subclient name, subclient id

        &#34;&#34;&#34;

        super(VMWareVirtualServerSubclient, self).__init__(
            backupset_object, subclient_name, subclient_id)
        self.diskExtension = [&#34;.vmdk&#34;]

        self._disk_option = {
            &#39;Original&#39;: 0,
            &#39;Thick Lazy Zero&#39;: 1,
            &#39;Thin&#39;: 2,
            &#39;Thick Eager Zero&#39;: 3
        }

        self._transport_mode = {
            &#39;Auto&#39;: 0,
            &#39;SAN&#39;: 1,
            &#39;Hot Add&#39;: 2,
            &#39;NBD&#39;: 5,
            &#39;NBD SSL&#39;: 4
        }

    def add_revert_option(self, request_json, revert):
        &#34;&#34;&#34;
        Add revert in restore json

        Args:

            request_json            (dict)  :       restore dict

            revert                  (bool)  :       revert option

        Returns:
            request_json            (dict)  :       restore dict

        &#34;&#34;&#34;
        if revert:
            request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;commonOptions&#39;][&#39;revert&#39;] = True
        return request_json

    def full_vm_restore_in_place(
            self,
            vm_to_restore=None,
            overwrite=True,
            power_on=True,
            copy_precedence=0,
            disk_option=&#39;Original&#39;,
            transport_mode=&#39;Auto&#39;,
            proxy_client=None,
            to_time=0,
            **kwargs):
        &#34;&#34;&#34;Restores the FULL Virtual machine specified in the input list
            to the location same as the actual location of the VM in VCenter.

            Args:
                vm_to_restore         (list)        --  provide the VM name to restore
                                                        default: None

                overwrite             (bool)        --  overwrite the existing VM
                                                        default: True

                power_on              (bool)        --  power on the  restored VM
                                                        default: True

                copy_precedence       (int)         --  copy precedence value
                                                        default: 0

                disk_option           (str)  --  disk provisioning for the restored vm
                                                        Options for input are: &#39;Original&#39;,
                                                        &#39;Thick Lazy Zero&#39;, &#39;Thin&#39;,
                                                        &#39;Thick Eager Zero&#39;
                                                        default: Original

                transport_mode        (str)  --  transport mode to be used for
                                                        the restore.
                                                        Options for input are: &#39;Auto&#39;, &#39;SAN&#39;,
                                                        &#39;&#39;Hot Add&#39;, NBD&#39;, &#39;NBD SSL&#39;
                                                        default: Auto

                proxy_client          (str)  --  proxy client to be used for restore
                                                        default: proxy added in subclient

                to_time                 (int)       -- End time to select the job for restore
                                                        default: None

                **kwargs                         : Arbitrary keyword arguments Properties as of
                                                     full_vm_restore_in_place
                    eg:
                    media_agent         (str)   -- media agent

                    v2_details          (dict)       -- details for v2 subclient
                                                    eg: check clients.vmclient.VMClient._child_job_subclient_details

                    revert              (bool)      --  Revert option


            Returns:
                object - instance of the Job class for this restore job

            Raises:
                SDKException:
                    if inputs are not of correct type as per definition

                    if failed to initialize job

                    if response is empty

                    if response is not success

        &#34;&#34;&#34;

        restore_option = {&#34;media_agent&#34;: kwargs.get(&#34;media_agent&#34;, None), &#34;v2_details&#34;: kwargs.get(&#34;v2_details&#34;, None),
                          &#34;revert&#34;: kwargs.get(&#34;revert&#34;, False)}

        # check input parameters are correct
        if vm_to_restore and not isinstance(vm_to_restore, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        disk_option_value = self._disk_option[disk_option]
        transport_mode_value = self._transport_mode[transport_mode]

        if copy_precedence:
            restore_option[&#39;copy_precedence_applicable&#39;] = True

        if proxy_client is not None:
            restore_option[&#39;client_name&#39;] = proxy_client

        if vm_to_restore and not isinstance(vm_to_restore, list):
            vm_to_restore = [vm_to_restore]
        restore_option_copy = restore_option.copy()

        # set attr for all the option in restore xml from user inputs
        self._set_restore_inputs(
            restore_option,
            vm_to_restore=self._set_vm_to_restore(vm_to_restore),
            in_place=True,
            esx_server_name=&#34;&#34;,
            volume_level_restore=1,
            unconditional_overwrite=overwrite,
            power_on=power_on,
            disk_option=disk_option_value,
            transport_mode=transport_mode_value,
            copy_precedence=copy_precedence,
            to_time=to_time
        )

        request_json = self._prepare_fullvm_restore_json(restore_option)
        request_json = self.add_revert_option(request_json, restore_option.get(&#39;revert&#39;, False))
        return self._process_restore_response(request_json)

    def full_vm_restore_out_of_place(
            self,
            vm_to_restore=None,
            restored_vm_name=None,
            vcenter_client=None,
            esx_host=None,
            datastore=None,
            overwrite=True,
            power_on=True,
            copy_precedence=0,
            disk_option=&#39;Original&#39;,
            transport_mode=&#39;Auto&#39;,
            proxy_client=None,
            to_time=0,
            **kwargs
    ):
        &#34;&#34;&#34;Restores the FULL Virtual machine specified in the input list
            to the provided vcenter client along with the ESX and the datastores.
            If the provided client name is none then it restores the Full Virtual
            Machine to the source client and corresponding ESX and datastore.

            Args:
                vm_to_restore            (str)    --  VM that is to be restored

                restored_vm_name         (str)    --  new name of vm. If nothing is passed,
                                                      &#39;del&#39; is appended to the original vm name

                vcenter_client    (str)    --  name of the vcenter client where the VM
                                                      should be restored.

                esx_host          (str)    --  destination esx host. Restores to the source
                                                      VM esx if this value is not specified

                datastore         (str)    --  datastore where the restored VM should be
                                                      located. Restores to the source VM datastore
                                                      if this value is not specified

                overwrite               (bool)    --  overwrite the existing VM
                                                      default: True

                power_on                (bool)    --  power on the  restored VM
                                                      default: True

                copy_precedence          (int)    --  copy precedence value
                                                      default: 0

                disk_option       (str)    --  disk provisioning for the  restored vm
                                                      Options for input are: &#39;Original&#39;,
                                                      &#39;Thick Lazy Zero&#39;, &#39;Thin&#39;, &#39;Thick Eager Zero&#39;
                                                      default: &#39;Original&#39;

                transport_mode    (str)    --  transport mode to be used for the restore.
                                                      Options for input are: &#39;Auto&#39;, &#39;SAN&#39;,
                                                      &#39;Hot Add&#39;, &#39;NBD&#39;, &#39;NBD SSL&#39;
                                                      default: Auto

                proxy_client      (str)    --  destination proxy client

                to_time             (Int)         --  End time to select the job for restore
                                                    default: None

                **kwargs                         : Arbitrary keyword arguments Properties as of
                                                     full_vm_restore_out_of_place
                    eg:
                    source_ip           (str)    --  IP of the source VM

                    destination_ip      (str)    --  IP of the destination VM

                    destComputerName  (str)    --  Hostname of the restored vm

                    source_subnet  (str)    --  subnet of the source vm

                    source_gateway  (str)    --  gateway of the source vm

                    destination_subnet  (str)    --  subnet of the restored vm

                    destination_gateway  (str)    --  gateway of the restored vm

                    media_agent         (str)   --  media agent for restore

                    restore_option      (dict)     --  complete dictionary with all advanced options
                        default: {}

                    v2_details          (dict)       -- details for v2 jobs
                                                    eg: check clients.vmclient.VMClient._child_job_subclient_details

                    revert              (bool)      --  Revert option


            Returns:
                object - instance of the Job class for this restore job

            Raises:
                SDKException:
                    if inputs are not of correct type as per definition

                    if failed to initialize job

                    if response is empty

                    if response is not success

        &#34;&#34;&#34;

        restore_option = {}
        extra_options = [&#39;source_ip&#39;, &#39;destination_ip&#39;, &#39;network&#39;, &#39;destComputerName&#39;,
                         &#39;source_subnet&#39;, &#39;source_gateway&#39;, &#39;destination_subnet&#39;,
                         &#39;destination_gateway&#39;, &#39;folder_path&#39;, &#39;media_agent&#39;, &#39;v2_details&#39;, &#39;revert&#39;]
        for key in extra_options:
            if key in kwargs:
                restore_option[key] = kwargs[key]
            else:
                restore_option[key] = None
        # check mandatory input parameters are correct
        if vm_to_restore and not isinstance(vm_to_restore, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if copy_precedence:
            restore_option[&#39;copy_precedence_applicable&#39;] = True

        # populating proxy client. It assumes the proxy controller added in instance
        # properties if not specified
        if proxy_client is not None:
            restore_option[&#39;client_name&#39;] = proxy_client

        if restored_vm_name:
            if not (isinstance(vm_to_restore, str) or
                    isinstance(restored_vm_name, str)):
                raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)
            restore_option[&#39;restore_new_name&#39;] = restored_vm_name

        if vm_to_restore and not isinstance(vm_to_restore, list):
            vm_to_restore = [vm_to_restore]

        restore_option_copy = restore_option.copy()

        self._set_restore_inputs(
            restore_option,
            in_place=False,
            vcenter_client=vcenter_client,
            datastore=datastore,
            esx_host=esx_host,
            esx_server=None,
            unconditional_overwrite=overwrite,
            power_on=power_on,
            vm_to_restore=self._set_vm_to_restore(vm_to_restore),
            disk_option=self._disk_option[disk_option],
            transport_mode=self._transport_mode[transport_mode],
            copy_precedence=copy_precedence,
            volume_level_restore=1,
            source_item=[],
            to_time=to_time
        )

        request_json = self._prepare_fullvm_restore_json(restore_option)
        request_json = self.add_revert_option(request_json, restore_option.get(&#39;revert&#39;, False))
        return self._process_restore_response(request_json)

    def disk_restore(self,
                     vm_name,
                     destination_path,
                     disk_name=None,
                     proxy_client=None,
                     copy_precedence=0,
                     convert_to=None,
                     media_agent=None,
                     snap_proxy=None):
        &#34;&#34;&#34;Restores the disk specified in the input paths list to the same location

            Args:
                vm_name             (str)    --  Name of the VM added in subclient content
                                                        whose  disk is selected for restore

                destination_path        (str)    --  Staging (destination) path to restore the
                                                        disk.

                disk_name                 (list)    --  name of the disk which has to be restored
                                                        (only vmdk files permitted - enter full
                                                        name of the disk)
                                                        default: None

                proxy_client        (str)    --  Destination proxy client to be used
                                                        default: None

                copy_precedence            (int)    --  SP copy precedence from which browse has to
                                                         be performed

                convert_to          (str)    --  disk format for the restored disk
                                                        (applicable only when the vmdk disk is
                                                        selected for restore). Allowed values are
                                                        &#34;VHDX&#34; or &#34;VHD&#34;
                                                        default: None

                media_agent         (str)   -- MA needs to use for disk browse
                    default :Storage policy MA

                snap_proxy          (str)   -- proxy need to be used for disk
                                                    restores from snap
                    default :proxy in instance or subclient
            Returns:
                object - instance of the Job class for this restore job

            Raises:
                SDKException:
                    if inputs are not passed in proper expected format

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;

        vm_names, vm_ids = self._get_vm_ids_and_names_dict_from_browse()
        _disk_restore_option = {}

        disk_extn = &#39;.vmdk&#39;
        if not disk_name:
            disk_name = []
        else:
            disk_extn = self._get_disk_extension(disk_name)

        # check if inputs are correct
        if not (isinstance(vm_name, str) and
                isinstance(destination_path, str) and
                isinstance(disk_name, list) and
                disk_extn == &#39;.vmdk&#39;):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if convert_to is not None:
            convert_to = convert_to.lower()
            if convert_to not in [&#39;vhdx&#39;, &#39;vhd&#39;]:
                raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if copy_precedence:
            _disk_restore_option[&#39;copy_precedence_applicable&#39;] = True

        # fetching all disks from the vm
        disk_list, disk_info_dict = self.disk_level_browse(
            &#34;\\&#34; + vm_ids[vm_name])

        if not disk_name:  # if disk names are not provided, restore all vmdk disks
            for each_disk_path in disk_list:
                disk_name.append(each_disk_path.split(&#39;\\&#39;)[-1])

        else:  # else, check if the given VM has a disk with the list of disks in disk_name.
            for each_disk in disk_name:
                each_disk_path = &#34;\\&#34; + str(vm_name) + &#34;\\&#34; + each_disk
                if each_disk_path not in disk_list:
                    raise SDKException(&#39;Subclient&#39;, &#39;111&#39;)

        # if conversion option is given
        if convert_to is not None:
            dest_disk_dict = {
                &#39;VHD_DYNAMIC&#39;: 13,
                &#39;VHDX_DYNAMIC&#39;: 21
            }
            vol_restore, dest_disk = self._get_conversion_disk_Type(&#39;vmdk&#39;, convert_to)
            _disk_restore_option[&#34;destination_disktype&#34;] = dest_disk_dict[dest_disk]
            _disk_restore_option[&#34;volume_level_restore&#34;] = 4
        else:
            _disk_restore_option[&#34;volume_level_restore&#34;] = 3

        _disk_restore_option[&#34;destination_vendor&#34;] = \
            self._backupset_object._instance_object._vendor_id

        if proxy_client is not None:
            _disk_restore_option[&#39;client&#39;] = proxy_client
        else:
            _disk_restore_option[&#39;client&#39;] = self._backupset_object._instance_object.co_ordinator

        # set Source item List
        src_item_list = []
        for each_disk in disk_name:
            src_item_list.append(&#34;\\&#34; + vm_ids[vm_name] + &#34;\\&#34; + each_disk.split(&#34;\\&#34;)[-1])

        _disk_restore_option[&#39;paths&#39;] = src_item_list

        self._set_restore_inputs(
            _disk_restore_option,
            in_place=False,
            copy_precedence=copy_precedence,
            destination_path=destination_path,
            paths=src_item_list
        )

        request_json = self._prepare_disk_restore_json(_disk_restore_option)
        return self._process_restore_response(request_json)

    def attach_disk_restore(self,
                            vm_name,
                            vcenter,
                            esx=None,
                            datastore=None,
                            proxy_client=None,
                            copy_precedence=0,
                            media_agent=None,
                            snap_proxy=None,
                            disk_name=None):

        &#34;&#34;&#34;Attaches the Disks to the provided vm

            Args:
                vm_name             (str)    --  Name of the VM added in subclient content
                                                        whose  disk is selected for restore

                vcenter             (dict)          --  Dictinoary of vcenter, username and creds

                esx                 (str)    --  Esx host where the vm resides

                datastore               (string)    --  Datastore where disks will be restoed to
                                                        default: None

                proxy_client        (str)    --  Destination proxy client to be used
                                                        default: None

                copy_precedence            (int)    --  SP copy precedence from which browse has to
                                                         be performed

                media_agent                 (str)   -- MA needs to use for disk browse
                                                        default :Storage policy MA

                snap_proxy                   (str)   -- proxy need to be used for disk
                                                    restores from snap
                                                   default :proxy in instance or subclient

                disk_name                    (str)  --  Prefix of the disk name to be attached
                                                        defaul: None

            Returns:
                object - instance of the Job class for this restore job

            Raises:
                SDKException:
                    if inputs are not passed in proper expected format

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;

        vm_names, vm_ids = self._get_vm_ids_and_names_dict_from_browse()
        _attach_disk_restore_option = {}

        disk_extn = &#39;.vmdk&#39;
        if not disk_name:
            disk_name = []
        else:
            disk_extn = self._get_disk_extension(disk_name)

        # check if inputs are correct
        if not (isinstance(vm_name, str) and
                isinstance(disk_name, list) and
                disk_extn == &#39;.vmdk&#39;):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if copy_precedence:
            _attach_disk_restore_option[&#39;copy_precedence_applicable&#39;] = True

        # fetching all disks from the vm
        disk_list, disk_info_dict = self.disk_level_browse(
            &#34;\\&#34; + vm_ids[vm_name])

        if not disk_name:  # if disk names are not provided, restore all vmdk disks
            for each_disk_path in disk_list:
                disk_name.append(disk_info_dict[each_disk_path][&#39;snap_display_name&#39;])

        else:  # else, check if the given VM has a disk with the list of disks in disk_name.
            for each_disk in disk_name:
                each_disk_path = &#34;\\&#34; + str(vm_name) + &#34;\\&#34; + each_disk
                if each_disk_path not in disk_list:
                    raise SDKException(&#39;Subclient&#39;, &#39;111&#39;)

        if proxy_client is not None:
            _attach_disk_restore_option[&#39;client&#39;] = proxy_client
        else:
            _attach_disk_restore_option[&#39;client&#39;] = self._backupset_object._instance_object.co_ordinator

        # set Source item List
        src_item_list = []
        for each_disk in disk_name:
            src_item_list.append(&#34;\\&#34; + vm_ids[vm_name] + &#34;\\&#34; + each_disk.split(&#34;\\&#34;)[-1])

        _attach_disk_restore_option[&#39;paths&#39;] = src_item_list

        self._set_restore_inputs(
            _attach_disk_restore_option,
            in_place=True,
            copy_precedence=copy_precedence,
            vm_to_restore=vm_name,
            esxHost=vcenter[&#39;vcenter&#39;],
            userName=vcenter[&#39;user&#39;],
            password=vcenter[&#39;password&#39;],
            esx=esx,
            paths=src_item_list,
            datastore=datastore,
            volume_level_restore=6
        )

        request_json = self._prepare_attach_disk_restore_json(_attach_disk_restore_option)
        return self._process_restore_response(request_json)

    def full_vm_conversion_azurerm(
            self,
            azure_client,
            vm_to_restore=None,
            resource_group=None,
            storage_account=None,
            datacenter=None,
            proxy_client=None,
            overwrite=True,
            power_on=True,
            instance_size=None,
            public_ip=False,
            restore_as_managed=False,
            copy_precedence=0,
            disk_type=None,
            restore_option=None,
            networkDisplayName=None,
            networkrsg=None,
            destsubid=None,
            subnetId=None):
        &#34;&#34;&#34;
                This converts the Hyperv VM to AzureRM
                Args:
                        vm_to_restore          (dict):     dict containing the VM name(s) to restore as
                                                           keys and the new VM name(s) as their values.
                                                           Input empty string for default VM name for
                                                           restored VM.
                                                           default: {}

                        azure_client    (str):      name of the AzureRM client
                                                           where the VM should be
                                                           restored.

                        resource_group   (str):      destination Resource group
                                                            in the AzureRM

                        storage_account  (str):    storage account where the
                                                          restored VM should be located
                                                          in AzureRM

                        overwrite              (bool):    overwrite the existing VM
                                                          default: True

                        power_on               (bool):    power on the  restored VM
                                                          default: True

                        instance_size    (str):    Instance Size of restored VM

                        public_ip              (bool):    If True, creates the Public IP of
                                                          restored VM

                        restore_as_managed     (bool):    If True, restore as Managed VM in Azure

                        copy_precedence         (int):    copy precedence value
                                                          default: 0

                        proxy_client      (str):   destination proxy client

                        networkDisplayName(str):   destination network display name

                        networkrsg        (str):   destination network display name&#39;s security group

                        destsubid         (str):   destination subscription id

                        subnetId          (str):   destination subet id



                    Returns:
                        object - instance of the Job class for this restore job

                    Raises:
                        SDKException:
                            if inputs are not of correct type as per definition

                            if failed to initialize job

                            if response is empty

                            if response is not success

        &#34;&#34;&#34;
        if restore_option is None:
            restore_option = {}

        if vm_to_restore and not isinstance(vm_to_restore, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if not isinstance(vm_to_restore, list):
            vm_to_restore = [vm_to_restore]
        # check mandatory input parameters are correct
        if not isinstance(azure_client, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        subclient = self._set_vm_conversion_defaults(azure_client, restore_option)
        instance = subclient._backupset_object._instance_object
        if proxy_client is None:
            proxy_client = instance.server_host_name[0]

        self._set_restore_inputs(
            restore_option,
            in_place=False,
            vcenter_client=azure_client,
            datastore=storage_account,
            esx_host=resource_group,
            datacenter=datacenter,
            unconditional_overwrite=overwrite,
            client_name=proxy_client,
            power_on=power_on,
            vm_to_restore=self._set_vm_to_restore(vm_to_restore),
            copy_precedence=copy_precedence,
            createPublicIP=public_ip,
            restoreAsManagedVM=restore_as_managed,
            instanceSize=instance_size,
            volume_level_restore=1,
            destination_instance=instance.instance_name,
            backupset_client_name=instance._agent_object._client_object.client_name,
            networkDisplayName=networkDisplayName,
            networkrsg=networkrsg,
            destsubid=destsubid,
            subnetId=subnetId
        )

        request_json = self._prepare_fullvm_restore_json(restore_option)
        return self._process_restore_response(request_json)


    def full_vm_conversion_hyperv(
            self,
            hyperv_client,
            vm_to_restore=None,
            DestinationPath=None,
            proxy_client=None,
            overwrite=True,
            power_on=True,
            copy_precedence=0,
            destination_network=None):
        &#34;&#34;&#34;
                This converts the AzureRM to Hyper-v VM
                Args:

                    hyperv_client(str):  name of the hyper-V client
                                                    where the VM should restored.

                    vm_to_restore(dict):    dict containing the VM name(s) to restore as
                                                keys and the new VM name(s) as their values.
                                                Input empty string for default VM name for
                                                restored VM.
                                                default: {}

                    DestinationPath   (str): DestinationPath
                                                        in the Hyper-V client

                    proxy_client(str):   destination proxy client

                    overwrite   (bool):    overwrite the existing VM
                                                default: True

                    power_on  (bool):    power on the  restored VM
                                            default: True

                    copy_precedence   (int):    copy precedence value
                                                    default: 0

                    Destination_network   (str):      Destination network
                                                            in the Hyper-V client

                    Returns:
                        object - instance of the Job class for this restore job

                    Raises:
                        SDKException:
                            if inputs are not of correct type as per definition

                            if failed to initialize job

                            if response is empty

                            if response is not success

        &#34;&#34;&#34;

        restore_option = {}

        # check mandatory input parameters are correct
        if not isinstance(hyperv_client, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if not isinstance(vm_to_restore, list):
            vm_to_restore = [vm_to_restore]

        subclient = self._set_vm_conversion_defaults(hyperv_client, restore_option)
        instance = subclient._backupset_object._instance_object
        if proxy_client is None:
            proxy_client = instance.server_host_name[0]

        self._set_restore_inputs(
            restore_option,
            in_place=False,
            vcenter_client=hyperv_client,
            unconditional_overwrite=overwrite,
            client_name=proxy_client,
            DestinationPath=DestinationPath,
            power_on=power_on,
            vm_to_restore=vm_to_restore,
            copy_precedence=copy_precedence,
            datastore=DestinationPath,
            name=vm_to_restore,
            destination_network=destination_network,
            volume_level_restore=1,
            destination_instance=instance.instance_name,
            backupset_client_name=instance._agent_object._client_object.client_name
        )

        request_json = self._prepare_fullvm_restore_json(restore_option)
        disk_options = request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][&#39;diskLevelVMRestoreOption&#39;]
        for disk_info in disk_options[&#39;advancedRestoreOptions&#39;][0][&#39;disks&#39;]:
            disk_info[&#39;newName&#39;] = &#39;&#39;
        request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;volumeRstOption&#39;][&#39;volumeLevelRestoreType&#39;] = 1

        return self._process_restore_response(request_json)

    def create_blr_replication_pair(self, *, target, vms, plan_name, rpstore=None, granular_options=None):
        &#34;&#34;&#34;

        Args:
            target  (VirtualMachinePolicy): an instance of  VirtualMachinePolicy which is the target

            vms     (List)                : List of VMs to be replicated

            plan_name (str)               : Name of the plan

            rpstore (str)                 : Name of the RPStore.
                default : None. If name of the RPStore is given, granular mode is chosen else Live mode

            granular_options(dict)        : Dict which contains granular recovery options

                Example:
                    {
                        &#34;ccrpInterval&#34;: 300,
                        &#34;acrpInterval&#34;: 0,
                        &#34;maxRpInterval&#34;: 21600,
                        &#34;rpMergeDelay&#34;: 172800,
                        &#34;rpRetention&#34;: 604800,
                        &#34;maxRpStoreOfflineTime&#34;: 0,
                        &#34;useOffPeakSchedule&#34;: 0,
                    }
        &#34;&#34;&#34;

        try:
            assert isinstance(target, VirtualMachinePolicy) is True
        except AssertionError:
            raise TypeError(&#34;Expected an instance of VirtualMachinePolicy&#34;)
        if rpstore and granular_options:
            try:
                assert granular_options[&#34;rpRetention&#34;] &gt; granular_options[&#34;rpMergeDelay&#34;]
                assert granular_options[&#34;rpRetention&#34;] &gt; granular_options[&#34;maxRpInterval&#34;]
            except AssertionError:
                ValueError(&#34;rpRetention value must be greater than rpMergeDelay and maxRpInterval&#34;)

        restore_option = dict()
        restore_option.update(granular_options)
        for vm in vms:
            self._set_restore_inputs(
                restore_option,
                paths=[],
                in_place=False,
                target_id=target.vm_policy_id,
                target_name=target.vm_policy_name,
                vcenter_client=target.properties()[&#34;destinationHyperV&#34;][&#34;clientName&#34;],
                datastore=target.properties()[&#34;dataStores&#34;][0][&#34;dataStoreName&#34;],
                esx_host=target.properties()[&#34;esxServers&#34;][0][&#34;esxServerName&#34;],
                vm_to_restore=[vm],
                volume_level_restore=1,
                block_level=True,
                new_name=target.properties()[&#34;vmNameEditString&#34;],
                prefix=bool(target.properties()[&#34;vmNameEditType&#34;] == 1),
                plan_name=plan_name,
                source_network=target.properties()[&#34;networkList&#34;][0][&#34;sourceNetwork&#34;],
                destination_network=target.properties()[&#34;networkList&#34;][0][&#34;destinationNetwork&#34;]

            )
            if isinstance(rpstore, RPStore):
                restore_option[&#34;recovery_type&#34;] = 4
                restore_option[&#34;rpstore_name&#34;] = rpstore.rpstore_name
                restore_option[&#34;rpstore_id&#34;] = rpstore.rpstore_id

            response = self._commcell_object.execute_qcommand(&#34;qoperation execute&#34;,
                                                              self._prepare_blr_xml(restore_option))
            if response.json() != {&#39;errorMessage&#39;: &#39;&#39;, &#39;errorCode&#39;: 0}:
                raise SDKException(&#34;Subclient&#34;, 102, response.json()[&#34;errorMessage&#34;])

    def full_vm_conversion_googlecloud(
            self,
            google_cloud_client,
            vm_to_restore=None,
            esx_host=None,
            vmSize=None,
            nics=None,
            datacenter=None,
            projectId=None,
            overwrite=True,
            power_on=True,
            proxy_client=None,
            vcenter_client=None,
            esx_server=None,
            copy_precedence=0,
            restore_option=None):

        &#34;&#34;&#34;
                        This converts the VMware to Google Cloud
                        Args:
                                vm_to_restore          (list):     provide the VM names to restore

                                google_cloud_client    (str):      name of the Google Cloud client
                                                                   where the VM should be
                                                                   restored.

                                esx_host               (str): Zone of the restored VM in Google Cloud

                                vmSize                 (str): vmSize of the restoed VM

                                overwrite              (bool):    overwrite the existing VM
                                                                  default: True

                                power_on               (bool):    power on the  restored VM
                                                                  default: True

                                vcenter_client    (str)    --  name of the vcenter client where the VM
                                                      should be restored.

                                copy_precedence         (int):    copy precedence value
                                                                  default: 0

                                proxy_client      (str):   destination proxy client

                                esx_server        (str):    Name of the destination virtualization Client

                                nics              (str):   Network Configurations of the VM

                                datacenter        (str):   Project ID of the restored VM

                                projectId         (str):   project ID where the new VM has to be created

                            Returns:
                                object - instance of the Job class for this restore job

                            Raises:
                                SDKException:
                                    if inputs are not of correct type as per definition

                                    if failed to initialize job

                                    if response is empty

                                    if response is not success

        &#34;&#34;&#34;

        if restore_option is None:
            restore_option = {}

        # check mandatory input parameters are correct
        if not isinstance(google_cloud_client, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        subclient = self._set_vm_conversion_defaults(google_cloud_client, restore_option)
        instance = subclient._backupset_object._instance_object
        if proxy_client is None:
            proxy_client = instance.server_host_name[0]

        if vm_to_restore is None:
            vm_to_restore = self._set_vm_to_restore(vm_to_restore)

        self._set_restore_inputs(
            restore_option,
            vm_to_restore=vm_to_restore,
            esx_host=esx_host,
            esx_server=esx_server,
            vcenter_client=vcenter_client,
            vmSize=vmSize,
            nics=nics,
            datacenter=datacenter,
            createPublicIP=False,
            projectId=projectId,
            unconditional_overwrite=overwrite,
            power_on=power_on,
            volume_level_restore=1,
            client_name=proxy_client,
            in_place=False,
            copy_precedence=copy_precedence
        )

        request_json = self._prepare_fullvm_restore_json(restore_option)
        request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
            &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;projectId&#39;] = projectId
        request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
            &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;newName&#39;] = vm_to_restore[0].lower().replace(&#34;_&#34;,
                                                                                                                   &#34;&#34;)
        disk_new_names = request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
            &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;disks&#39;]
        for each in range(0, len(disk_new_names)):
            request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
                &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;disks&#39;][each][&#39;newName&#39;] = &#34;&#34;
        return self._process_restore_response(request_json)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient"><code class="flex name class">
<span>class <span class="ident">VMWareVirtualServerSubclient</span></span>
<span>(</span><span>backupset_object, subclient_name, subclient_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Derived class from VirtualServerSubclient Base class.
This represents a VMWare virtual server subclient,
and can perform restore operations on only that subclient.</p>
<p>Initialize the Instance object for the given Virtual Server instance.
Args
class_object (backupset_object, subclient_name, subclient_id)
&ndash;
instance of the
backupset class, subclient name, subclient id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L50-L1016" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class VMWareVirtualServerSubclient(VirtualServerSubclient):
    &#34;&#34;&#34;Derived class from VirtualServerSubclient Base class.
       This represents a VMWare virtual server subclient,
       and can perform restore operations on only that subclient.

    &#34;&#34;&#34;

    def __init__(self, backupset_object, subclient_name, subclient_id=None):
        &#34;&#34;&#34;Initialize the Instance object for the given Virtual Server instance.
        Args
        class_object (backupset_object, subclient_name, subclient_id)  --  instance of the
                                         backupset class, subclient name, subclient id

        &#34;&#34;&#34;

        super(VMWareVirtualServerSubclient, self).__init__(
            backupset_object, subclient_name, subclient_id)
        self.diskExtension = [&#34;.vmdk&#34;]

        self._disk_option = {
            &#39;Original&#39;: 0,
            &#39;Thick Lazy Zero&#39;: 1,
            &#39;Thin&#39;: 2,
            &#39;Thick Eager Zero&#39;: 3
        }

        self._transport_mode = {
            &#39;Auto&#39;: 0,
            &#39;SAN&#39;: 1,
            &#39;Hot Add&#39;: 2,
            &#39;NBD&#39;: 5,
            &#39;NBD SSL&#39;: 4
        }

    def add_revert_option(self, request_json, revert):
        &#34;&#34;&#34;
        Add revert in restore json

        Args:

            request_json            (dict)  :       restore dict

            revert                  (bool)  :       revert option

        Returns:
            request_json            (dict)  :       restore dict

        &#34;&#34;&#34;
        if revert:
            request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;commonOptions&#39;][&#39;revert&#39;] = True
        return request_json

    def full_vm_restore_in_place(
            self,
            vm_to_restore=None,
            overwrite=True,
            power_on=True,
            copy_precedence=0,
            disk_option=&#39;Original&#39;,
            transport_mode=&#39;Auto&#39;,
            proxy_client=None,
            to_time=0,
            **kwargs):
        &#34;&#34;&#34;Restores the FULL Virtual machine specified in the input list
            to the location same as the actual location of the VM in VCenter.

            Args:
                vm_to_restore         (list)        --  provide the VM name to restore
                                                        default: None

                overwrite             (bool)        --  overwrite the existing VM
                                                        default: True

                power_on              (bool)        --  power on the  restored VM
                                                        default: True

                copy_precedence       (int)         --  copy precedence value
                                                        default: 0

                disk_option           (str)  --  disk provisioning for the restored vm
                                                        Options for input are: &#39;Original&#39;,
                                                        &#39;Thick Lazy Zero&#39;, &#39;Thin&#39;,
                                                        &#39;Thick Eager Zero&#39;
                                                        default: Original

                transport_mode        (str)  --  transport mode to be used for
                                                        the restore.
                                                        Options for input are: &#39;Auto&#39;, &#39;SAN&#39;,
                                                        &#39;&#39;Hot Add&#39;, NBD&#39;, &#39;NBD SSL&#39;
                                                        default: Auto

                proxy_client          (str)  --  proxy client to be used for restore
                                                        default: proxy added in subclient

                to_time                 (int)       -- End time to select the job for restore
                                                        default: None

                **kwargs                         : Arbitrary keyword arguments Properties as of
                                                     full_vm_restore_in_place
                    eg:
                    media_agent         (str)   -- media agent

                    v2_details          (dict)       -- details for v2 subclient
                                                    eg: check clients.vmclient.VMClient._child_job_subclient_details

                    revert              (bool)      --  Revert option


            Returns:
                object - instance of the Job class for this restore job

            Raises:
                SDKException:
                    if inputs are not of correct type as per definition

                    if failed to initialize job

                    if response is empty

                    if response is not success

        &#34;&#34;&#34;

        restore_option = {&#34;media_agent&#34;: kwargs.get(&#34;media_agent&#34;, None), &#34;v2_details&#34;: kwargs.get(&#34;v2_details&#34;, None),
                          &#34;revert&#34;: kwargs.get(&#34;revert&#34;, False)}

        # check input parameters are correct
        if vm_to_restore and not isinstance(vm_to_restore, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        disk_option_value = self._disk_option[disk_option]
        transport_mode_value = self._transport_mode[transport_mode]

        if copy_precedence:
            restore_option[&#39;copy_precedence_applicable&#39;] = True

        if proxy_client is not None:
            restore_option[&#39;client_name&#39;] = proxy_client

        if vm_to_restore and not isinstance(vm_to_restore, list):
            vm_to_restore = [vm_to_restore]
        restore_option_copy = restore_option.copy()

        # set attr for all the option in restore xml from user inputs
        self._set_restore_inputs(
            restore_option,
            vm_to_restore=self._set_vm_to_restore(vm_to_restore),
            in_place=True,
            esx_server_name=&#34;&#34;,
            volume_level_restore=1,
            unconditional_overwrite=overwrite,
            power_on=power_on,
            disk_option=disk_option_value,
            transport_mode=transport_mode_value,
            copy_precedence=copy_precedence,
            to_time=to_time
        )

        request_json = self._prepare_fullvm_restore_json(restore_option)
        request_json = self.add_revert_option(request_json, restore_option.get(&#39;revert&#39;, False))
        return self._process_restore_response(request_json)

    def full_vm_restore_out_of_place(
            self,
            vm_to_restore=None,
            restored_vm_name=None,
            vcenter_client=None,
            esx_host=None,
            datastore=None,
            overwrite=True,
            power_on=True,
            copy_precedence=0,
            disk_option=&#39;Original&#39;,
            transport_mode=&#39;Auto&#39;,
            proxy_client=None,
            to_time=0,
            **kwargs
    ):
        &#34;&#34;&#34;Restores the FULL Virtual machine specified in the input list
            to the provided vcenter client along with the ESX and the datastores.
            If the provided client name is none then it restores the Full Virtual
            Machine to the source client and corresponding ESX and datastore.

            Args:
                vm_to_restore            (str)    --  VM that is to be restored

                restored_vm_name         (str)    --  new name of vm. If nothing is passed,
                                                      &#39;del&#39; is appended to the original vm name

                vcenter_client    (str)    --  name of the vcenter client where the VM
                                                      should be restored.

                esx_host          (str)    --  destination esx host. Restores to the source
                                                      VM esx if this value is not specified

                datastore         (str)    --  datastore where the restored VM should be
                                                      located. Restores to the source VM datastore
                                                      if this value is not specified

                overwrite               (bool)    --  overwrite the existing VM
                                                      default: True

                power_on                (bool)    --  power on the  restored VM
                                                      default: True

                copy_precedence          (int)    --  copy precedence value
                                                      default: 0

                disk_option       (str)    --  disk provisioning for the  restored vm
                                                      Options for input are: &#39;Original&#39;,
                                                      &#39;Thick Lazy Zero&#39;, &#39;Thin&#39;, &#39;Thick Eager Zero&#39;
                                                      default: &#39;Original&#39;

                transport_mode    (str)    --  transport mode to be used for the restore.
                                                      Options for input are: &#39;Auto&#39;, &#39;SAN&#39;,
                                                      &#39;Hot Add&#39;, &#39;NBD&#39;, &#39;NBD SSL&#39;
                                                      default: Auto

                proxy_client      (str)    --  destination proxy client

                to_time             (Int)         --  End time to select the job for restore
                                                    default: None

                **kwargs                         : Arbitrary keyword arguments Properties as of
                                                     full_vm_restore_out_of_place
                    eg:
                    source_ip           (str)    --  IP of the source VM

                    destination_ip      (str)    --  IP of the destination VM

                    destComputerName  (str)    --  Hostname of the restored vm

                    source_subnet  (str)    --  subnet of the source vm

                    source_gateway  (str)    --  gateway of the source vm

                    destination_subnet  (str)    --  subnet of the restored vm

                    destination_gateway  (str)    --  gateway of the restored vm

                    media_agent         (str)   --  media agent for restore

                    restore_option      (dict)     --  complete dictionary with all advanced options
                        default: {}

                    v2_details          (dict)       -- details for v2 jobs
                                                    eg: check clients.vmclient.VMClient._child_job_subclient_details

                    revert              (bool)      --  Revert option


            Returns:
                object - instance of the Job class for this restore job

            Raises:
                SDKException:
                    if inputs are not of correct type as per definition

                    if failed to initialize job

                    if response is empty

                    if response is not success

        &#34;&#34;&#34;

        restore_option = {}
        extra_options = [&#39;source_ip&#39;, &#39;destination_ip&#39;, &#39;network&#39;, &#39;destComputerName&#39;,
                         &#39;source_subnet&#39;, &#39;source_gateway&#39;, &#39;destination_subnet&#39;,
                         &#39;destination_gateway&#39;, &#39;folder_path&#39;, &#39;media_agent&#39;, &#39;v2_details&#39;, &#39;revert&#39;]
        for key in extra_options:
            if key in kwargs:
                restore_option[key] = kwargs[key]
            else:
                restore_option[key] = None
        # check mandatory input parameters are correct
        if vm_to_restore and not isinstance(vm_to_restore, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if copy_precedence:
            restore_option[&#39;copy_precedence_applicable&#39;] = True

        # populating proxy client. It assumes the proxy controller added in instance
        # properties if not specified
        if proxy_client is not None:
            restore_option[&#39;client_name&#39;] = proxy_client

        if restored_vm_name:
            if not (isinstance(vm_to_restore, str) or
                    isinstance(restored_vm_name, str)):
                raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)
            restore_option[&#39;restore_new_name&#39;] = restored_vm_name

        if vm_to_restore and not isinstance(vm_to_restore, list):
            vm_to_restore = [vm_to_restore]

        restore_option_copy = restore_option.copy()

        self._set_restore_inputs(
            restore_option,
            in_place=False,
            vcenter_client=vcenter_client,
            datastore=datastore,
            esx_host=esx_host,
            esx_server=None,
            unconditional_overwrite=overwrite,
            power_on=power_on,
            vm_to_restore=self._set_vm_to_restore(vm_to_restore),
            disk_option=self._disk_option[disk_option],
            transport_mode=self._transport_mode[transport_mode],
            copy_precedence=copy_precedence,
            volume_level_restore=1,
            source_item=[],
            to_time=to_time
        )

        request_json = self._prepare_fullvm_restore_json(restore_option)
        request_json = self.add_revert_option(request_json, restore_option.get(&#39;revert&#39;, False))
        return self._process_restore_response(request_json)

    def disk_restore(self,
                     vm_name,
                     destination_path,
                     disk_name=None,
                     proxy_client=None,
                     copy_precedence=0,
                     convert_to=None,
                     media_agent=None,
                     snap_proxy=None):
        &#34;&#34;&#34;Restores the disk specified in the input paths list to the same location

            Args:
                vm_name             (str)    --  Name of the VM added in subclient content
                                                        whose  disk is selected for restore

                destination_path        (str)    --  Staging (destination) path to restore the
                                                        disk.

                disk_name                 (list)    --  name of the disk which has to be restored
                                                        (only vmdk files permitted - enter full
                                                        name of the disk)
                                                        default: None

                proxy_client        (str)    --  Destination proxy client to be used
                                                        default: None

                copy_precedence            (int)    --  SP copy precedence from which browse has to
                                                         be performed

                convert_to          (str)    --  disk format for the restored disk
                                                        (applicable only when the vmdk disk is
                                                        selected for restore). Allowed values are
                                                        &#34;VHDX&#34; or &#34;VHD&#34;
                                                        default: None

                media_agent         (str)   -- MA needs to use for disk browse
                    default :Storage policy MA

                snap_proxy          (str)   -- proxy need to be used for disk
                                                    restores from snap
                    default :proxy in instance or subclient
            Returns:
                object - instance of the Job class for this restore job

            Raises:
                SDKException:
                    if inputs are not passed in proper expected format

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;

        vm_names, vm_ids = self._get_vm_ids_and_names_dict_from_browse()
        _disk_restore_option = {}

        disk_extn = &#39;.vmdk&#39;
        if not disk_name:
            disk_name = []
        else:
            disk_extn = self._get_disk_extension(disk_name)

        # check if inputs are correct
        if not (isinstance(vm_name, str) and
                isinstance(destination_path, str) and
                isinstance(disk_name, list) and
                disk_extn == &#39;.vmdk&#39;):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if convert_to is not None:
            convert_to = convert_to.lower()
            if convert_to not in [&#39;vhdx&#39;, &#39;vhd&#39;]:
                raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if copy_precedence:
            _disk_restore_option[&#39;copy_precedence_applicable&#39;] = True

        # fetching all disks from the vm
        disk_list, disk_info_dict = self.disk_level_browse(
            &#34;\\&#34; + vm_ids[vm_name])

        if not disk_name:  # if disk names are not provided, restore all vmdk disks
            for each_disk_path in disk_list:
                disk_name.append(each_disk_path.split(&#39;\\&#39;)[-1])

        else:  # else, check if the given VM has a disk with the list of disks in disk_name.
            for each_disk in disk_name:
                each_disk_path = &#34;\\&#34; + str(vm_name) + &#34;\\&#34; + each_disk
                if each_disk_path not in disk_list:
                    raise SDKException(&#39;Subclient&#39;, &#39;111&#39;)

        # if conversion option is given
        if convert_to is not None:
            dest_disk_dict = {
                &#39;VHD_DYNAMIC&#39;: 13,
                &#39;VHDX_DYNAMIC&#39;: 21
            }
            vol_restore, dest_disk = self._get_conversion_disk_Type(&#39;vmdk&#39;, convert_to)
            _disk_restore_option[&#34;destination_disktype&#34;] = dest_disk_dict[dest_disk]
            _disk_restore_option[&#34;volume_level_restore&#34;] = 4
        else:
            _disk_restore_option[&#34;volume_level_restore&#34;] = 3

        _disk_restore_option[&#34;destination_vendor&#34;] = \
            self._backupset_object._instance_object._vendor_id

        if proxy_client is not None:
            _disk_restore_option[&#39;client&#39;] = proxy_client
        else:
            _disk_restore_option[&#39;client&#39;] = self._backupset_object._instance_object.co_ordinator

        # set Source item List
        src_item_list = []
        for each_disk in disk_name:
            src_item_list.append(&#34;\\&#34; + vm_ids[vm_name] + &#34;\\&#34; + each_disk.split(&#34;\\&#34;)[-1])

        _disk_restore_option[&#39;paths&#39;] = src_item_list

        self._set_restore_inputs(
            _disk_restore_option,
            in_place=False,
            copy_precedence=copy_precedence,
            destination_path=destination_path,
            paths=src_item_list
        )

        request_json = self._prepare_disk_restore_json(_disk_restore_option)
        return self._process_restore_response(request_json)

    def attach_disk_restore(self,
                            vm_name,
                            vcenter,
                            esx=None,
                            datastore=None,
                            proxy_client=None,
                            copy_precedence=0,
                            media_agent=None,
                            snap_proxy=None,
                            disk_name=None):

        &#34;&#34;&#34;Attaches the Disks to the provided vm

            Args:
                vm_name             (str)    --  Name of the VM added in subclient content
                                                        whose  disk is selected for restore

                vcenter             (dict)          --  Dictinoary of vcenter, username and creds

                esx                 (str)    --  Esx host where the vm resides

                datastore               (string)    --  Datastore where disks will be restoed to
                                                        default: None

                proxy_client        (str)    --  Destination proxy client to be used
                                                        default: None

                copy_precedence            (int)    --  SP copy precedence from which browse has to
                                                         be performed

                media_agent                 (str)   -- MA needs to use for disk browse
                                                        default :Storage policy MA

                snap_proxy                   (str)   -- proxy need to be used for disk
                                                    restores from snap
                                                   default :proxy in instance or subclient

                disk_name                    (str)  --  Prefix of the disk name to be attached
                                                        defaul: None

            Returns:
                object - instance of the Job class for this restore job

            Raises:
                SDKException:
                    if inputs are not passed in proper expected format

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;

        vm_names, vm_ids = self._get_vm_ids_and_names_dict_from_browse()
        _attach_disk_restore_option = {}

        disk_extn = &#39;.vmdk&#39;
        if not disk_name:
            disk_name = []
        else:
            disk_extn = self._get_disk_extension(disk_name)

        # check if inputs are correct
        if not (isinstance(vm_name, str) and
                isinstance(disk_name, list) and
                disk_extn == &#39;.vmdk&#39;):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if copy_precedence:
            _attach_disk_restore_option[&#39;copy_precedence_applicable&#39;] = True

        # fetching all disks from the vm
        disk_list, disk_info_dict = self.disk_level_browse(
            &#34;\\&#34; + vm_ids[vm_name])

        if not disk_name:  # if disk names are not provided, restore all vmdk disks
            for each_disk_path in disk_list:
                disk_name.append(disk_info_dict[each_disk_path][&#39;snap_display_name&#39;])

        else:  # else, check if the given VM has a disk with the list of disks in disk_name.
            for each_disk in disk_name:
                each_disk_path = &#34;\\&#34; + str(vm_name) + &#34;\\&#34; + each_disk
                if each_disk_path not in disk_list:
                    raise SDKException(&#39;Subclient&#39;, &#39;111&#39;)

        if proxy_client is not None:
            _attach_disk_restore_option[&#39;client&#39;] = proxy_client
        else:
            _attach_disk_restore_option[&#39;client&#39;] = self._backupset_object._instance_object.co_ordinator

        # set Source item List
        src_item_list = []
        for each_disk in disk_name:
            src_item_list.append(&#34;\\&#34; + vm_ids[vm_name] + &#34;\\&#34; + each_disk.split(&#34;\\&#34;)[-1])

        _attach_disk_restore_option[&#39;paths&#39;] = src_item_list

        self._set_restore_inputs(
            _attach_disk_restore_option,
            in_place=True,
            copy_precedence=copy_precedence,
            vm_to_restore=vm_name,
            esxHost=vcenter[&#39;vcenter&#39;],
            userName=vcenter[&#39;user&#39;],
            password=vcenter[&#39;password&#39;],
            esx=esx,
            paths=src_item_list,
            datastore=datastore,
            volume_level_restore=6
        )

        request_json = self._prepare_attach_disk_restore_json(_attach_disk_restore_option)
        return self._process_restore_response(request_json)

    def full_vm_conversion_azurerm(
            self,
            azure_client,
            vm_to_restore=None,
            resource_group=None,
            storage_account=None,
            datacenter=None,
            proxy_client=None,
            overwrite=True,
            power_on=True,
            instance_size=None,
            public_ip=False,
            restore_as_managed=False,
            copy_precedence=0,
            disk_type=None,
            restore_option=None,
            networkDisplayName=None,
            networkrsg=None,
            destsubid=None,
            subnetId=None):
        &#34;&#34;&#34;
                This converts the Hyperv VM to AzureRM
                Args:
                        vm_to_restore          (dict):     dict containing the VM name(s) to restore as
                                                           keys and the new VM name(s) as their values.
                                                           Input empty string for default VM name for
                                                           restored VM.
                                                           default: {}

                        azure_client    (str):      name of the AzureRM client
                                                           where the VM should be
                                                           restored.

                        resource_group   (str):      destination Resource group
                                                            in the AzureRM

                        storage_account  (str):    storage account where the
                                                          restored VM should be located
                                                          in AzureRM

                        overwrite              (bool):    overwrite the existing VM
                                                          default: True

                        power_on               (bool):    power on the  restored VM
                                                          default: True

                        instance_size    (str):    Instance Size of restored VM

                        public_ip              (bool):    If True, creates the Public IP of
                                                          restored VM

                        restore_as_managed     (bool):    If True, restore as Managed VM in Azure

                        copy_precedence         (int):    copy precedence value
                                                          default: 0

                        proxy_client      (str):   destination proxy client

                        networkDisplayName(str):   destination network display name

                        networkrsg        (str):   destination network display name&#39;s security group

                        destsubid         (str):   destination subscription id

                        subnetId          (str):   destination subet id



                    Returns:
                        object - instance of the Job class for this restore job

                    Raises:
                        SDKException:
                            if inputs are not of correct type as per definition

                            if failed to initialize job

                            if response is empty

                            if response is not success

        &#34;&#34;&#34;
        if restore_option is None:
            restore_option = {}

        if vm_to_restore and not isinstance(vm_to_restore, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if not isinstance(vm_to_restore, list):
            vm_to_restore = [vm_to_restore]
        # check mandatory input parameters are correct
        if not isinstance(azure_client, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        subclient = self._set_vm_conversion_defaults(azure_client, restore_option)
        instance = subclient._backupset_object._instance_object
        if proxy_client is None:
            proxy_client = instance.server_host_name[0]

        self._set_restore_inputs(
            restore_option,
            in_place=False,
            vcenter_client=azure_client,
            datastore=storage_account,
            esx_host=resource_group,
            datacenter=datacenter,
            unconditional_overwrite=overwrite,
            client_name=proxy_client,
            power_on=power_on,
            vm_to_restore=self._set_vm_to_restore(vm_to_restore),
            copy_precedence=copy_precedence,
            createPublicIP=public_ip,
            restoreAsManagedVM=restore_as_managed,
            instanceSize=instance_size,
            volume_level_restore=1,
            destination_instance=instance.instance_name,
            backupset_client_name=instance._agent_object._client_object.client_name,
            networkDisplayName=networkDisplayName,
            networkrsg=networkrsg,
            destsubid=destsubid,
            subnetId=subnetId
        )

        request_json = self._prepare_fullvm_restore_json(restore_option)
        return self._process_restore_response(request_json)


    def full_vm_conversion_hyperv(
            self,
            hyperv_client,
            vm_to_restore=None,
            DestinationPath=None,
            proxy_client=None,
            overwrite=True,
            power_on=True,
            copy_precedence=0,
            destination_network=None):
        &#34;&#34;&#34;
                This converts the AzureRM to Hyper-v VM
                Args:

                    hyperv_client(str):  name of the hyper-V client
                                                    where the VM should restored.

                    vm_to_restore(dict):    dict containing the VM name(s) to restore as
                                                keys and the new VM name(s) as their values.
                                                Input empty string for default VM name for
                                                restored VM.
                                                default: {}

                    DestinationPath   (str): DestinationPath
                                                        in the Hyper-V client

                    proxy_client(str):   destination proxy client

                    overwrite   (bool):    overwrite the existing VM
                                                default: True

                    power_on  (bool):    power on the  restored VM
                                            default: True

                    copy_precedence   (int):    copy precedence value
                                                    default: 0

                    Destination_network   (str):      Destination network
                                                            in the Hyper-V client

                    Returns:
                        object - instance of the Job class for this restore job

                    Raises:
                        SDKException:
                            if inputs are not of correct type as per definition

                            if failed to initialize job

                            if response is empty

                            if response is not success

        &#34;&#34;&#34;

        restore_option = {}

        # check mandatory input parameters are correct
        if not isinstance(hyperv_client, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        if not isinstance(vm_to_restore, list):
            vm_to_restore = [vm_to_restore]

        subclient = self._set_vm_conversion_defaults(hyperv_client, restore_option)
        instance = subclient._backupset_object._instance_object
        if proxy_client is None:
            proxy_client = instance.server_host_name[0]

        self._set_restore_inputs(
            restore_option,
            in_place=False,
            vcenter_client=hyperv_client,
            unconditional_overwrite=overwrite,
            client_name=proxy_client,
            DestinationPath=DestinationPath,
            power_on=power_on,
            vm_to_restore=vm_to_restore,
            copy_precedence=copy_precedence,
            datastore=DestinationPath,
            name=vm_to_restore,
            destination_network=destination_network,
            volume_level_restore=1,
            destination_instance=instance.instance_name,
            backupset_client_name=instance._agent_object._client_object.client_name
        )

        request_json = self._prepare_fullvm_restore_json(restore_option)
        disk_options = request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][&#39;diskLevelVMRestoreOption&#39;]
        for disk_info in disk_options[&#39;advancedRestoreOptions&#39;][0][&#39;disks&#39;]:
            disk_info[&#39;newName&#39;] = &#39;&#39;
        request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;volumeRstOption&#39;][&#39;volumeLevelRestoreType&#39;] = 1

        return self._process_restore_response(request_json)

    def create_blr_replication_pair(self, *, target, vms, plan_name, rpstore=None, granular_options=None):
        &#34;&#34;&#34;

        Args:
            target  (VirtualMachinePolicy): an instance of  VirtualMachinePolicy which is the target

            vms     (List)                : List of VMs to be replicated

            plan_name (str)               : Name of the plan

            rpstore (str)                 : Name of the RPStore.
                default : None. If name of the RPStore is given, granular mode is chosen else Live mode

            granular_options(dict)        : Dict which contains granular recovery options

                Example:
                    {
                        &#34;ccrpInterval&#34;: 300,
                        &#34;acrpInterval&#34;: 0,
                        &#34;maxRpInterval&#34;: 21600,
                        &#34;rpMergeDelay&#34;: 172800,
                        &#34;rpRetention&#34;: 604800,
                        &#34;maxRpStoreOfflineTime&#34;: 0,
                        &#34;useOffPeakSchedule&#34;: 0,
                    }
        &#34;&#34;&#34;

        try:
            assert isinstance(target, VirtualMachinePolicy) is True
        except AssertionError:
            raise TypeError(&#34;Expected an instance of VirtualMachinePolicy&#34;)
        if rpstore and granular_options:
            try:
                assert granular_options[&#34;rpRetention&#34;] &gt; granular_options[&#34;rpMergeDelay&#34;]
                assert granular_options[&#34;rpRetention&#34;] &gt; granular_options[&#34;maxRpInterval&#34;]
            except AssertionError:
                ValueError(&#34;rpRetention value must be greater than rpMergeDelay and maxRpInterval&#34;)

        restore_option = dict()
        restore_option.update(granular_options)
        for vm in vms:
            self._set_restore_inputs(
                restore_option,
                paths=[],
                in_place=False,
                target_id=target.vm_policy_id,
                target_name=target.vm_policy_name,
                vcenter_client=target.properties()[&#34;destinationHyperV&#34;][&#34;clientName&#34;],
                datastore=target.properties()[&#34;dataStores&#34;][0][&#34;dataStoreName&#34;],
                esx_host=target.properties()[&#34;esxServers&#34;][0][&#34;esxServerName&#34;],
                vm_to_restore=[vm],
                volume_level_restore=1,
                block_level=True,
                new_name=target.properties()[&#34;vmNameEditString&#34;],
                prefix=bool(target.properties()[&#34;vmNameEditType&#34;] == 1),
                plan_name=plan_name,
                source_network=target.properties()[&#34;networkList&#34;][0][&#34;sourceNetwork&#34;],
                destination_network=target.properties()[&#34;networkList&#34;][0][&#34;destinationNetwork&#34;]

            )
            if isinstance(rpstore, RPStore):
                restore_option[&#34;recovery_type&#34;] = 4
                restore_option[&#34;rpstore_name&#34;] = rpstore.rpstore_name
                restore_option[&#34;rpstore_id&#34;] = rpstore.rpstore_id

            response = self._commcell_object.execute_qcommand(&#34;qoperation execute&#34;,
                                                              self._prepare_blr_xml(restore_option))
            if response.json() != {&#39;errorMessage&#39;: &#39;&#39;, &#39;errorCode&#39;: 0}:
                raise SDKException(&#34;Subclient&#34;, 102, response.json()[&#34;errorMessage&#34;])

    def full_vm_conversion_googlecloud(
            self,
            google_cloud_client,
            vm_to_restore=None,
            esx_host=None,
            vmSize=None,
            nics=None,
            datacenter=None,
            projectId=None,
            overwrite=True,
            power_on=True,
            proxy_client=None,
            vcenter_client=None,
            esx_server=None,
            copy_precedence=0,
            restore_option=None):

        &#34;&#34;&#34;
                        This converts the VMware to Google Cloud
                        Args:
                                vm_to_restore          (list):     provide the VM names to restore

                                google_cloud_client    (str):      name of the Google Cloud client
                                                                   where the VM should be
                                                                   restored.

                                esx_host               (str): Zone of the restored VM in Google Cloud

                                vmSize                 (str): vmSize of the restoed VM

                                overwrite              (bool):    overwrite the existing VM
                                                                  default: True

                                power_on               (bool):    power on the  restored VM
                                                                  default: True

                                vcenter_client    (str)    --  name of the vcenter client where the VM
                                                      should be restored.

                                copy_precedence         (int):    copy precedence value
                                                                  default: 0

                                proxy_client      (str):   destination proxy client

                                esx_server        (str):    Name of the destination virtualization Client

                                nics              (str):   Network Configurations of the VM

                                datacenter        (str):   Project ID of the restored VM

                                projectId         (str):   project ID where the new VM has to be created

                            Returns:
                                object - instance of the Job class for this restore job

                            Raises:
                                SDKException:
                                    if inputs are not of correct type as per definition

                                    if failed to initialize job

                                    if response is empty

                                    if response is not success

        &#34;&#34;&#34;

        if restore_option is None:
            restore_option = {}

        # check mandatory input parameters are correct
        if not isinstance(google_cloud_client, str):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

        subclient = self._set_vm_conversion_defaults(google_cloud_client, restore_option)
        instance = subclient._backupset_object._instance_object
        if proxy_client is None:
            proxy_client = instance.server_host_name[0]

        if vm_to_restore is None:
            vm_to_restore = self._set_vm_to_restore(vm_to_restore)

        self._set_restore_inputs(
            restore_option,
            vm_to_restore=vm_to_restore,
            esx_host=esx_host,
            esx_server=esx_server,
            vcenter_client=vcenter_client,
            vmSize=vmSize,
            nics=nics,
            datacenter=datacenter,
            createPublicIP=False,
            projectId=projectId,
            unconditional_overwrite=overwrite,
            power_on=power_on,
            volume_level_restore=1,
            client_name=proxy_client,
            in_place=False,
            copy_precedence=copy_precedence
        )

        request_json = self._prepare_fullvm_restore_json(restore_option)
        request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
            &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;projectId&#39;] = projectId
        request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
            &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;newName&#39;] = vm_to_restore[0].lower().replace(&#34;_&#34;,
                                                                                                                   &#34;&#34;)
        disk_new_names = request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
            &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;disks&#39;]
        for each in range(0, len(disk_new_names)):
            request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
                &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;disks&#39;][each][&#39;newName&#39;] = &#34;&#34;
        return self._process_restore_response(request_json)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient">VirtualServerSubclient</a></li>
<li><a title="cvpysdk.subclient.Subclient" href="../../subclient.html#cvpysdk.subclient.Subclient">Subclient</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.add_revert_option"><code class="name flex">
<span>def <span class="ident">add_revert_option</span></span>(<span>self, request_json, revert)</span>
</code></dt>
<dd>
<div class="desc"><p>Add revert in restore json</p>
<h2 id="args">Args</h2>
<p>request_json
(dict)
:
restore dict</p>
<p>revert
(bool)
:
revert option</p>
<h2 id="returns">Returns</h2>
<p>request_json
(dict)
:
restore dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L84-L100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_revert_option(self, request_json, revert):
    &#34;&#34;&#34;
    Add revert in restore json

    Args:

        request_json            (dict)  :       restore dict

        revert                  (bool)  :       revert option

    Returns:
        request_json            (dict)  :       restore dict

    &#34;&#34;&#34;
    if revert:
        request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;commonOptions&#39;][&#39;revert&#39;] = True
    return request_json</code></pre>
</details>
</dd>
<dt id="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.attach_disk_restore"><code class="name flex">
<span>def <span class="ident">attach_disk_restore</span></span>(<span>self, vm_name, vcenter, esx=None, datastore=None, proxy_client=None, copy_precedence=0, media_agent=None, snap_proxy=None, disk_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Attaches the Disks to the provided vm</p>
<h2 id="args">Args</h2>
<p>vm_name
(str)
&ndash;
Name of the VM added in subclient content
whose
disk is selected for restore</p>
<p>vcenter
(dict)
&ndash;
Dictinoary of vcenter, username and creds</p>
<p>esx
(str)
&ndash;
Esx host where the vm resides</p>
<p>datastore
(string)
&ndash;
Datastore where disks will be restoed to
default: None</p>
<p>proxy_client
(str)
&ndash;
Destination proxy client to be used
default: None</p>
<p>copy_precedence
(int)
&ndash;
SP copy precedence from which browse has to
be performed</p>
<p>media_agent
(str)
&ndash; MA needs to use for disk browse
default :Storage policy MA</p>
<p>snap_proxy
(str)
&ndash; proxy need to be used for disk
restores from snap
default :proxy in instance or subclient</p>
<p>disk_name
(str)
&ndash;
Prefix of the disk name to be attached
defaul: None</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Job class for this restore job</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if inputs are not passed in proper expected format</p>
<pre><code>if response is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L499-L610" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def attach_disk_restore(self,
                        vm_name,
                        vcenter,
                        esx=None,
                        datastore=None,
                        proxy_client=None,
                        copy_precedence=0,
                        media_agent=None,
                        snap_proxy=None,
                        disk_name=None):

    &#34;&#34;&#34;Attaches the Disks to the provided vm

        Args:
            vm_name             (str)    --  Name of the VM added in subclient content
                                                    whose  disk is selected for restore

            vcenter             (dict)          --  Dictinoary of vcenter, username and creds

            esx                 (str)    --  Esx host where the vm resides

            datastore               (string)    --  Datastore where disks will be restoed to
                                                    default: None

            proxy_client        (str)    --  Destination proxy client to be used
                                                    default: None

            copy_precedence            (int)    --  SP copy precedence from which browse has to
                                                     be performed

            media_agent                 (str)   -- MA needs to use for disk browse
                                                    default :Storage policy MA

            snap_proxy                   (str)   -- proxy need to be used for disk
                                                restores from snap
                                               default :proxy in instance or subclient

            disk_name                    (str)  --  Prefix of the disk name to be attached
                                                    defaul: None

        Returns:
            object - instance of the Job class for this restore job

        Raises:
            SDKException:
                if inputs are not passed in proper expected format

                if response is empty

                if response is not success
    &#34;&#34;&#34;

    vm_names, vm_ids = self._get_vm_ids_and_names_dict_from_browse()
    _attach_disk_restore_option = {}

    disk_extn = &#39;.vmdk&#39;
    if not disk_name:
        disk_name = []
    else:
        disk_extn = self._get_disk_extension(disk_name)

    # check if inputs are correct
    if not (isinstance(vm_name, str) and
            isinstance(disk_name, list) and
            disk_extn == &#39;.vmdk&#39;):
        raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

    if copy_precedence:
        _attach_disk_restore_option[&#39;copy_precedence_applicable&#39;] = True

    # fetching all disks from the vm
    disk_list, disk_info_dict = self.disk_level_browse(
        &#34;\\&#34; + vm_ids[vm_name])

    if not disk_name:  # if disk names are not provided, restore all vmdk disks
        for each_disk_path in disk_list:
            disk_name.append(disk_info_dict[each_disk_path][&#39;snap_display_name&#39;])

    else:  # else, check if the given VM has a disk with the list of disks in disk_name.
        for each_disk in disk_name:
            each_disk_path = &#34;\\&#34; + str(vm_name) + &#34;\\&#34; + each_disk
            if each_disk_path not in disk_list:
                raise SDKException(&#39;Subclient&#39;, &#39;111&#39;)

    if proxy_client is not None:
        _attach_disk_restore_option[&#39;client&#39;] = proxy_client
    else:
        _attach_disk_restore_option[&#39;client&#39;] = self._backupset_object._instance_object.co_ordinator

    # set Source item List
    src_item_list = []
    for each_disk in disk_name:
        src_item_list.append(&#34;\\&#34; + vm_ids[vm_name] + &#34;\\&#34; + each_disk.split(&#34;\\&#34;)[-1])

    _attach_disk_restore_option[&#39;paths&#39;] = src_item_list

    self._set_restore_inputs(
        _attach_disk_restore_option,
        in_place=True,
        copy_precedence=copy_precedence,
        vm_to_restore=vm_name,
        esxHost=vcenter[&#39;vcenter&#39;],
        userName=vcenter[&#39;user&#39;],
        password=vcenter[&#39;password&#39;],
        esx=esx,
        paths=src_item_list,
        datastore=datastore,
        volume_level_restore=6
    )

    request_json = self._prepare_attach_disk_restore_json(_attach_disk_restore_option)
    return self._process_restore_response(request_json)</code></pre>
</details>
</dd>
<dt id="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.create_blr_replication_pair"><code class="name flex">
<span>def <span class="ident">create_blr_replication_pair</span></span>(<span>self, *, target, vms, plan_name, rpstore=None, granular_options=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="args">Args</h2>
<p>target
(VirtualMachinePolicy): an instance of
VirtualMachinePolicy which is the target</p>
<p>vms
(List)
: List of VMs to be replicated</p>
<p>plan_name (str)
: Name of the plan</p>
<p>rpstore (str)
: Name of the RPStore.
default : None. If name of the RPStore is given, granular mode is chosen else Live mode</p>
<p>granular_options(dict)
: Dict which contains granular recovery options</p>
<pre><code>Example:
    {
        "ccrpInterval": 300,
        "acrpInterval": 0,
        "maxRpInterval": 21600,
        "rpMergeDelay": 172800,
        "rpRetention": 604800,
        "maxRpStoreOfflineTime": 0,
        "useOffPeakSchedule": 0,
    }
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L834-L902" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def create_blr_replication_pair(self, *, target, vms, plan_name, rpstore=None, granular_options=None):
    &#34;&#34;&#34;

    Args:
        target  (VirtualMachinePolicy): an instance of  VirtualMachinePolicy which is the target

        vms     (List)                : List of VMs to be replicated

        plan_name (str)               : Name of the plan

        rpstore (str)                 : Name of the RPStore.
            default : None. If name of the RPStore is given, granular mode is chosen else Live mode

        granular_options(dict)        : Dict which contains granular recovery options

            Example:
                {
                    &#34;ccrpInterval&#34;: 300,
                    &#34;acrpInterval&#34;: 0,
                    &#34;maxRpInterval&#34;: 21600,
                    &#34;rpMergeDelay&#34;: 172800,
                    &#34;rpRetention&#34;: 604800,
                    &#34;maxRpStoreOfflineTime&#34;: 0,
                    &#34;useOffPeakSchedule&#34;: 0,
                }
    &#34;&#34;&#34;

    try:
        assert isinstance(target, VirtualMachinePolicy) is True
    except AssertionError:
        raise TypeError(&#34;Expected an instance of VirtualMachinePolicy&#34;)
    if rpstore and granular_options:
        try:
            assert granular_options[&#34;rpRetention&#34;] &gt; granular_options[&#34;rpMergeDelay&#34;]
            assert granular_options[&#34;rpRetention&#34;] &gt; granular_options[&#34;maxRpInterval&#34;]
        except AssertionError:
            ValueError(&#34;rpRetention value must be greater than rpMergeDelay and maxRpInterval&#34;)

    restore_option = dict()
    restore_option.update(granular_options)
    for vm in vms:
        self._set_restore_inputs(
            restore_option,
            paths=[],
            in_place=False,
            target_id=target.vm_policy_id,
            target_name=target.vm_policy_name,
            vcenter_client=target.properties()[&#34;destinationHyperV&#34;][&#34;clientName&#34;],
            datastore=target.properties()[&#34;dataStores&#34;][0][&#34;dataStoreName&#34;],
            esx_host=target.properties()[&#34;esxServers&#34;][0][&#34;esxServerName&#34;],
            vm_to_restore=[vm],
            volume_level_restore=1,
            block_level=True,
            new_name=target.properties()[&#34;vmNameEditString&#34;],
            prefix=bool(target.properties()[&#34;vmNameEditType&#34;] == 1),
            plan_name=plan_name,
            source_network=target.properties()[&#34;networkList&#34;][0][&#34;sourceNetwork&#34;],
            destination_network=target.properties()[&#34;networkList&#34;][0][&#34;destinationNetwork&#34;]

        )
        if isinstance(rpstore, RPStore):
            restore_option[&#34;recovery_type&#34;] = 4
            restore_option[&#34;rpstore_name&#34;] = rpstore.rpstore_name
            restore_option[&#34;rpstore_id&#34;] = rpstore.rpstore_id

        response = self._commcell_object.execute_qcommand(&#34;qoperation execute&#34;,
                                                          self._prepare_blr_xml(restore_option))
        if response.json() != {&#39;errorMessage&#39;: &#39;&#39;, &#39;errorCode&#39;: 0}:
            raise SDKException(&#34;Subclient&#34;, 102, response.json()[&#34;errorMessage&#34;])</code></pre>
</details>
</dd>
<dt id="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.disk_restore"><code class="name flex">
<span>def <span class="ident">disk_restore</span></span>(<span>self, vm_name, destination_path, disk_name=None, proxy_client=None, copy_precedence=0, convert_to=None, media_agent=None, snap_proxy=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Restores the disk specified in the input paths list to the same location</p>
<h2 id="args">Args</h2>
<p>vm_name
(str)
&ndash;
Name of the VM added in subclient content
whose
disk is selected for restore</p>
<p>destination_path
(str)
&ndash;
Staging (destination) path to restore the
disk.</p>
<p>disk_name
(list)
&ndash;
name of the disk which has to be restored
(only vmdk files permitted - enter full
name of the disk)
default: None</p>
<p>proxy_client
(str)
&ndash;
Destination proxy client to be used
default: None</p>
<p>copy_precedence
(int)
&ndash;
SP copy precedence from which browse has to
be performed</p>
<p>convert_to
(str)
&ndash;
disk format for the restored disk
(applicable only when the vmdk disk is
selected for restore). Allowed values are
"VHDX" or "VHD"
default: None</p>
<p>media_agent
(str)
&ndash; MA needs to use for disk browse
default :Storage policy MA</p>
<p>snap_proxy
(str)
&ndash; proxy need to be used for disk
restores from snap
default :proxy in instance or subclient</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Job class for this restore job</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if inputs are not passed in proper expected format</p>
<pre><code>if response is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L370-L497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def disk_restore(self,
                 vm_name,
                 destination_path,
                 disk_name=None,
                 proxy_client=None,
                 copy_precedence=0,
                 convert_to=None,
                 media_agent=None,
                 snap_proxy=None):
    &#34;&#34;&#34;Restores the disk specified in the input paths list to the same location

        Args:
            vm_name             (str)    --  Name of the VM added in subclient content
                                                    whose  disk is selected for restore

            destination_path        (str)    --  Staging (destination) path to restore the
                                                    disk.

            disk_name                 (list)    --  name of the disk which has to be restored
                                                    (only vmdk files permitted - enter full
                                                    name of the disk)
                                                    default: None

            proxy_client        (str)    --  Destination proxy client to be used
                                                    default: None

            copy_precedence            (int)    --  SP copy precedence from which browse has to
                                                     be performed

            convert_to          (str)    --  disk format for the restored disk
                                                    (applicable only when the vmdk disk is
                                                    selected for restore). Allowed values are
                                                    &#34;VHDX&#34; or &#34;VHD&#34;
                                                    default: None

            media_agent         (str)   -- MA needs to use for disk browse
                default :Storage policy MA

            snap_proxy          (str)   -- proxy need to be used for disk
                                                restores from snap
                default :proxy in instance or subclient
        Returns:
            object - instance of the Job class for this restore job

        Raises:
            SDKException:
                if inputs are not passed in proper expected format

                if response is empty

                if response is not success
    &#34;&#34;&#34;

    vm_names, vm_ids = self._get_vm_ids_and_names_dict_from_browse()
    _disk_restore_option = {}

    disk_extn = &#39;.vmdk&#39;
    if not disk_name:
        disk_name = []
    else:
        disk_extn = self._get_disk_extension(disk_name)

    # check if inputs are correct
    if not (isinstance(vm_name, str) and
            isinstance(destination_path, str) and
            isinstance(disk_name, list) and
            disk_extn == &#39;.vmdk&#39;):
        raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

    if convert_to is not None:
        convert_to = convert_to.lower()
        if convert_to not in [&#39;vhdx&#39;, &#39;vhd&#39;]:
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

    if copy_precedence:
        _disk_restore_option[&#39;copy_precedence_applicable&#39;] = True

    # fetching all disks from the vm
    disk_list, disk_info_dict = self.disk_level_browse(
        &#34;\\&#34; + vm_ids[vm_name])

    if not disk_name:  # if disk names are not provided, restore all vmdk disks
        for each_disk_path in disk_list:
            disk_name.append(each_disk_path.split(&#39;\\&#39;)[-1])

    else:  # else, check if the given VM has a disk with the list of disks in disk_name.
        for each_disk in disk_name:
            each_disk_path = &#34;\\&#34; + str(vm_name) + &#34;\\&#34; + each_disk
            if each_disk_path not in disk_list:
                raise SDKException(&#39;Subclient&#39;, &#39;111&#39;)

    # if conversion option is given
    if convert_to is not None:
        dest_disk_dict = {
            &#39;VHD_DYNAMIC&#39;: 13,
            &#39;VHDX_DYNAMIC&#39;: 21
        }
        vol_restore, dest_disk = self._get_conversion_disk_Type(&#39;vmdk&#39;, convert_to)
        _disk_restore_option[&#34;destination_disktype&#34;] = dest_disk_dict[dest_disk]
        _disk_restore_option[&#34;volume_level_restore&#34;] = 4
    else:
        _disk_restore_option[&#34;volume_level_restore&#34;] = 3

    _disk_restore_option[&#34;destination_vendor&#34;] = \
        self._backupset_object._instance_object._vendor_id

    if proxy_client is not None:
        _disk_restore_option[&#39;client&#39;] = proxy_client
    else:
        _disk_restore_option[&#39;client&#39;] = self._backupset_object._instance_object.co_ordinator

    # set Source item List
    src_item_list = []
    for each_disk in disk_name:
        src_item_list.append(&#34;\\&#34; + vm_ids[vm_name] + &#34;\\&#34; + each_disk.split(&#34;\\&#34;)[-1])

    _disk_restore_option[&#39;paths&#39;] = src_item_list

    self._set_restore_inputs(
        _disk_restore_option,
        in_place=False,
        copy_precedence=copy_precedence,
        destination_path=destination_path,
        paths=src_item_list
    )

    request_json = self._prepare_disk_restore_json(_disk_restore_option)
    return self._process_restore_response(request_json)</code></pre>
</details>
</dd>
<dt id="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_conversion_azurerm"><code class="name flex">
<span>def <span class="ident">full_vm_conversion_azurerm</span></span>(<span>self, azure_client, vm_to_restore=None, resource_group=None, storage_account=None, datacenter=None, proxy_client=None, overwrite=True, power_on=True, instance_size=None, public_ip=False, restore_as_managed=False, copy_precedence=0, disk_type=None, restore_option=None, networkDisplayName=None, networkrsg=None, destsubid=None, subnetId=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This converts the Hyperv VM to AzureRM</p>
<h2 id="args">Args</h2>
<pre><code>vm_to_restore          (dict):     dict containing the VM name(s) to restore as
                                   keys and the new VM name(s) as their values.
                                   Input empty string for default VM name for
                                   restored VM.
                                   default: {}

azure_client    (str):      name of the AzureRM client
                                   where the VM should be
                                   restored.

resource_group   (str):      destination Resource group
                                    in the AzureRM

storage_account  (str):    storage account where the
                                  restored VM should be located
                                  in AzureRM

overwrite              (bool):    overwrite the existing VM
                                  default: True

power_on               (bool):    power on the  restored VM
                                  default: True

instance_size    (str):    Instance Size of restored VM

public_ip              (bool):    If True, creates the Public IP of
                                  restored VM

restore_as_managed     (bool):    If True, restore as Managed VM in Azure

copy_precedence         (int):    copy precedence value
                                  default: 0

proxy_client      (str):   destination proxy client

networkDisplayName(str):   destination network display name

networkrsg        (str):   destination network display name's security group

destsubid         (str):   destination subscription id

subnetId          (str):   destination subet id
</code></pre>
<p>Returns:
object - instance of the Job class for this restore job</p>
<p>Raises:
SDKException:
if inputs are not of correct type as per definition</p>
<pre><code>    if failed to initialize job

    if response is empty

    if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L612-L736" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def full_vm_conversion_azurerm(
        self,
        azure_client,
        vm_to_restore=None,
        resource_group=None,
        storage_account=None,
        datacenter=None,
        proxy_client=None,
        overwrite=True,
        power_on=True,
        instance_size=None,
        public_ip=False,
        restore_as_managed=False,
        copy_precedence=0,
        disk_type=None,
        restore_option=None,
        networkDisplayName=None,
        networkrsg=None,
        destsubid=None,
        subnetId=None):
    &#34;&#34;&#34;
            This converts the Hyperv VM to AzureRM
            Args:
                    vm_to_restore          (dict):     dict containing the VM name(s) to restore as
                                                       keys and the new VM name(s) as their values.
                                                       Input empty string for default VM name for
                                                       restored VM.
                                                       default: {}

                    azure_client    (str):      name of the AzureRM client
                                                       where the VM should be
                                                       restored.

                    resource_group   (str):      destination Resource group
                                                        in the AzureRM

                    storage_account  (str):    storage account where the
                                                      restored VM should be located
                                                      in AzureRM

                    overwrite              (bool):    overwrite the existing VM
                                                      default: True

                    power_on               (bool):    power on the  restored VM
                                                      default: True

                    instance_size    (str):    Instance Size of restored VM

                    public_ip              (bool):    If True, creates the Public IP of
                                                      restored VM

                    restore_as_managed     (bool):    If True, restore as Managed VM in Azure

                    copy_precedence         (int):    copy precedence value
                                                      default: 0

                    proxy_client      (str):   destination proxy client

                    networkDisplayName(str):   destination network display name

                    networkrsg        (str):   destination network display name&#39;s security group

                    destsubid         (str):   destination subscription id

                    subnetId          (str):   destination subet id



                Returns:
                    object - instance of the Job class for this restore job

                Raises:
                    SDKException:
                        if inputs are not of correct type as per definition

                        if failed to initialize job

                        if response is empty

                        if response is not success

    &#34;&#34;&#34;
    if restore_option is None:
        restore_option = {}

    if vm_to_restore and not isinstance(vm_to_restore, str):
        raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

    if not isinstance(vm_to_restore, list):
        vm_to_restore = [vm_to_restore]
    # check mandatory input parameters are correct
    if not isinstance(azure_client, str):
        raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

    subclient = self._set_vm_conversion_defaults(azure_client, restore_option)
    instance = subclient._backupset_object._instance_object
    if proxy_client is None:
        proxy_client = instance.server_host_name[0]

    self._set_restore_inputs(
        restore_option,
        in_place=False,
        vcenter_client=azure_client,
        datastore=storage_account,
        esx_host=resource_group,
        datacenter=datacenter,
        unconditional_overwrite=overwrite,
        client_name=proxy_client,
        power_on=power_on,
        vm_to_restore=self._set_vm_to_restore(vm_to_restore),
        copy_precedence=copy_precedence,
        createPublicIP=public_ip,
        restoreAsManagedVM=restore_as_managed,
        instanceSize=instance_size,
        volume_level_restore=1,
        destination_instance=instance.instance_name,
        backupset_client_name=instance._agent_object._client_object.client_name,
        networkDisplayName=networkDisplayName,
        networkrsg=networkrsg,
        destsubid=destsubid,
        subnetId=subnetId
    )

    request_json = self._prepare_fullvm_restore_json(restore_option)
    return self._process_restore_response(request_json)</code></pre>
</details>
</dd>
<dt id="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_conversion_googlecloud"><code class="name flex">
<span>def <span class="ident">full_vm_conversion_googlecloud</span></span>(<span>self, google_cloud_client, vm_to_restore=None, esx_host=None, vmSize=None, nics=None, datacenter=None, projectId=None, overwrite=True, power_on=True, proxy_client=None, vcenter_client=None, esx_server=None, copy_precedence=0, restore_option=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This converts the VMware to Google Cloud</p>
<h2 id="args">Args</h2>
<pre><code>vm_to_restore          (list):     provide the VM names to restore

google_cloud_client    (str):      name of the Google Cloud client
                                   where the VM should be
                                   restored.

esx_host               (str): Zone of the restored VM in Google Cloud

vmSize                 (str): vmSize of the restoed VM

overwrite              (bool):    overwrite the existing VM
                                  default: True

power_on               (bool):    power on the  restored VM
                                  default: True

vcenter_client    (str)    --  name of the vcenter client where the VM
                      should be restored.

copy_precedence         (int):    copy precedence value
                                  default: 0

proxy_client      (str):   destination proxy client

esx_server        (str):    Name of the destination virtualization Client

nics              (str):   Network Configurations of the VM

datacenter        (str):   Project ID of the restored VM

projectId         (str):   project ID where the new VM has to be created
</code></pre>
<p>Returns:
object - instance of the Job class for this restore job</p>
<p>Raises:
SDKException:
if inputs are not of correct type as per definition</p>
<pre><code>    if failed to initialize job

    if response is empty

    if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L904-L1016" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def full_vm_conversion_googlecloud(
        self,
        google_cloud_client,
        vm_to_restore=None,
        esx_host=None,
        vmSize=None,
        nics=None,
        datacenter=None,
        projectId=None,
        overwrite=True,
        power_on=True,
        proxy_client=None,
        vcenter_client=None,
        esx_server=None,
        copy_precedence=0,
        restore_option=None):

    &#34;&#34;&#34;
                    This converts the VMware to Google Cloud
                    Args:
                            vm_to_restore          (list):     provide the VM names to restore

                            google_cloud_client    (str):      name of the Google Cloud client
                                                               where the VM should be
                                                               restored.

                            esx_host               (str): Zone of the restored VM in Google Cloud

                            vmSize                 (str): vmSize of the restoed VM

                            overwrite              (bool):    overwrite the existing VM
                                                              default: True

                            power_on               (bool):    power on the  restored VM
                                                              default: True

                            vcenter_client    (str)    --  name of the vcenter client where the VM
                                                  should be restored.

                            copy_precedence         (int):    copy precedence value
                                                              default: 0

                            proxy_client      (str):   destination proxy client

                            esx_server        (str):    Name of the destination virtualization Client

                            nics              (str):   Network Configurations of the VM

                            datacenter        (str):   Project ID of the restored VM

                            projectId         (str):   project ID where the new VM has to be created

                        Returns:
                            object - instance of the Job class for this restore job

                        Raises:
                            SDKException:
                                if inputs are not of correct type as per definition

                                if failed to initialize job

                                if response is empty

                                if response is not success

    &#34;&#34;&#34;

    if restore_option is None:
        restore_option = {}

    # check mandatory input parameters are correct
    if not isinstance(google_cloud_client, str):
        raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

    subclient = self._set_vm_conversion_defaults(google_cloud_client, restore_option)
    instance = subclient._backupset_object._instance_object
    if proxy_client is None:
        proxy_client = instance.server_host_name[0]

    if vm_to_restore is None:
        vm_to_restore = self._set_vm_to_restore(vm_to_restore)

    self._set_restore_inputs(
        restore_option,
        vm_to_restore=vm_to_restore,
        esx_host=esx_host,
        esx_server=esx_server,
        vcenter_client=vcenter_client,
        vmSize=vmSize,
        nics=nics,
        datacenter=datacenter,
        createPublicIP=False,
        projectId=projectId,
        unconditional_overwrite=overwrite,
        power_on=power_on,
        volume_level_restore=1,
        client_name=proxy_client,
        in_place=False,
        copy_precedence=copy_precedence
    )

    request_json = self._prepare_fullvm_restore_json(restore_option)
    request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
        &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;projectId&#39;] = projectId
    request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
        &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;newName&#39;] = vm_to_restore[0].lower().replace(&#34;_&#34;,
                                                                                                               &#34;&#34;)
    disk_new_names = request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
        &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;disks&#39;]
    for each in range(0, len(disk_new_names)):
        request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][
            &#39;diskLevelVMRestoreOption&#39;][&#39;advancedRestoreOptions&#39;][0][&#39;disks&#39;][each][&#39;newName&#39;] = &#34;&#34;
    return self._process_restore_response(request_json)</code></pre>
</details>
</dd>
<dt id="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_conversion_hyperv"><code class="name flex">
<span>def <span class="ident">full_vm_conversion_hyperv</span></span>(<span>self, hyperv_client, vm_to_restore=None, DestinationPath=None, proxy_client=None, overwrite=True, power_on=True, copy_precedence=0, destination_network=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This converts the AzureRM to Hyper-v VM</p>
<h2 id="args">Args</h2>
<p>hyperv_client(str):
name of the hyper-V client
where the VM should restored.</p>
<p>vm_to_restore(dict):
dict containing the VM name(s) to restore as
keys and the new VM name(s) as their values.
Input empty string for default VM name for
restored VM.
default: {}</p>
<p>DestinationPath
(str): DestinationPath
in the Hyper-V client</p>
<p>proxy_client(str):
destination proxy client</p>
<p>overwrite
(bool):
overwrite the existing VM
default: True</p>
<p>power_on
(bool):
power on the
restored VM
default: True</p>
<p>copy_precedence
(int):
copy precedence value
default: 0</p>
<p>Destination_network
(str):
Destination network
in the Hyper-V client</p>
<p>Returns:
object - instance of the Job class for this restore job</p>
<p>Raises:
SDKException:
if inputs are not of correct type as per definition</p>
<pre><code>    if failed to initialize job

    if response is empty

    if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L739-L832" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def full_vm_conversion_hyperv(
        self,
        hyperv_client,
        vm_to_restore=None,
        DestinationPath=None,
        proxy_client=None,
        overwrite=True,
        power_on=True,
        copy_precedence=0,
        destination_network=None):
    &#34;&#34;&#34;
            This converts the AzureRM to Hyper-v VM
            Args:

                hyperv_client(str):  name of the hyper-V client
                                                where the VM should restored.

                vm_to_restore(dict):    dict containing the VM name(s) to restore as
                                            keys and the new VM name(s) as their values.
                                            Input empty string for default VM name for
                                            restored VM.
                                            default: {}

                DestinationPath   (str): DestinationPath
                                                    in the Hyper-V client

                proxy_client(str):   destination proxy client

                overwrite   (bool):    overwrite the existing VM
                                            default: True

                power_on  (bool):    power on the  restored VM
                                        default: True

                copy_precedence   (int):    copy precedence value
                                                default: 0

                Destination_network   (str):      Destination network
                                                        in the Hyper-V client

                Returns:
                    object - instance of the Job class for this restore job

                Raises:
                    SDKException:
                        if inputs are not of correct type as per definition

                        if failed to initialize job

                        if response is empty

                        if response is not success

    &#34;&#34;&#34;

    restore_option = {}

    # check mandatory input parameters are correct
    if not isinstance(hyperv_client, str):
        raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

    if not isinstance(vm_to_restore, list):
        vm_to_restore = [vm_to_restore]

    subclient = self._set_vm_conversion_defaults(hyperv_client, restore_option)
    instance = subclient._backupset_object._instance_object
    if proxy_client is None:
        proxy_client = instance.server_host_name[0]

    self._set_restore_inputs(
        restore_option,
        in_place=False,
        vcenter_client=hyperv_client,
        unconditional_overwrite=overwrite,
        client_name=proxy_client,
        DestinationPath=DestinationPath,
        power_on=power_on,
        vm_to_restore=vm_to_restore,
        copy_precedence=copy_precedence,
        datastore=DestinationPath,
        name=vm_to_restore,
        destination_network=destination_network,
        volume_level_restore=1,
        destination_instance=instance.instance_name,
        backupset_client_name=instance._agent_object._client_object.client_name
    )

    request_json = self._prepare_fullvm_restore_json(restore_option)
    disk_options = request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;virtualServerRstOption&#39;][&#39;diskLevelVMRestoreOption&#39;]
    for disk_info in disk_options[&#39;advancedRestoreOptions&#39;][0][&#39;disks&#39;]:
        disk_info[&#39;newName&#39;] = &#39;&#39;
    request_json[&#39;taskInfo&#39;][&#39;subTasks&#39;][0][&#39;options&#39;][&#39;restoreOptions&#39;][&#39;volumeRstOption&#39;][&#39;volumeLevelRestoreType&#39;] = 1

    return self._process_restore_response(request_json)</code></pre>
</details>
</dd>
<dt id="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_restore_in_place"><code class="name flex">
<span>def <span class="ident">full_vm_restore_in_place</span></span>(<span>self, vm_to_restore=None, overwrite=True, power_on=True, copy_precedence=0, disk_option='Original', transport_mode='Auto', proxy_client=None, to_time=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Restores the FULL Virtual machine specified in the input list
to the location same as the actual location of the VM in VCenter.</p>
<h2 id="args">Args</h2>
<p>vm_to_restore
(list)
&ndash;
provide the VM name to restore
default: None</p>
<p>overwrite
(bool)
&ndash;
overwrite the existing VM
default: True</p>
<p>power_on
(bool)
&ndash;
power on the
restored VM
default: True</p>
<p>copy_precedence
(int)
&ndash;
copy precedence value
default: 0</p>
<p>disk_option
(str)
&ndash;
disk provisioning for the restored vm
Options for input are: 'Original',
'Thick Lazy Zero', 'Thin',
'Thick Eager Zero'
default: Original</p>
<p>transport_mode
(str)
&ndash;
transport mode to be used for
the restore.
Options for input are: 'Auto', 'SAN',
''Hot Add', NBD', 'NBD SSL'
default: Auto</p>
<p>proxy_client
(str)
&ndash;
proxy client to be used for restore
default: proxy added in subclient</p>
<p>to_time
(int)
&ndash; End time to select the job for restore
default: None</p>
<p>**kwargs
: Arbitrary keyword arguments Properties as of
full_vm_restore_in_place
eg:
media_agent
(str)
&ndash; media agent</p>
<pre><code>v2_details          (dict)       -- details for v2 subclient
                                eg: check clients.vmclient.VMClient._child_job_subclient_details

revert              (bool)      --  Revert option
</code></pre>
<h2 id="returns">Returns</h2>
<p>object - instance of the Job class for this restore job</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if inputs are not of correct type as per definition</p>
<pre><code>if failed to initialize job

if response is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L102-L210" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def full_vm_restore_in_place(
        self,
        vm_to_restore=None,
        overwrite=True,
        power_on=True,
        copy_precedence=0,
        disk_option=&#39;Original&#39;,
        transport_mode=&#39;Auto&#39;,
        proxy_client=None,
        to_time=0,
        **kwargs):
    &#34;&#34;&#34;Restores the FULL Virtual machine specified in the input list
        to the location same as the actual location of the VM in VCenter.

        Args:
            vm_to_restore         (list)        --  provide the VM name to restore
                                                    default: None

            overwrite             (bool)        --  overwrite the existing VM
                                                    default: True

            power_on              (bool)        --  power on the  restored VM
                                                    default: True

            copy_precedence       (int)         --  copy precedence value
                                                    default: 0

            disk_option           (str)  --  disk provisioning for the restored vm
                                                    Options for input are: &#39;Original&#39;,
                                                    &#39;Thick Lazy Zero&#39;, &#39;Thin&#39;,
                                                    &#39;Thick Eager Zero&#39;
                                                    default: Original

            transport_mode        (str)  --  transport mode to be used for
                                                    the restore.
                                                    Options for input are: &#39;Auto&#39;, &#39;SAN&#39;,
                                                    &#39;&#39;Hot Add&#39;, NBD&#39;, &#39;NBD SSL&#39;
                                                    default: Auto

            proxy_client          (str)  --  proxy client to be used for restore
                                                    default: proxy added in subclient

            to_time                 (int)       -- End time to select the job for restore
                                                    default: None

            **kwargs                         : Arbitrary keyword arguments Properties as of
                                                 full_vm_restore_in_place
                eg:
                media_agent         (str)   -- media agent

                v2_details          (dict)       -- details for v2 subclient
                                                eg: check clients.vmclient.VMClient._child_job_subclient_details

                revert              (bool)      --  Revert option


        Returns:
            object - instance of the Job class for this restore job

        Raises:
            SDKException:
                if inputs are not of correct type as per definition

                if failed to initialize job

                if response is empty

                if response is not success

    &#34;&#34;&#34;

    restore_option = {&#34;media_agent&#34;: kwargs.get(&#34;media_agent&#34;, None), &#34;v2_details&#34;: kwargs.get(&#34;v2_details&#34;, None),
                      &#34;revert&#34;: kwargs.get(&#34;revert&#34;, False)}

    # check input parameters are correct
    if vm_to_restore and not isinstance(vm_to_restore, str):
        raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

    disk_option_value = self._disk_option[disk_option]
    transport_mode_value = self._transport_mode[transport_mode]

    if copy_precedence:
        restore_option[&#39;copy_precedence_applicable&#39;] = True

    if proxy_client is not None:
        restore_option[&#39;client_name&#39;] = proxy_client

    if vm_to_restore and not isinstance(vm_to_restore, list):
        vm_to_restore = [vm_to_restore]
    restore_option_copy = restore_option.copy()

    # set attr for all the option in restore xml from user inputs
    self._set_restore_inputs(
        restore_option,
        vm_to_restore=self._set_vm_to_restore(vm_to_restore),
        in_place=True,
        esx_server_name=&#34;&#34;,
        volume_level_restore=1,
        unconditional_overwrite=overwrite,
        power_on=power_on,
        disk_option=disk_option_value,
        transport_mode=transport_mode_value,
        copy_precedence=copy_precedence,
        to_time=to_time
    )

    request_json = self._prepare_fullvm_restore_json(restore_option)
    request_json = self.add_revert_option(request_json, restore_option.get(&#39;revert&#39;, False))
    return self._process_restore_response(request_json)</code></pre>
</details>
</dd>
<dt id="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_restore_out_of_place"><code class="name flex">
<span>def <span class="ident">full_vm_restore_out_of_place</span></span>(<span>self, vm_to_restore=None, restored_vm_name=None, vcenter_client=None, esx_host=None, datastore=None, overwrite=True, power_on=True, copy_precedence=0, disk_option='Original', transport_mode='Auto', proxy_client=None, to_time=0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Restores the FULL Virtual machine specified in the input list
to the provided vcenter client along with the ESX and the datastores.
If the provided client name is none then it restores the Full Virtual
Machine to the source client and corresponding ESX and datastore.</p>
<h2 id="args">Args</h2>
<p>vm_to_restore
(str)
&ndash;
VM that is to be restored</p>
<p>restored_vm_name
(str)
&ndash;
new name of vm. If nothing is passed,
'del' is appended to the original vm name</p>
<p>vcenter_client
(str)
&ndash;
name of the vcenter client where the VM
should be restored.</p>
<p>esx_host
(str)
&ndash;
destination esx host. Restores to the source
VM esx if this value is not specified</p>
<p>datastore
(str)
&ndash;
datastore where the restored VM should be
located. Restores to the source VM datastore
if this value is not specified</p>
<p>overwrite
(bool)
&ndash;
overwrite the existing VM
default: True</p>
<p>power_on
(bool)
&ndash;
power on the
restored VM
default: True</p>
<p>copy_precedence
(int)
&ndash;
copy precedence value
default: 0</p>
<p>disk_option
(str)
&ndash;
disk provisioning for the
restored vm
Options for input are: 'Original',
'Thick Lazy Zero', 'Thin', 'Thick Eager Zero'
default: 'Original'</p>
<p>transport_mode
(str)
&ndash;
transport mode to be used for the restore.
Options for input are: 'Auto', 'SAN',
'Hot Add', 'NBD', 'NBD SSL'
default: Auto</p>
<p>proxy_client
(str)
&ndash;
destination proxy client</p>
<p>to_time
(Int)
&ndash;
End time to select the job for restore
default: None</p>
<p>**kwargs
: Arbitrary keyword arguments Properties as of
full_vm_restore_out_of_place
eg:
source_ip
(str)
&ndash;
IP of the source VM</p>
<pre><code>destination_ip      (str)    --  IP of the destination VM

destComputerName  (str)    --  Hostname of the restored vm

source_subnet  (str)    --  subnet of the source vm

source_gateway  (str)    --  gateway of the source vm

destination_subnet  (str)    --  subnet of the restored vm

destination_gateway  (str)    --  gateway of the restored vm

media_agent         (str)   --  media agent for restore

restore_option      (dict)     --  complete dictionary with all advanced options
    default: {}

v2_details          (dict)       -- details for v2 jobs
                                eg: check clients.vmclient.VMClient._child_job_subclient_details

revert              (bool)      --  Revert option
</code></pre>
<h2 id="returns">Returns</h2>
<p>object - instance of the Job class for this restore job</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if inputs are not of correct type as per definition</p>
<pre><code>if failed to initialize job

if response is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/72534fb602d3d7d1fc922ea1ec5a16fe4d403218/cvpysdk/subclients/virtualserver/vmware.py#L212-L368" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def full_vm_restore_out_of_place(
        self,
        vm_to_restore=None,
        restored_vm_name=None,
        vcenter_client=None,
        esx_host=None,
        datastore=None,
        overwrite=True,
        power_on=True,
        copy_precedence=0,
        disk_option=&#39;Original&#39;,
        transport_mode=&#39;Auto&#39;,
        proxy_client=None,
        to_time=0,
        **kwargs
):
    &#34;&#34;&#34;Restores the FULL Virtual machine specified in the input list
        to the provided vcenter client along with the ESX and the datastores.
        If the provided client name is none then it restores the Full Virtual
        Machine to the source client and corresponding ESX and datastore.

        Args:
            vm_to_restore            (str)    --  VM that is to be restored

            restored_vm_name         (str)    --  new name of vm. If nothing is passed,
                                                  &#39;del&#39; is appended to the original vm name

            vcenter_client    (str)    --  name of the vcenter client where the VM
                                                  should be restored.

            esx_host          (str)    --  destination esx host. Restores to the source
                                                  VM esx if this value is not specified

            datastore         (str)    --  datastore where the restored VM should be
                                                  located. Restores to the source VM datastore
                                                  if this value is not specified

            overwrite               (bool)    --  overwrite the existing VM
                                                  default: True

            power_on                (bool)    --  power on the  restored VM
                                                  default: True

            copy_precedence          (int)    --  copy precedence value
                                                  default: 0

            disk_option       (str)    --  disk provisioning for the  restored vm
                                                  Options for input are: &#39;Original&#39;,
                                                  &#39;Thick Lazy Zero&#39;, &#39;Thin&#39;, &#39;Thick Eager Zero&#39;
                                                  default: &#39;Original&#39;

            transport_mode    (str)    --  transport mode to be used for the restore.
                                                  Options for input are: &#39;Auto&#39;, &#39;SAN&#39;,
                                                  &#39;Hot Add&#39;, &#39;NBD&#39;, &#39;NBD SSL&#39;
                                                  default: Auto

            proxy_client      (str)    --  destination proxy client

            to_time             (Int)         --  End time to select the job for restore
                                                default: None

            **kwargs                         : Arbitrary keyword arguments Properties as of
                                                 full_vm_restore_out_of_place
                eg:
                source_ip           (str)    --  IP of the source VM

                destination_ip      (str)    --  IP of the destination VM

                destComputerName  (str)    --  Hostname of the restored vm

                source_subnet  (str)    --  subnet of the source vm

                source_gateway  (str)    --  gateway of the source vm

                destination_subnet  (str)    --  subnet of the restored vm

                destination_gateway  (str)    --  gateway of the restored vm

                media_agent         (str)   --  media agent for restore

                restore_option      (dict)     --  complete dictionary with all advanced options
                    default: {}

                v2_details          (dict)       -- details for v2 jobs
                                                eg: check clients.vmclient.VMClient._child_job_subclient_details

                revert              (bool)      --  Revert option


        Returns:
            object - instance of the Job class for this restore job

        Raises:
            SDKException:
                if inputs are not of correct type as per definition

                if failed to initialize job

                if response is empty

                if response is not success

    &#34;&#34;&#34;

    restore_option = {}
    extra_options = [&#39;source_ip&#39;, &#39;destination_ip&#39;, &#39;network&#39;, &#39;destComputerName&#39;,
                     &#39;source_subnet&#39;, &#39;source_gateway&#39;, &#39;destination_subnet&#39;,
                     &#39;destination_gateway&#39;, &#39;folder_path&#39;, &#39;media_agent&#39;, &#39;v2_details&#39;, &#39;revert&#39;]
    for key in extra_options:
        if key in kwargs:
            restore_option[key] = kwargs[key]
        else:
            restore_option[key] = None
    # check mandatory input parameters are correct
    if vm_to_restore and not isinstance(vm_to_restore, str):
        raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)

    if copy_precedence:
        restore_option[&#39;copy_precedence_applicable&#39;] = True

    # populating proxy client. It assumes the proxy controller added in instance
    # properties if not specified
    if proxy_client is not None:
        restore_option[&#39;client_name&#39;] = proxy_client

    if restored_vm_name:
        if not (isinstance(vm_to_restore, str) or
                isinstance(restored_vm_name, str)):
            raise SDKException(&#39;Subclient&#39;, &#39;101&#39;)
        restore_option[&#39;restore_new_name&#39;] = restored_vm_name

    if vm_to_restore and not isinstance(vm_to_restore, list):
        vm_to_restore = [vm_to_restore]

    restore_option_copy = restore_option.copy()

    self._set_restore_inputs(
        restore_option,
        in_place=False,
        vcenter_client=vcenter_client,
        datastore=datastore,
        esx_host=esx_host,
        esx_server=None,
        unconditional_overwrite=overwrite,
        power_on=power_on,
        vm_to_restore=self._set_vm_to_restore(vm_to_restore),
        disk_option=self._disk_option[disk_option],
        transport_mode=self._transport_mode[transport_mode],
        copy_precedence=copy_precedence,
        volume_level_restore=1,
        source_item=[],
        to_time=to_time
    )

    request_json = self._prepare_fullvm_restore_json(restore_option)
    request_json = self.add_revert_option(request_json, restore_option.get(&#39;revert&#39;, False))
    return self._process_restore_response(request_json)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient">VirtualServerSubclient</a></b></code>:
<ul class="hlist">
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.allow_multiple_readers" href="../../subclient.html#cvpysdk.subclient.Subclient.allow_multiple_readers">allow_multiple_readers</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.amazon_defaults" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.amazon_defaults">amazon_defaults</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.backup" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.backup">backup</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.browse" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.browse">browse</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.browse_in_time" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.browse_in_time">browse_in_time</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.cbtvalue" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.cbtvalue">cbtvalue</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.content" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.content">content</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.data_readers" href="../../subclient.html#cvpysdk.subclient.Subclient.data_readers">data_readers</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.deduplication_options" href="../../subclient.html#cvpysdk.subclient.Subclient.deduplication_options">deduplication_options</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.description" href="../../subclient.html#cvpysdk.subclient.Subclient.description">description</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.disable_backup" href="../../subclient.html#cvpysdk.subclient.Subclient.disable_backup">disable_backup</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.disable_intelli_snap" href="../../subclient.html#cvpysdk.subclient.Subclient.disable_intelli_snap">disable_intelli_snap</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.disk_level_browse" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.disk_level_browse">disk_level_browse</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.disk_pattern" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.disk_pattern">disk_pattern</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.display_name" href="../../subclient.html#cvpysdk.subclient.Subclient.display_name">display_name</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.enable_backup" href="../../subclient.html#cvpysdk.subclient.Subclient.enable_backup">enable_backup</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.enable_backup_at_time" href="../../subclient.html#cvpysdk.subclient.Subclient.enable_backup_at_time">enable_backup_at_time</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.enable_intelli_snap" href="../../subclient.html#cvpysdk.subclient.Subclient.enable_intelli_snap">enable_intelli_snap</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.enable_trueup" href="../../subclient.html#cvpysdk.subclient.Subclient.enable_trueup">enable_trueup</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.enable_trueup_days" href="../../subclient.html#cvpysdk.subclient.Subclient.enable_trueup_days">enable_trueup_days</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.encryption_flag" href="../../subclient.html#cvpysdk.subclient.Subclient.encryption_flag">encryption_flag</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.exclude_from_sla" href="../../subclient.html#cvpysdk.subclient.Subclient.exclude_from_sla">exclude_from_sla</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.find" href="../../subclient.html#cvpysdk.subclient.Subclient.find">find</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.find_latest_job" href="../../subclient.html#cvpysdk.subclient.Subclient.find_latest_job">find_latest_job</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.get_ma_associated_storagepolicy" href="../../subclient.html#cvpysdk.subclient.Subclient.get_ma_associated_storagepolicy">get_ma_associated_storagepolicy</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.get_nics_from_browse" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.get_nics_from_browse">get_nics_from_browse</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.guest_file_restore" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.guest_file_restore">guest_file_restore</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.guest_files_browse" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.guest_files_browse">guest_files_browse</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.instance_proxy" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.instance_proxy">instance_proxy</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.is_backup_enabled" href="../../subclient.html#cvpysdk.subclient.Subclient.is_backup_enabled">is_backup_enabled</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.is_blocklevel_backup_enabled" href="../../subclient.html#cvpysdk.subclient.Subclient.is_blocklevel_backup_enabled">is_blocklevel_backup_enabled</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.is_default_subclient" href="../../subclient.html#cvpysdk.subclient.Subclient.is_default_subclient">is_default_subclient</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.is_intelli_snap_enabled" href="../../subclient.html#cvpysdk.subclient.Subclient.is_intelli_snap_enabled">is_intelli_snap_enabled</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.is_on_demand_subclient" href="../../subclient.html#cvpysdk.subclient.Subclient.is_on_demand_subclient">is_on_demand_subclient</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.is_trueup_enabled" href="../../subclient.html#cvpysdk.subclient.Subclient.is_trueup_enabled">is_trueup_enabled</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.last_backup_time" href="../../subclient.html#cvpysdk.subclient.Subclient.last_backup_time">last_backup_time</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.list_media" href="../../subclient.html#cvpysdk.subclient.Subclient.list_media">list_media</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.live_sync" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.live_sync">live_sync</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.metadata" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.metadata">metadata</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.name" href="../../subclient.html#cvpysdk.subclient.Subclient.name">name</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.network_agent" href="../../subclient.html#cvpysdk.subclient.Subclient.network_agent">network_agent</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.next_backup_time" href="../../subclient.html#cvpysdk.subclient.Subclient.next_backup_time">next_backup_time</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.parse_nics_xml" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.parse_nics_xml">parse_nics_xml</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.plan" href="../../subclient.html#cvpysdk.subclient.Subclient.plan">plan</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.preview_content" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.preview_content">preview_content</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.properties" href="../../subclient.html#cvpysdk.subclient.Subclient.properties">properties</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.quiesce_file_system" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.quiesce_file_system">quiesce_file_system</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.read_buffer_size" href="../../subclient.html#cvpysdk.subclient.Subclient.read_buffer_size">read_buffer_size</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.refresh" href="../../subclient.html#cvpysdk.subclient.Subclient.refresh">refresh</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.restore_in_place" href="../../subclient.html#cvpysdk.subclient.Subclient.restore_in_place">restore_in_place</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.restore_out_of_place" href="../../subclient.html#cvpysdk.subclient.Subclient.restore_out_of_place">restore_out_of_place</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.set_advanced_attach_disk_restore_options" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.set_advanced_attach_disk_restore_options">set_advanced_attach_disk_restore_options</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.set_advanced_vm_restore_options" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.set_advanced_vm_restore_options">set_advanced_vm_restore_options</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.set_backup_nodes" href="../../subclient.html#cvpysdk.subclient.Subclient.set_backup_nodes">set_backup_nodes</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.set_proxy_for_snap" href="../../subclient.html#cvpysdk.subclient.Subclient.set_proxy_for_snap">set_proxy_for_snap</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.snapshot_engine_name" href="../../subclient.html#cvpysdk.subclient.Subclient.snapshot_engine_name">snapshot_engine_name</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.software_compression" href="../../subclient.html#cvpysdk.subclient.Subclient.software_compression">software_compression</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.storage_ma" href="../../subclient.html#cvpysdk.subclient.Subclient.storage_ma">storage_ma</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.storage_ma_id" href="../../subclient.html#cvpysdk.subclient.Subclient.storage_ma_id">storage_ma_id</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.storage_policy" href="../../subclient.html#cvpysdk.subclient.Subclient.storage_policy">storage_policy</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.subclient_guid" href="../../subclient.html#cvpysdk.subclient.Subclient.subclient_guid">subclient_guid</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.subclient_id" href="../../subclient.html#cvpysdk.subclient.Subclient.subclient_id">subclient_id</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.subclient_name" href="../../subclient.html#cvpysdk.subclient.Subclient.subclient_name">subclient_name</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.subclient_proxy" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.subclient_proxy">subclient_proxy</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.unset_proxy_for_snap" href="../../subclient.html#cvpysdk.subclient.Subclient.unset_proxy_for_snap">unset_proxy_for_snap</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.update_properties" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.update_properties">update_properties</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.vm_diskfilter" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.vm_diskfilter">vm_diskfilter</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.vm_files_browse" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.vm_files_browse">vm_files_browse</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.vm_files_browse_in_time" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.vm_files_browse_in_time">vm_files_browse_in_time</a></code></li>
<li><code><a title="cvpysdk.subclients.vssubclient.VirtualServerSubclient.vm_filter" href="../vssubclient.html#cvpysdk.subclients.vssubclient.VirtualServerSubclient.vm_filter">vm_filter</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GitHub home" href="https://github.com/Commvault/cvpysdk">
<img src="https://commvault.github.io/cvpysdk/logo.png" alt="" width="100%"> Commvault Python SDK
</a> <br>
<a class="homelink" title="Go to Top Level" href="https://commvault.github.io/cvpysdk/cvpysdk/index.html"> Go to Top Level </a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cvpysdk.subclients.virtualserver" href="index.html">cvpysdk.subclients.virtualserver</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient" href="#cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient">VMWareVirtualServerSubclient</a></code></h4>
<ul class="">
<li><code><a title="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.add_revert_option" href="#cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.add_revert_option">add_revert_option</a></code></li>
<li><code><a title="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.attach_disk_restore" href="#cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.attach_disk_restore">attach_disk_restore</a></code></li>
<li><code><a title="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.create_blr_replication_pair" href="#cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.create_blr_replication_pair">create_blr_replication_pair</a></code></li>
<li><code><a title="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.disk_restore" href="#cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.disk_restore">disk_restore</a></code></li>
<li><code><a title="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_conversion_azurerm" href="#cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_conversion_azurerm">full_vm_conversion_azurerm</a></code></li>
<li><code><a title="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_conversion_googlecloud" href="#cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_conversion_googlecloud">full_vm_conversion_googlecloud</a></code></li>
<li><code><a title="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_conversion_hyperv" href="#cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_conversion_hyperv">full_vm_conversion_hyperv</a></code></li>
<li><code><a title="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_restore_in_place" href="#cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_restore_in_place">full_vm_restore_in_place</a></code></li>
<li><code><a title="cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_restore_out_of_place" href="#cvpysdk.subclients.virtualserver.vmware.VMWareVirtualServerSubclient.full_vm_restore_out_of_place">full_vm_restore_out_of_place</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>