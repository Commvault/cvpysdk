<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cvpysdk.policies.storage_policies API documentation</title>
<meta name="description" content="Main file for performing storage policy related operations on the commcell â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em;background-color:#f8f9fa}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#FE496A;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#FD0131}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<link rel="shortcut icon" type="image/x-icon" href="https://commvault.github.io/cvpysdk/favicon.ico">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cvpysdk.policies.storage_policies</code></h1>
</header>
<section id="section-intro">
<p>Main file for performing storage policy related operations on the commcell.</p>
<p>This file has all the classes related to Storage Policy operations.</p>
<p>StoragePolicies:
Class for representing all the Storage Policies associated to the commcell.</p>
<p>StoragePolicy:
Class for representing a single Storage Policy associated to the commcell.</p>
<h2 id="storagepolicies">Storagepolicies</h2>
<p><strong>init</strong>(commcell_object)
&ndash;
initialize the StoragePolicies instance for the commcell</p>
<p><strong>str</strong>()
&ndash;
returns all the storage policies associated with the commcell</p>
<p><strong>repr</strong>()
&ndash;
returns a string for the instance of the StoragePolicies class</p>
<p>_get_policies()
&ndash;
gets all the storage policies of the commcell</p>
<p>all_storage_policies()
&ndash;
returns the dict of all the storage policies on commcell</p>
<p>has_policy(policy_name)
&ndash;
checks if a storage policy exists with the given name</p>
<p>add_global_storage_policy()
&ndash;
adds a new global storage policy to the commcell</p>
<p>add()
&ndash;
adds a new storage policy to the commcell</p>
<p>add_tape_sp()
&ndash;
add new storage policy with tape library as data path</p>
<p>delete(storage_policy_name)
&ndash;
removes the specified storage policy from the commcell</p>
<p>refresh()
&ndash;
refresh the storage policies associated with the commcell</p>
<h2 id="storagepolicy">Storagepolicy</h2>
<p><strong>init</strong>(commcell_object,
storage_policy_name,
storage_policy_id)
&ndash;
initialize the instance of StoragePolicy class for
a specific storage policy of the commcell</p>
<p><strong>repr</strong>()
&ndash;
returns a string representation of the
StoragePolicy instance</p>
<p>_get_storage_policy_id()
&ndash;
gets the id of the StoragePolicy instance</p>
<p>_get_storage_policy_properties()
&ndash;
returns the properties of this storage policy</p>
<p>_get_storage_policy_advanced_properties()&ndash;
returns the advanced properties of this storage policy</p>
<p>_initialize_storage_policy_properties() &ndash;
initializes storage policy properties</p>
<p>edit_block_size_on_gdsp
&ndash;
edits the sidb block size on GDSP</p>
<p>has_copy()
&ndash;
checks if copy with given name exists</p>
<p>create_secondary_copy()
&ndash;
creates a storage policy copy</p>
<p>create_snap_copy()
&ndash;
creates snap, snapvault, snapmirror, replica
and replica mirror copies</p>
<p>create_dedupe_secondary_copy()
&ndash;
create secondary copy with dedupe enabled</p>
<p>delete_secondary_copy()
&ndash;
deletes storage policy copy</p>
<p>copies()
&ndash;
returns the storage policy copies associated with
this storage policy</p>
<p>get_copy_precedence()
&ndash;
returns the copy precedence value associated with
the copy name</p>
<p>update_snapshot_options()
&ndash;
Method for Updating Backup Copy and Snapshot
Catalog Options</p>
<p>run_backup_copy()
&ndash;
Runs the backup copy job from Commcell</p>
<p>modify_dynamic_stream_allocation()
&ndash;
modifies dsa property of storage policy</p>
<p>run_snapshot_cataloging()
&ndash;
Runs the deferred catalog job from Commcell</p>
<p>run_aux_copy()
&ndash;
starts a aux copy job for this storage policy and
returns the job object</p>
<p>refresh()
&ndash;
refresh the properties of the storage policy</p>
<p>update_transactional_ddb()
&ndash;
enable/disable transactional DDB option on a DDB</p>
<p>seal_ddb()
&ndash;
seal a DDB store</p>
<p>add_ddb_partition()
&ndash;
Adds a new DDB partition</p>
<p>move_dedupe_store()
&ndash;
Moves a deduplication store</p>
<p>run_ddb_verification()
&ndash;
Runs DDB verification job</p>
<p>run_data_verification()
&ndash;
Runs Data Verification Job</p>
<p>get_copy()
&ndash;
Returns the StoragePolicyCopy class object of the input copy</p>
<p>get_primary_copy()
&ndash;
Returns the primary copy of the storage policy</p>
<p>get_secondary_copies()
&ndash;
Returns all the secondary copies in the storage policy sorted
by copy precedence</p>
<p>delete_job()
&ndash;
Deletes a job on Storage Policy</p>
<p>mark_for_recovery()
&ndash;
Marks Deduplication store for recovery</p>
<p>run_recon()
&ndash;
Runs non-mem DB Reconstruction job</p>
<p>reassociate_all_subclients()
&ndash;
Reassociates all subclients associated to Storage Policy</p>
<p>enable_entity_extraction()
&ndash;
Enables the entity extraction for subclients associated to this policy</p>
<p>enable_content_indexing()
&ndash;
Enables the content indexing for this storage policy</p>
<p>run_content_indexing()
&ndash;
start the content indexing job for this storage policy</p>
<p>start_over()
&ndash;
performs start over operation on storage policy/gdsp</p>
<p>run_data_forecast()
&ndash; runs granular data forecast operation for given storage policy</p>
<h2 id="storagepolicycopy">Storagepolicycopy</h2>
<p><strong>init</strong>(self, commcell_object,
storage_policy_name,
copy_name, copy_id)
&ndash;
initialize the instance of StoragePolicy class for
a specific storage policy of the commcell</p>
<p><strong>repr</strong>()
&ndash;
returns a string representation of the
StoragePolicy instance</p>
<p>copy_name()
&ndash;
Gets the name of the storage policy copy</p>
<p>get_copy_id()
&ndash;
Gets the storage policy id asscoiated with the storage policy</p>
<p>get_copy_Precedence()
&ndash;
Gets the copy precendence associated with the storage policy copy</p>
<p>refresh()
&ndash;
Refresh the properties of the StoragePolicy</p>
<p>_get_request_json()
&ndash;
Gets all the storage policy copy properties</p>
<p>_get_copy_properties()
&ndash;
Gets the storage policy copy properties</p>
<p>_set_copy_properties()
&ndash;
sets the properties of this storage policy copy</p>
<p>set_copy_software_compression()
&ndash;
Sets the copy software compression setting</p>
<p>is_parallel_copy()
&ndash;
Gets the parallel copy setting on storage policy copy</p>
<p>set_parallel_copy()
&ndash;
Sets the parallel copy setting on storage policy copy</p>
<p>is_inline_copy()
&ndash;
Gets the inline copy setting on storage policy copy</p>
<p>set_inline_copy()
&ndash;
Sets the inline copy setting on storage policy copy</p>
<p>get_jobs_on_copy()
&ndash;
Fetches the Details of jobs on Storage Policy Copy</p>
<p>delete_job()
&ndash;
delete a job from storage policy copy node</p>
<p>_mark_jobs_on_copy()
&ndash;
marks job(s) for given operation on a secondary copy</p>
<p>pick_for_copy()
&ndash;
marks job(s) to be Picked for Copy to a secondary copy</p>
<p>recopy_jobs()
&ndash;
marks job(s) to be picked for ReCopying to a secondary copy</p>
<p>do_not_copy_jobs()
&ndash;
marks job(s) as Do Not Copy to a secondary copy</p>
<p>pick_jobs_for_data_verification()
&ndash;
marks job(s) on a copy to be Picked for Data Verification</p>
<p>do_not_verify_data()
&ndash;
marks job(s) on a copy to not be Picked for Data Verification</p>
<p>pick_jobs_for_backupcopy
&ndash;
marks job(skipped/unpicked) on a copy to be picked for backup copy</p>
<p>mark_jobs_bad()
&ndash;
marks job(s) on a copy as Bad</p>
<p>is_dedupe_enabled()
&ndash;
checks whether deduplication is enabled for the copy</p>
<p>set_encryption_properties()
&ndash;
configures copy encryption settings as per user input</p>
<p>set_key_management_server()
&ndash;
sets the Key Management Server to this copy</p>
<p>set_multiplexing_factor()
&ndash;
sets/unset the multiplexing factor for the storage policy copy</p>
<p>delete_datapath()
&ndash;
delete datapath from storage policy copy</p>
<p>set_default_datapath()
&ndash;
sets default data path</p>
<p>set_ddb_resiliency()
&ndash; set/unset ddb resiliency for storage policy copy</p>
<p>rotate_encryption_master_key()
&ndash; Rotates the encryption key for this copy</p>
<p>get_store_seal_frequency()
&ndash; Gets the store seal frequency for this copy</p>
<p>enable_compliance_lock()
&ndash; Sets compliance lock (wormCopy flag)</p>
<p>disable_compliance_lock()
&ndash; Unsets compliance lock (wormCopy flag)</p>
<h2 id="attributes">Attributes</h2>
<pre><code>**override_pool_retention**                 --  Returns if Override Pool Retention flag is set or not

**override_pool_retention.setter**          --  Sets/Unsets the override Pool Retention Flag

**space_optimized_auxillary_copy**          --  Returns the value of space optimized auxillary copy setting

**space_optimized_auxillary_copy.setter**   --  Sets the value of space optimized auxillary copy setting

**source_copy**                             --  Returns the source copy associated with the copy

**source_copy.setter**                      --  Sets the source copy for the copy

**store_priming**                    --  Sets the value of DDB store priming under copy dedupe properties

**ddb_resiliency**                          -- Returns whether ddb resiliency is set or not

***is_active***                             --  Returns/Sets the 'Active' Property of the Copy

***network_throttle_bandwidth***            --  Returns/Sets the value of Network Throttle Bandwidth

***is_compliance_lock_enabled***            --  Checks whether compliance lock on copy is enabled or not
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1-L4777" class="git-link">Browse git</a>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-

# --------------------------------------------------------------------------
# Copyright Commvault Systems, Inc.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# --------------------------------------------------------------------------

&#34;&#34;&#34;Main file for performing storage policy related operations on the commcell.

This file has all the classes related to Storage Policy operations.

StoragePolicies:  Class for representing all the Storage Policies associated to the commcell.

StoragePolicy:    Class for representing a single Storage Policy associated to the commcell.


StoragePolicies:
    __init__(commcell_object)    --  initialize the StoragePolicies instance for the commcell

    __str__()                    --  returns all the storage policies associated with the commcell

    __repr__()                   --  returns a string for the instance of the StoragePolicies class

    _get_policies()              --  gets all the storage policies of the commcell

    all_storage_policies()       --  returns the dict of all the storage policies on commcell

    has_policy(policy_name)      --  checks if a storage policy exists with the given name

    add_global_storage_policy()  --  adds a new global storage policy to the commcell

    add()                        --  adds a new storage policy to the commcell

    add_tape_sp()                --  add new storage policy with tape library as data path

    delete(storage_policy_name)  --  removes the specified storage policy from the commcell

    refresh()                    --  refresh the storage policies associated with the commcell


StoragePolicy:
    __init__(commcell_object,
             storage_policy_name,
             storage_policy_id)             --  initialize the instance of StoragePolicy class for
    a specific storage policy of the commcell


    __repr__()                              --  returns a string representation of the
    StoragePolicy instance

    _get_storage_policy_id()                --  gets the id of the StoragePolicy instance

    _get_storage_policy_properties()        --  returns the properties of this storage policy

    _get_storage_policy_advanced_properties()--  returns the advanced properties of this storage policy

    _initialize_storage_policy_properties() --  initializes storage policy properties

    edit_block_size_on_gdsp                 --  edits the sidb block size on GDSP

    has_copy()                              --  checks if copy with given name exists

    create_secondary_copy()                 --  creates a storage policy copy

    create_snap_copy()                      --  creates snap, snapvault, snapmirror, replica
                                                and replica mirror copies

    create_dedupe_secondary_copy()          --  create secondary copy with dedupe enabled

    delete_secondary_copy()                 --  deletes storage policy copy

    copies()                                --  returns the storage policy copies associated with
    this storage policy

    get_copy_precedence()                   --  returns the copy precedence value associated with
    the copy name

    update_snapshot_options()               --  Method for Updating Backup Copy and Snapshot
    Catalog Options

    run_backup_copy()                       --  Runs the backup copy job from Commcell

    modify_dynamic_stream_allocation()      --  modifies dsa property of storage policy

    run_snapshot_cataloging()               --  Runs the deferred catalog job from Commcell

    run_aux_copy()                          --  starts a aux copy job for this storage policy and
    returns the job object

    refresh()                               --  refresh the properties of the storage policy

    update_transactional_ddb()              --  enable/disable transactional DDB option on a DDB

    seal_ddb()                              --  seal a DDB store

    add_ddb_partition()                     --  Adds a new DDB partition

    move_dedupe_store()                     --  Moves a deduplication store

    run_ddb_verification()                  --  Runs DDB verification job

    run_data_verification()                 --  Runs Data Verification Job

    get_copy()                              --  Returns the StoragePolicyCopy class object of the input copy

    get_primary_copy()                      --  Returns the primary copy of the storage policy

    get_secondary_copies()                  --  Returns all the secondary copies in the storage policy sorted
    by copy precedence

    delete_job()                            --  Deletes a job on Storage Policy

    mark_for_recovery()                     --  Marks Deduplication store for recovery

    run_recon()                             --  Runs non-mem DB Reconstruction job

    reassociate_all_subclients()            --  Reassociates all subclients associated to Storage Policy

    enable_entity_extraction()              --  Enables the entity extraction for subclients associated to this policy

    enable_content_indexing()               --  Enables the content indexing for this storage policy

    run_content_indexing()                  --  start the content indexing job for this storage policy

    start_over()                            --  performs start over operation on storage policy/gdsp

    run_data_forecast()                     -- runs granular data forecast operation for given storage policy


StoragePolicyCopy:
    __init__(self, commcell_object,
                storage_policy_name,
                copy_name, copy_id)         --  initialize the instance of StoragePolicy class for
                                                a specific storage policy of the commcell

    __repr__()                              --  returns a string representation of the
                                                StoragePolicy instance

    copy_name()                         --  Gets the name of the storage policy copy

    get_copy_id()                                   --  Gets the storage policy id asscoiated with the storage policy

    get_copy_Precedence()                   --  Gets the copy precendence associated with the storage policy copy

    refresh()                                   --      Refresh the properties of the StoragePolicy

    _get_request_json()                     --  Gets all the storage policy copy properties

    _get_copy_properties()                      --      Gets the storage policy copy properties

    _set_copy_properties()                      --      sets the properties of this storage policy copy

    set_copy_software_compression()         --  Sets the copy software compression setting

    is_parallel_copy()                      --  Gets the parallel copy setting on storage policy copy

    set_parallel_copy()                     --  Sets the parallel copy setting on storage policy copy

    is_inline_copy()                        --  Gets the inline copy setting on storage policy copy

    set_inline_copy()                       --  Sets the inline copy setting on storage policy copy

    get_jobs_on_copy()                      --  Fetches the Details of jobs on Storage Policy Copy

    delete_job()                            --  delete a job from storage policy copy node

    _mark_jobs_on_copy()                    --  marks job(s) for given operation on a secondary copy

    pick_for_copy()                         --  marks job(s) to be Picked for Copy to a secondary copy

    recopy_jobs()                           --  marks job(s) to be picked for ReCopying to a secondary copy

    do_not_copy_jobs()                      --  marks job(s) as Do Not Copy to a secondary copy

    pick_jobs_for_data_verification()       --  marks job(s) on a copy to be Picked for Data Verification

    do_not_verify_data()                    --  marks job(s) on a copy to not be Picked for Data Verification

    pick_jobs_for_backupcopy                --  marks job(skipped/unpicked) on a copy to be picked for backup copy

    mark_jobs_bad()                         --  marks job(s) on a copy as Bad

    is_dedupe_enabled()                     --  checks whether deduplication is enabled for the copy

    set_encryption_properties()             --  configures copy encryption settings as per user input

    set_key_management_server()             --  sets the Key Management Server to this copy

    set_multiplexing_factor()               --  sets/unset the multiplexing factor for the storage policy copy

    delete_datapath()                       --  delete datapath from storage policy copy

    set_default_datapath()                  --  sets default data path

    set_ddb_resiliency()                    -- set/unset ddb resiliency for storage policy copy
    
    rotate_encryption_master_key()          -- Rotates the encryption key for this copy

    get_store_seal_frequency()              -- Gets the store seal frequency for this copy

    enable_compliance_lock()                -- Sets compliance lock (wormCopy flag)

    disable_compliance_lock()               -- Unsets compliance lock (wormCopy flag)

Attributes
----------
    **override_pool_retention**                 --  Returns if Override Pool Retention flag is set or not

    **override_pool_retention.setter**          --  Sets/Unsets the override Pool Retention Flag

    **space_optimized_auxillary_copy**          --  Returns the value of space optimized auxillary copy setting

    **space_optimized_auxillary_copy.setter**   --  Sets the value of space optimized auxillary copy setting

    **source_copy**                             --  Returns the source copy associated with the copy

    **source_copy.setter**                      --  Sets the source copy for the copy

    **store_priming**                    --  Sets the value of DDB store priming under copy dedupe properties

    **ddb_resiliency**                          -- Returns whether ddb resiliency is set or not

    ***is_active***                             --  Returns/Sets the &#39;Active&#39; Property of the Copy

    ***network_throttle_bandwidth***            --  Returns/Sets the value of Network Throttle Bandwidth

    ***is_compliance_lock_enabled***            --  Checks whether compliance lock on copy is enabled or not
&#34;&#34;&#34;

from __future__ import absolute_import
from __future__ import unicode_literals

from base64 import b64encode

from ..exception import SDKException
from ..job import Job
from ..schedules import Schedules, SchedulePattern

from ..storage import DiskLibrary
from ..storage import MediaAgent


class StoragePolicies(object):
    &#34;&#34;&#34;Class for getting all the storage policies associated with the commcell.&#34;&#34;&#34;

    def __init__(self, commcell_object):
        &#34;&#34;&#34;Initialize object of the StoragePolicies class.

            Args:
                commcell_object (object)  --  instance of the Commcell class

            Returns:
                object - instance of the StoragePolicies class
        &#34;&#34;&#34;
        self._commcell_object = commcell_object
        self._POLICY = self._commcell_object._services[&#39;STORAGE_POLICY&#39;]
        self._DELETE_POLICY =  self._commcell_object._services[&#39;DELETE_STORAGE_POLICY&#39;]
        self._policies = None
        self.refresh()

    def __str__(self):
        &#34;&#34;&#34;Representation string consisting of all storage policies of the commcell.

            Returns:
                str - string of all the storage policies associated with the commcell
        &#34;&#34;&#34;
        representation_string = &#39;{:^5}\t{:^20}\n\n&#39;.format(&#39;S. No.&#39;, &#39;Storage Policy&#39;)

        for index, policy in enumerate(self._policies):
            sub_str = &#39;{:^5}\t{:20}\n&#39;.format(index + 1, policy)
            representation_string += sub_str

        return representation_string.strip()

    def __repr__(self):
        &#34;&#34;&#34;Representation string for the instance of the Clients class.&#34;&#34;&#34;
        return &#34;StoragePolicies class instance for Commcell: &#39;{0}&#39;&#34;.format(
            self._commcell_object.commserv_name
        )

    def _get_policies(self):
        &#34;&#34;&#34;Gets all the storage policies associated to the commcell specified by commcell object.

            Returns:
                dict - consists of all storage policies of the commcell
                    {
                         &#34;storage_policy1_name&#34;: storage_policy1_id,
                         &#34;storage_policy2_name&#34;: storage_policy2_id
                    }

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;GET&#39;, self._POLICY + &#34;?getAll=TRUE&#34;)

        if flag:
            if response.json() and &#39;policies&#39; in response.json():
                policies = response.json()[&#39;policies&#39;]

                if policies == []:
                    return {}

                policies_dict = {}

                for policy in policies:
                    temp_name = policy[&#39;storagePolicyName&#39;].lower()
                    temp_id = str(policy[&#39;storagePolicyId&#39;]).lower()
                    policies_dict[temp_name] = temp_id

                return policies_dict
            else:
                return {}
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def all_storage_policies(self):
        &#34;&#34;&#34;Returns dict of all the storage policies on this commcell

            dict - consists of all storage policies of the commcell
                    {
                         &#34;storage_policy1_name&#34;: storage_policy1_id,
                         &#34;storage_policy2_name&#34;: storage_policy2_id
                    }
        &#34;&#34;&#34;
        return self._policies

    def has_policy(self, policy_name):
        &#34;&#34;&#34;Checks if a storage policy exists in the commcell with the input storage policy name.

            Args:
                policy_name (str)  --  name of the storage policy

            Returns:
                bool - boolean output whether the storage policy exists in the commcell or not

            Raises:
                SDKException:
                    if type of the storage policy name argument is not string
        &#34;&#34;&#34;
        if not isinstance(policy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        return self._policies and policy_name.lower() in self._policies

    def get(self, storage_policy_name):
        &#34;&#34;&#34;Returns a StoragePolicy object of the specified storage policy name.

            Args:
                storage_policy_name     (str)   --  name of the storage policy

            Returns:
                object - instance of the StoragePolicy class for the given policy name

            Raises:
                SDKException:
                    if type of the storage policy name argument is not string

                    if no storage policy exists with the given name
        &#34;&#34;&#34;
        if not isinstance(storage_policy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        storage_policy_name = storage_policy_name.lower()

        if self.has_policy(storage_policy_name):
            return StoragePolicy(
                self._commcell_object, storage_policy_name, self._policies[storage_policy_name]
            )
        else:
            raise SDKException(
                &#39;Storage&#39;, &#39;102&#39;, &#39;No policy exists with name: {0}&#39;.format(storage_policy_name)
            )

    def add_global_storage_policy(self,
                                  global_storage_policy_name,
                                  library,
                                  media_agent,
                                  dedup_path=None,
                                  dedup_path_media_agent=None):
        &#34;&#34;&#34;adds a global storage policy

            Args:
                global_storage_policy_name   (str)  --  name of the global storage policy which you want to add

                library                      (str)  --  name of the library which you want to be associated with your
                global storage policy

                media_agent                  (str)  --  name of the media agent which you want to be associated with
                the global storage policy

                        *enter BOTH, the dedup_path and dedup_path_media_agent if you want the deduplication
                         to be enabled.

                dedup_path                    (str) -- path of the deduplication database
                default- None

                dedup_path_media_agent:       (str) -- name of the media agent where the deduplication database
                                                       is stored
                default- None

            Returns:
                    the success message along with the name of the global storage policy if created successfully
                    else the error messages or the exceptions raised

            Raises:
                SDKException:
                        if the global_storage_policy_name,library,media_agent,dedup_path,dedup_path_media_agent
                        is not of type String

                        if response is empty

                        if response is not success

        &#34;&#34;&#34;

        if not (isinstance(global_storage_policy_name, str) and
                isinstance(library, str) and
                isinstance(media_agent, str)):
            raise SDKException(&#34;Storage&#34;, &#34;101&#34;)

        if ((dedup_path is not None and not isinstance(dedup_path, str)) or
                dedup_path_media_agent is not None and not isinstance(dedup_path_media_agent, str)):
            raise SDKException(&#34;Storage&#34;, &#34;101&#34;)

        request_json = {
            &#34;storagePolicyName&#34;: global_storage_policy_name,
            &#34;copyName&#34;: &#34;Primary_Global&#34;,
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;storagePolicyFlags&#34;: {
                    &#34;globalStoragePolicy&#34;: 1
                },
                &#34;library&#34;: {
                    &#34;libraryName&#34;: library
                },
                &#34;mediaAgent&#34;: {
                    &#34;mediaAgentName&#34;: media_agent
                },
                &#34;retentionRules&#34;: {
                    &#34;retainArchiverDataForDays&#34;: -1,
                    &#34;retainBackupDataForCycles&#34;: -1,
                    &#34;retainBackupDataForDays&#34;: -1
                }
            }
        }

        if dedup_path is not None and dedup_path_media_agent is not None:
            storage_policy_copy_info = {
                &#34;dedupeFlags&#34;: {
                    &#34;enableDASHFull&#34;: 1,
                    &#34;hostGlobalDedupStore&#34;: 1,
                    &#34;enableDeduplication&#34;: 1
                },
                &#34;storagePolicyFlags&#34;: {
                    &#34;blockLevelDedup&#34;: 1,
                    &#34;enableGlobalDeduplication&#34;: 1
                },
                &#34;DDBPartitionInfo&#34;: {
                    &#34;maInfoList&#34;: [
                        {
                            &#34;mediaAgent&#34;: {
                                &#34;mediaAgentName&#34;: dedup_path_media_agent
                            },
                            &#34;subStoreList&#34;: [
                                {
                                    &#34;diskFreeWarningThreshholdMB&#34;: 10240,
                                    &#34;diskFreeThresholdMB&#34;: 5120,
                                    &#34;accessPath&#34;: {
                                        &#34;path&#34;: dedup_path
                                    }
                                }
                            ]
                        }
                    ]
                }
            }
            request_json[&#34;storagePolicyCopyInfo&#34;].update(storage_policy_copy_info)

        # don&#39;t create dedup global storage policy if the arguments are not supplied
        elif(dedup_path or dedup_path_media_agent):
            raise SDKException(&#34;Storage&#34;, &#34;101&#34;, &#34;cannot create dedup global policy without complete arguments \n&#34;
                               &#34;supply both dedup path and dedup path media agent&#34;)

        # checking to create non dedup global storage policy
        elif(dedup_path is None and dedup_path_media_agent is None):
            storage_policy_copyinfo = {
                &#34;extendedFlags&#34;: {
                    &#34;globalStoragePolicy&#34;: 1
                }
            }
            request_json[&#34;storagePolicyCopyInfo&#34;].update(storage_policy_copyinfo)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._POLICY, request_json
        )

        if flag:
            if response.json():
                if &#39;error&#39; in response.json() and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                    # initialize the policies again
                    # so the policies object has all the policies
                    self.refresh()

                else:
                    error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                    o_str = &#39;Failed to create storage policy\nError: &#34;{0}&#34;&#39;

                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        return self.get(global_storage_policy_name)

    def add(self,
            storage_policy_name,
            library=None,
            media_agent=None,
            dedup_path=None,
            incremental_sp=None,
            retention_period=5,
            number_of_streams=None,
            ocum_server=None,
            dedup_media_agent=None,
            dr_sp=False,
            **kwargs):
        &#34;&#34;&#34;Adds a new Storage Policy to the Commcell.

            Args:
                storage_policy_name (str)         --  name of the new storage policy to add

                library             (str/object)  --  name or instance of the library
                to add the policy to

                media_agent         (str/object)  --  name or instance of media agent
                to add the policy to

                dedup_path          (str)         --  the path of the deduplication database
                default: None

                incremental_sp      (str)         --  the name of the incremental storage policy
                associated with the storage policy
                default: None

                retention_period    (int)         --  time period in days to retain
                the data backup for
                default:5

                number_of_streams   (int)         --  the number of streams for the storage policy
                default: None

                ocum_server         (str)         --  On Command Unified Server Name
                default: None

                dedup_media_agent   (str)          --  name of media agent where deduplication database is hosted.
                default:None

                dr_sp                (bool)         --  if True creates dr storage policy
                                                        if False creates data protection policy
                default:False

                **kwargs    --  dict of keyword arguments as follows:

                    global_policy_name   (str)         --  name of the global storage policy on which you want
                                                           the policy being created to be dependent.

                    global_dedup_policy (bool)  -- whether the global storage policy has a global deduplication pool
                                                   or not
                    default:True                  (meaning the global storage policy will have deduplication enabled)

            Raises:
                SDKException:
                    if type of the storage policy name argument is not string

                    if type of the retention period argument is not int

                    if type of the library argument is not either string or DiskLibrary instance

                    if type of the media agent argument is not either string or MediaAgent instance

                    if failed to create storage policy

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;

        extra_arguments = {
            &#39;global_policy_name&#39;: None,
            &#39;global_dedup_policy&#39;: True
        }
        # if global_dedup_policy will always have some value
        # global_policy_name decides if user wants to create sp using existing global dedup policy or not
        extra_arguments.update(kwargs)

        if ((dedup_path is not None and not isinstance(dedup_path, str)) or
                (not (isinstance(storage_policy_name, str) and
                      isinstance(retention_period, int))) or
                (incremental_sp is not None and not isinstance(incremental_sp, str))):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if isinstance(library, DiskLibrary):
            disk_library = library
        elif isinstance(library, str):
            disk_library = DiskLibrary(self._commcell_object, library)
        elif extra_arguments[&#34;global_policy_name&#34;] is not None:
            pass
            # when existing global_dedup_policy is used then library details not needed
        else:
            raise SDKException(&#39;Storage&#39;, &#39;104&#39;)

        if isinstance(media_agent, MediaAgent):
            media_agent = media_agent
        elif isinstance(media_agent, str):
            media_agent = MediaAgent(self._commcell_object, media_agent)
        elif extra_arguments[&#34;global_policy_name&#34;] is not None:
            pass
            # when existing global_dedup_policy is used then MA details not needed
        else:
            raise SDKException(&#39;Storage&#39;, &#39;103&#39;)

        sp_type = 2 if dr_sp else 1

        if extra_arguments[&#34;global_policy_name&#34;] is None:
            # then populate request json using supplied Library, MA and dedup path
            request_json = {
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;library&#34;: {
                        &#34;libraryId&#34;: int(disk_library.library_id)
                    },
                    &#34;mediaAgent&#34;: {
                        &#34;mediaAgentId&#34;: int(media_agent.media_agent_id)
                    },
                    &#34;retentionRules&#34;: {
                        &#34;retainBackupDataForDays&#34;: retention_period
                    }
                },
                &#34;storagePolicyName&#34;: storage_policy_name,
                &#34;type&#34;: sp_type
            }

            if dedup_path:
                if dedup_media_agent is None:
                    dedup_media_agent = media_agent
                elif self._commcell_object.media_agents.has_media_agent(dedup_media_agent):
                    dedup_media_agent = MediaAgent(self._commcell_object, dedup_media_agent)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;103&#39;)

                dedup_info = {
                    &#34;storagePolicyCopyInfo&#34;: {
                        &#34;dedupeFlags&#34;: {
                            &#34;enableDeduplication&#34;: 1
                        },
                        &#34;DDBPartitionInfo&#34;: {
                            &#34;maInfoList&#34;: [{
                                &#34;mediaAgent&#34;: {
                                    &#34;mediaAgentName&#34;: dedup_media_agent.media_agent_name
                                },
                                &#34;subStoreList&#34;: [{
                                    &#34;accessPath&#34;: {
                                        &#34;path&#34;: dedup_path
                                    }
                                }]
                            }]
                        }
                    }
                }

                request_json[&#34;storagePolicyCopyInfo&#34;].update(dedup_info[&#34;storagePolicyCopyInfo&#34;])

        # since we are supplying a global policy thus there is no need of the
        # dedup store details and the library details which got included above,
        # it will take up the settings of the global storage policy
        # thus defining request_json

        if extra_arguments[&#34;global_policy_name&#34;] is not None and extra_arguments[&#34;global_dedup_policy&#34;] is True:
            pool_obj = self._commcell_object.storage_pools.get(extra_arguments[&#34;global_policy_name&#34;])
            request_json = {
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;useGlobalPolicy&#34;: {
                        &#34;storagePolicyName&#34;: extra_arguments[&#34;global_policy_name&#34;]
                    },
                    &#34;retentionRules&#34;: {
                        &#34;retainBackupDataForDays&#34;: retention_period
                    },
                    &#34;dedupeFlags&#34;: {
                        &#34;useGlobalDedupStore&#34;: 1,
                        &#34;enableClientSideDedup&#34;: 1,
                        &#34;enableDASHFull&#34;: 1,
                        &#34;enableDeduplication&#34;: 1
                    },
                    &#34;extendedFlags&#34;: {
                        &#34;overRideGACPRetention&#34;: &#34;SET_FALSE&#34; if pool_obj.is_worm_storage_lock_enabled else &#34;SET_TRUE&#34;
                    }
                },
                &#34;storagePolicyName&#34;: storage_policy_name
            }

        elif extra_arguments[&#34;global_policy_name&#34;] is not None and extra_arguments[&#34;global_dedup_policy&#34;] is False:
            request_json = {
                &#34;storagePolicyName&#34;: storage_policy_name,
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;dedupeFlags&#34;: {
                        &#34;enableDASHFull&#34;: 1
                    },
                    &#34;retentionRules&#34;: {
                        &#34;retainBackupDataForDays&#34;: retention_period
                    },
                    &#34;extendedFlags&#34;: {
                        &#34;useGlobalStoragePolicy&#34;: 1
                    },
                    &#34;useGlobalPolicy&#34;: {
                        &#34;storagePolicyName&#34;: extra_arguments[&#34;global_policy_name&#34;]
                    }
                }
            }

        if number_of_streams is not None:
            number_of_streams_dict = {
                &#34;numberOfStreams&#34;: number_of_streams
            }
            request_json.update(number_of_streams_dict)

        if ocum_server is not None:
            ocum_server_dict1 = {
                &#34;dfmServer&#34;: {
                    &#34;name&#34;: ocum_server,
                    &#34;id&#34;: 0
                }
            }
            ocum_server_dict2 = {
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;snapLibrary&#34;: {
                        &#34;libraryName&#34;: &#34;Use primary copy&#39;s library and mediaAgent&#34;
                    },
                    &#34;storagePolicyFlags&#34;: {
                        &#34;enableSnapshot&#34;: 1
                    }
                }
            }

            request_json[&#34;storagePolicyCopyInfo&#34;].update(ocum_server_dict2[&#34;storagePolicyCopyInfo&#34;])
            request_json.update(ocum_server_dict1)

        if incremental_sp:
            incremental_sp_info = {
                &#34;incrementalStoragePolicy&#34;: {
                    &#34;storagePolicyName&#34;: incremental_sp
                }
            }

            request_json.update(incremental_sp_info)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._POLICY, request_json
        )

        if flag:
            if response.json():
                if &#39;error&#39; in response.json() and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                    # initialize the policies again
                    # so the policies object has all the policies
                    self.refresh()

                else:
                    error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                    o_str = &#39;Failed to create storage policy\nError: &#34;{0}&#34;&#39;

                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        return self.get(storage_policy_name)

    def add_tape_sp(self, storage_policy_name, library, media_agent, drive_pool, scratch_pool, retention_period_days=15,
                    ocum_server=None):
        &#34;&#34;&#34;
        Adds storage policy with tape data path
        Args:
                storage_policy_name (str)         --  name of the new storage policy to add

                library             (str)     --  name or instance of the library
                to add the policy to

                media_agent         (str/object)  --  name or instance of media agent
                to add the policy to

                drive_pool          (str)         --  Drive pool name of the tape library

                scratch_pool      (str)          --  Scratch pool name of the tape library

                retention_period_days    (int)         --  time period in days to retain
                the data backup for
                default: 15

                ocum_server         (str)         --  On Command Unified Server Name
                default: None

            Raises:
                SDKException:
                    if type of the storage policy name argument is not string

                    if type of the retention period argument is not int

                    if type of the library argument is not either string or DiskLibrary instance

                    if type of the media agent argument is not either string or MediaAgent instance

                    if failed to create storage policy

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        tape_library = library
        if not (isinstance(drive_pool, str) and
                isinstance(scratch_pool, str) and
                isinstance(tape_library, str) and
                isinstance(media_agent, str) and
                isinstance(storage_policy_name, str) and
                (retention_period_days is None or isinstance(retention_period_days, int))):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_json = {
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;retentionRules&#34;: {
                    &#34;retainBackupDataForDays&#34;: retention_period_days
                },
                &#34;library&#34;: {
                    &#34;libraryName&#34;: tape_library
                },
                &#34;mediaAgent&#34;: {
                    &#34;mediaAgentName&#34;: media_agent
                }
            },
            &#34;drivePool&#34;: drive_pool,
            &#34;scratchpool&#34;: scratch_pool,
            &#34;storagePolicyName&#34;: storage_policy_name
        }

        if ocum_server is not None:
            ocum_server_dict1 = {
                &#34;dfmServer&#34;: {
                    &#34;name&#34;: ocum_server,
                    &#34;id&#34;: 0
                }
            }

            ocum_server_dict2 = {
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;snapLibrary&#34;: {
                        &#34;libraryName&#34;: &#34;Use primary copy&#39;s library and mediaAgent&#34;
                    },
                    &#34;storagePolicyFlags&#34;: {
                        &#34;enableSnapshot&#34;: 1
                    }
                }
            }

            request_json[&#34;storagePolicyCopyInfo&#34;].update(ocum_server_dict2[&#34;storagePolicyCopyInfo&#34;])
            request_json.update(ocum_server_dict1)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._POLICY, request_json
        )

        if flag:
            if response.json():
                if &#39;error&#39; in response.json() and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                    # initialize the policies again
                    # so the policies object has all the policies
                    self.refresh()

                else:
                    error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                    o_str = &#39;Failed to create storage policy with tape data path\nError: &#34;{0}&#34;&#39;

                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        return self.get(storage_policy_name)

    def delete(self, storage_policy_name):
        &#34;&#34;&#34;Deletes a storage policy from the commcell.

            Args:
                storage_policy_name (str)  --  name of the storage policy to delete

            Raises:
                SDKException:
                    if type of the storage policy name argument is not string

                    if failed to delete storage policy

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        if not isinstance(storage_policy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if self.has_policy(storage_policy_name):
            storagepolicy_id = self.all_storage_policies[storage_policy_name.lower()]
            policy_delete_service = self._DELETE_POLICY + &#39;/{0}&#39;.format(storagepolicy_id)

            flag, response = self._commcell_object._cvpysdk_object.make_request(
                &#39;DELETE&#39;, policy_delete_service
            )

            if flag:
                try:
                    if response.json():
                        if &#39;error&#39; in response.json():
                            if &#39;errorCode&#39; in response.json()[&#39;error&#39;] and &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                                error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                                o_str = &#39;Failed to delete storage policy\nError: &#34;{0}&#34;&#39;

                                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
                            elif &#39;errorCode&#39; in response.json()[&#39;error&#39;] and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                                self.refresh()
                                return response.text.strip()
                except ValueError:
                    if response.text:
                        if &#39;errorCode&#39; in response.text and &#39;errorMessage&#39; in response.text:
                            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, response.text.strip())
                        self.refresh()
                        return response.text.strip()
                    else:
                        raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                response_string = self._commcell_object._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        else:
            raise SDKException(
                &#39;Storage&#39;, &#39;102&#39;, &#39;No policy exists with name: {0}&#39;.format(storage_policy_name)
            )

    def refresh(self):
        &#34;&#34;&#34;Refresh the storage policies associated with the Commcell.&#34;&#34;&#34;
        self._policies = self._get_policies()


class StoragePolicy(object):
    &#34;&#34;&#34;Class for performing storage policy operations for a specific storage policy&#34;&#34;&#34;

    def __init__(self, commcell_object, storage_policy_name, storage_policy_id=None):
        &#34;&#34;&#34;Initialise the Storage Policy class instance.&#34;&#34;&#34;
        self._storage_policy_name = storage_policy_name.lower()
        self._commcell_object = commcell_object

        if storage_policy_id:
            self._storage_policy_id = str(storage_policy_id)
        else:
            self._storage_policy_id = self._get_storage_policy_id()

        self._STORAGE_POLICY = self._commcell_object._services[&#39;GET_STORAGE_POLICY&#39;] % (
            self.storage_policy_id
        )
        self._STORAGE_POLICY_ADVANCED = self._commcell_object._services[&#39;GET_STORAGE_POLICY_ADVANCED&#39;] % (
            self.storage_policy_id
        )
        self._storage_policy_properties = None
        self._storage_policy_advanced_properties = None
        self._copies = {}
        self.refresh()

    def __repr__(self):
        &#34;&#34;&#34;String representation of the instance of this class.&#34;&#34;&#34;
        representation_string = &#39;Storage Policy class instance for Storage Policy: &#34;{0}&#34;&#39;
        return representation_string.format(self.storage_policy_name)

    def _get_storage_policy_id(self):
        &#34;&#34;&#34;Gets the storage policy id asscoiated with the storage policy&#34;&#34;&#34;

        storage_policies = StoragePolicies(self._commcell_object)
        return storage_policies.get(self.storage_policy_name).storage_policy_id

    def _get_storage_policy_advanced_properties(self):
        &#34;&#34;&#34;Gets the advanced storage policy properties of this storage policy.

            Returns:
                dict - dictionary consisting of the advanced properties of this storage policy

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;GET&#39;, self._STORAGE_POLICY_ADVANCED
        )

        if flag:
            if response.json():
                return response.json()
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_storage_policy_properties(self):
        &#34;&#34;&#34;Gets the storage policy properties of this storage policy.

            Returns:
                dict - dictionary consisting of the properties of this storage policy

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;GET&#39;, self._STORAGE_POLICY
        )

        if flag:
            if response.json():
                return response.json()
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _initialize_storage_policy_properties(self):
        &#34;&#34;&#34;Initializes the common properties for the storage policy.&#34;&#34;&#34;
        self._storage_policy_properties = self._get_storage_policy_properties()
        self._copies = {}

        if &#39;copy&#39; in self._storage_policy_properties:
            for copy in self._storage_policy_properties[&#39;copy&#39;]:
                copy_type = copy[&#39;copyType&#39;]
                active = copy[&#39;active&#39;]
                copy_id = copy[&#39;StoragePolicyCopy&#39;][&#39;copyId&#39;]
                copy_name = copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;].lower()
                try:
                    library_name = copy[&#39;library&#39;][&#39;libraryName&#39;]
                except:
                    library_name = None
                copy_precedence = copy[&#39;copyPrecedence&#39;]
                is_snap_copy = bool(int(copy[&#39;isSnapCopy&#39;]))
                is_default_copy = bool(int(copy.get(&#39;isDefault&#39;, 0)))
                temp = {
                    &#34;copyType&#34;: copy_type,
                    &#34;active&#34;: active,
                    &#34;copyId&#34;: copy_id,
                    &#34;libraryName&#34;: library_name,
                    &#34;copyPrecedence&#34;: copy_precedence,
                    &#34;isSnapCopy&#34;: is_snap_copy,
                    &#34;isDefault&#34;: is_default_copy
                }
                self._copies[copy_name] = temp

    def edit_block_size_on_gdsp(self,
                                size=512):
        &#34;&#34;&#34;
        edit the block size on the gdsp

        Args:
                size (int) - SIDB block size to be changed to


        Raises:
            SDKException:
                    if error in response

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        request_json = {
                        &#34;App_UpdateStoragePolicyReq&#34;: {
                            &#34;StoragePolicy&#34;: {
                                &#34;storagePolicyName&#34;: self._storage_policy_name
                            },
                            &#34;sidbBlockSizeKB&#34;: size
                          }
                        }

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_json
        )

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = &#34;Failed to update block size factor on gdsp with error \
                                    {0}&#34;.format(str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                        else:
                            error_message = &#34;Failed to update block size factor on gdsp&#34;
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def has_copy(self, copy_name):
        &#34;&#34;&#34;Checks if a storage policy copy exists for this storage
            policy with the input storage policy name.

            Args:
                copy_name (str)  --  name of the storage policy copy

            Returns:
                bool - boolean output whether the storage policy copy exists or not

            Raises:
                SDKException:
                    if type of the storage policy copy name argument is not string
        &#34;&#34;&#34;
        if not isinstance(copy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        return self._copies and copy_name.lower() in self._copies

    def create_secondary_copy(self,
                              copy_name,
                              library_name=None,
                              media_agent_name=None,
                              drive_pool=None,
                              spare_pool=None,
                              tape_library_id=None,
                              drive_pool_id=None,
                              spare_pool_id=None,
                              snap_copy=False,
                              global_policy=None,
                              retention_days=30):
        &#34;&#34;&#34;Creates Synchronous copy for this storage policy

            Args:
                copy_name           (str)   --  copy name to create

                library_name        (str)   --  library name to be assigned

                media_agent_name    (str)   --  media_agent to be assigned

                snap_copy           (bool)  --  boolean on whether copy should be a snap copy
                default: False

                global_policy       (str)   --  name of the global policy to be assigned

            Raises:
                SDKException:
                    if type of inputs in not string

                    if copy with given name already exists

                    if failed to create copy

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        if global_policy is not None:
            if not (isinstance(copy_name, str) and isinstance(global_policy, str)):
                raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

            if self.has_copy(copy_name):
                err_msg = f&#39;Storage Policy copy &#34;{copy_name}&#34; already exists.&#39;
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

            if not self._commcell_object.storage_pools.has_storage_pool(global_policy):
                err_msg = f&#39;No Global Storage Policy &#34;{global_policy}&#34; exists.&#39;
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

            global_policy = self._commcell_object.storage_pools.get(global_policy)

            global_policy_copy = StoragePolicyCopy (self._commcell_object, global_policy.storage_pool_name, global_policy.copy_name)

            is_global_dedupe_policy = global_policy_copy._dedupe_flags.get(&#39;enableDeduplication&#39;, 0)
            
            request = {
                       &#34;copyName&#34;: copy_name,
                       &#34;storagePolicyCopyInfo&#34;: {
                          &#34;copyType&#34;: 0,
                          &#34;isDefault&#34;: 0,
                          &#34;isMirrorCopy&#34;: 0,
                          &#34;isSnapCopy&#34;: 0,
                          &#34;numberOfStreamsToCombine&#34;: 1,
                          &#34;StoragePolicyCopy&#34;: {
                             &#34;_type_&#34;: 18,
                             &#34;storagePolicyName&#34;: self.storage_policy_name
                          },
                          &#34;retentionRules&#34;: {
                             &#34;retainArchiverDataForDays&#34;: -1,
                             &#34;retainBackupDataForCycles&#34;: 1,
                             &#34;retainBackupDataForDays&#34;: retention_days
                          },
                          &#34;dedupeFlags&#34;: {
                              &#34;enableDeduplication&#34;: is_global_dedupe_policy,
                              &#34;useGlobalDedupStore&#34;: is_global_dedupe_policy
                          },
                           &#34;useGlobalPolicy&#34;:{
                               &#34;storagePolicyName&#34;: global_policy.storage_pool_name
                           },
                           &#34;extendedFlags&#34;:{
                               &#34;useGlobalStoragePolicy&#34;: 1
                           }
                       }
                    }

        else:
            if not (isinstance(copy_name, str) and
                    isinstance(library_name, str) and
                    isinstance(media_agent_name, str)):
                raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

            if self.has_copy(copy_name):
                err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

            media_agent_id = self._commcell_object.media_agents._media_agents[media_agent_name.lower()][&#39;id&#39;]

            snap_copy = int(snap_copy)

            if drive_pool is not None:
                    request = &#34;&#34;&#34;
                            &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                                &lt;storagePolicyCopyInfo copyType=&#34;0&#34; isDefault=&#34;0&#34; isMirrorCopy=&#34;0&#34; isSnapCopy=&#34;{11}&#34; numberOfStreamsToCombine=&#34;1&#34;&gt;
                                    &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                                    &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                                    &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                                    &lt;drivePool drivePoolId = &#34;{7}&#34; drivePoolName = &#34;{8}&#34;  libraryName = &#34;{4}&#34; /&gt;
                                    &lt;spareMediaGroup spareMediaGroupId = &#34;{9}&#34; spareMediaGroupName = &#34;{10}&#34; libraryName = &#34;{4}&#34; /&gt;
                                    &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;1&#34; retainBackupDataForDays=&#34;30&#34; /&gt;
                                &lt;/storagePolicyCopyInfo&gt;
                            &lt;/App_CreateStoragePolicyCopyReq&gt;
                            &#34;&#34;&#34;.format(copy_name, self.storage_policy_id, self.storage_policy_name,
                                       tape_library_id, library_name, media_agent_id, media_agent_name,
                                       drive_pool_id, drive_pool, spare_pool_id, spare_pool, snap_copy)

            else:
                library_id = self._commcell_object.disk_libraries._libraries[library_name.lower()]
                request = &#34;&#34;&#34;
                &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                    &lt;storagePolicyCopyInfo copyType=&#34;0&#34; isDefault=&#34;0&#34; isMirrorCopy=&#34;0&#34; isSnapCopy=&#34;{7}&#34; numberOfStreamsToCombine=&#34;1&#34;&gt;
                        &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                        &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                        &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                        &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;1&#34; retainBackupDataForDays=&#34;30&#34; /&gt;
                    &lt;/storagePolicyCopyInfo&gt;
                &lt;/App_CreateStoragePolicyCopyReq&gt;
                &#34;&#34;&#34;.format(copy_name, self.storage_policy_id, self.storage_policy_name,
                           library_id, library_name, media_agent_id, media_agent_name, snap_copy)

        create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, create_copy_service, request
        )

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = &#34;Failed to create {0} Storage Policy copy with error \
                            {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                        else:
                            error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                                copy_name
                            )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def run_content_indexing(self):
        &#34;&#34;&#34;starts the offline CI job for this storage policy

            Args:
                None

            Returns:
                object - instance of the Job class for this CI job

            Raises:
                SDKException:
                        if type of inputs is not valid

                        if failed to start content indexing job

                        if response received is empty

                        if response is not success
        &#34;&#34;&#34;
        request_xml = &#34;&#34;&#34;&lt;TMMsg_CreateTaskReq&gt;
        &lt;taskInfo&gt;
        &lt;associations subclientId=&#34;0&#34; storagePolicyId=&#34;{0}&#34; applicationId=&#34;0&#34; clientName=&#34;&#34; backupsetId=&#34;0&#34;
        instanceId=&#34;0&#34; commCellId=&#34;0&#34; clientId=&#34;0&#34; subclientName=&#34;&#34; mediaAgentId=&#34;0&#34; mediaAgentName=&#34;&#34; backupsetName=&#34;&#34;
        instanceName=&#34;&#34; storagePolicyName=&#34;{1}&#34; _type_=&#34;0&#34; appName=&#34;&#34; /&gt;
        &lt;task ownerId=&#34;1&#34; taskType=&#34;1&#34; ownerName=&#34;admin&#34; sequenceNumber=&#34;0&#34; initiatedFrom=&#34;1&#34; policyType=&#34;0&#34; taskId=&#34;0&#34;&gt;
        &lt;taskFlags disabled=&#34;0&#34; /&gt;&lt;/task&gt;
        &lt;subTasks subTaskOperation=&#34;1&#34;&gt;&lt;subTask subTaskType=&#34;1&#34; operationType=&#34;4022&#34; /&gt;
        &lt;options&gt;&lt;backupOpts&gt;&lt;mediaOpt&gt;
        &lt;auxcopyJobOption maxNumberOfStreams=&#34;0&#34; allCopies=&#34;1&#34; useMaximumStreams=&#34;1&#34;&gt;&lt;mediaAgent mediaAgentId=&#34;0&#34;
        _type_=&#34;11&#34; mediaAgentName=&#34;&#34; /&gt;
        &lt;/auxcopyJobOption&gt;&lt;/mediaOpt&gt;&lt;/backupOpts&gt;&lt;adminOpts&gt;
        &lt;contentIndexingOption fileAnalytics=&#34;0&#34; subClientBasedAnalytics=&#34;0&#34; reanalyze=&#34;0&#34; /&gt;
        &lt;/adminOpts&gt;
        &lt;restoreOptions&gt;&lt;virtualServerRstOption isBlockLevelReplication=&#34;0&#34; /&gt;&lt;commonOptions syncRestore=&#34;0&#34; /&gt;
        &lt;/restoreOptions&gt;&lt;/options&gt;&lt;/subTasks&gt;
        &lt;/taskInfo&gt;&lt;/TMMsg_CreateTaskReq&gt;&#34;&#34;&#34;.format(self._storage_policy_id, self._storage_policy_name)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
        )

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, &#39;Unable to get job id for CI job&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;, &#39;Empty response&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;)

    def enable_content_indexing(
            self,
            cloud_id,
            include_doc_type=None,
            max_doc_size=None,
            min_doc_size=None,
            exclude_doc_type=None):
        &#34;&#34;&#34;configures offline CI for this storage policy

                Args:

                    cloud_id            (str)   --  cloud id of the search engine

                    include_doc_type    (str)   --  include document types for content indexing

                        Example : &#34;*.csv,*.ppt&#34;

                    exclude_doc_type    (str)   --  exclude document types for content indexing

                        Example : &#34;*.py,*.txt&#34;

                    max_doc_size        (str)   --  maximum document size for CI in KB

                    min_doc_size        (str)   --  minimum document size for CI in KB

                Returns:
                    None

                Raises:

                    SDKException:
                            if type of inputs is not valid

                            if failed to configure content indexing

                            if response received is empty

                            if response is not success
        &#34;&#34;&#34;
        if not isinstance(cloud_id, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if include_doc_type is None:
            include_doc_type = &#34;*.bmp,*.csv,*.doc,*.docx,*.dot,*.eml,*.htm,*.html,*.jpeg,*.jpg,*.log,*.msg,*.odg,&#34; \
                               &#34;*.odp,*.ods,*.odt,*.pages,*.pdf,*.png,*.ppt,*.pptx,*.rtf,*.txt,*.xls,*.xlsx,*.xmind,*.xml&#34;
        if max_doc_size is None:
            max_doc_size = &#34;51200&#34;

        if min_doc_size is None:
            min_doc_size = &#34;0&#34;

        if exclude_doc_type is None:
            exclude_doc_type = &#34;&#34;

        request_xml = &#34;&#34;&#34;&lt;EVGui_ContentIndexingControlReq operation=&#34;16&#34;&gt;&lt;header localeId=&#34;0&#34; userId=&#34;0&#34;/&gt;
        &lt;ciProps archGroupId=&#34;{0}&#34; calendarId=&#34;1&#34; cloudId=&#34;{1}&#34; contentIndexDataOver=&#34;0&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
         enable=&#34;1&#34; entityIds=&#34;&#34; excludeDocTypes=&#34;{5}&#34; filterSelected=&#34;1&#34; flags=&#34;0&#34;
         includeDocTypes=&#34;{2}&#34; indexType=&#34;0&#34; jobsOlderThan=&#34;0&#34;
         maxDocSizeKB=&#34;{3}&#34; minDocSizeKB=&#34;{4}&#34; numPeriod=&#34;1&#34; retentionDays=&#34;-1&#34; sourceCopyId=&#34;0&#34; startTime=&#34;0&#34;
         synchronizeOn=&#34;0&#34; type=&#34;0&#34;/&gt;&lt;/EVGui_ContentIndexingControlReq&gt;&#34;&#34;&#34;\
            .format(self._storage_policy_id, cloud_id, include_doc_type, max_doc_size, min_doc_size, exclude_doc_type)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
        )

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 1:
                        error_message = &#34;Failed to enable content indexing for this storage policy&#34;
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;, &#39;No success error code found in response&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def enable_entity_extraction(self, entity_details, entity_names, ca_client_name):
        &#34;&#34;&#34;configures offline CI entity extraction for given subclient id&#39;s on this storage policy

                Args:
                    entity_details     (list)     --  List of subclient to configure for Entity Extraction

                    Format : [[clientname,agent type,backup set name,subclient name]]

                    entity_names         (list)   --  list of entity names to be configured for Entity Extraction

                    Example : [Email,SSN]

                    ca_client_name       (str)    --  client name where Content Analyzer package is installed

                Raises:
                    SDKException:
                        if type of inputs is not valid

                        if failed to configure EE

                        if response received is empty

                        if response is not success
        &#34;&#34;&#34;
        if not (isinstance(entity_details, list) and isinstance(entity_names, list)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        if not isinstance(ca_client_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        request_xml = &#34;&#34;&#34;&lt;EVGui_SetEntityExtractionListReq archGroupId=&#34;{0}&#34;&gt;
        &lt;entityExtraction isConfigured=&#34;1&#34;&gt;&#34;&#34;&#34;.format(self._storage_policy_id)
        for subclient in entity_details:
            client_name = subclient[0]
            app_name = subclient[1]
            backup_set_name = subclient[2]
            subclient_name = subclient[3]
            client_obj = self._commcell_object.clients.get(client_name)
            agent_obj = client_obj.agents.get(app_name)
            backup_set_obj = agent_obj.backupsets.get(backup_set_name)
            subclient_obj = backup_set_obj.subclients.get(subclient_name)
            if subclient_obj.storage_policy.lower() != self._storage_policy_name.lower():
                err_msg = &#39;Subclient &#34;{0}&#34; is not a part of this storage policy&#39;.format(subclient_name)
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)
            subclient_prop = subclient_obj.properties
            request_xml = request_xml + &#34;&#34;&#34;&lt;appList appOperation=&#34;0&#34; appTypeId=&#34;{0}&#34; archGroupId=&#34;0&#34;
                backupSetId=&#34;{1}&#34; clientId=&#34;{2}&#34; instanceId=&#34;{3}&#34; subClientId=&#34;{4}&#34;/&gt;&#34;&#34;&#34;.format(
                subclient_prop[&#39;subClientEntity&#39;][&#39;applicationId&#39;],
                subclient_prop[&#39;subClientEntity&#39;][&#39;backupsetId&#39;],
                subclient_prop[&#39;subClientEntity&#39;][&#39;clientId&#39;],
                subclient_prop[&#39;subClientEntity&#39;][&#39;instanceId&#39;],
                subclient_prop[&#39;subClientEntity&#39;][&#39;subclientId&#39;],
            )

        for entity in entity_names:
            entity_obj = self._commcell_object.activate.entity_manager().get(entity)
            request_xml = request_xml + &#34;&#34;&#34;&lt;entities enabled=&#34;1&#34; entityId=&#34;{0}&#34; entityName=&#34;{1}&#34;/&gt;&#34;&#34;&#34;\
                .format(entity_obj.entity_id, entity)

        client_obj = self._commcell_object.clients.get(ca_client_name)
        request_xml = request_xml + &#34;&#34;&#34;&lt;extractingClientList enabled=&#34;1&#34;&gt;
        &lt;eeClient clientId=&#34;{0}&#34; clientName=&#34;{1}&#34;/&gt;
        &lt;/extractingClientList&gt;&lt;/entityExtraction&gt;&lt;/EVGui_SetEntityExtractionListReq&gt;&#34;&#34;&#34;\
            .format(client_obj.client_id, ca_client_name)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
        )

        if flag:
            if response.json():
                if &#39;errorCode&#39; in response.json():
                    error_code = int(response.json()[&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to enable entity extraction for this storage policy&#34;
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;, &#39;No success error code found in response&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def create_snap_copy(self,
                         copy_name,
                         is_mirror_copy,
                         is_snap_copy,
                         library_name,
                         media_agent_name,
                         source_copy,
                         provisioning_policy=None,
                         resource_pool=None,
                         is_replica_copy=None,
                         **kwargs):
        &#34;&#34;&#34;Creates Snap copy for this storage policy

            Args:
                copy_name           (str)   --  copy name to create

                is_mirror_copy      (bool)   --  if true then copyType will be Mirror

                is_snap_copy        (bool)   --  if true then copyType will be Snap

                library_name        (str)   --  library name to be assigned

                media_agent_name    (str)   --  media_agent to be assigned

                source_copy         (str)   --  Name of the Source Copy for this copy

                provisioning_policy (str)   --  Name of the provisioning Policy to add
                default : None

                resource_pool       (str)   --  Name of the resource pool to add
                default : None

                is_replica_copy     (bool)   --  if true then Replica Copy will be created
                default : None

                is_c2c_target       (bool)   -- if true then NetApp Cloud target copy will be created 
                default : False

                job_retention       (bool)  -- if true job based retention will be set
                default : False

                enable_selective_copy (int) -- Enable selective copy with value selectiveRule

            Raises:
                SDKException:
                    if type of inputs in not string

                    if copy with given name already exists

                    if failed to create copy

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and
                isinstance(library_name, str) and
                isinstance(media_agent_name, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if self.has_copy(copy_name):
            err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        if is_replica_copy:
            arrayReplicaCopy = &#34;1&#34;
            useOfflineReplication = &#34;1&#34;
        else:
            arrayReplicaCopy = &#34;0&#34;
            useOfflineReplication = &#34;0&#34;
        if is_mirror_copy:
            is_mirror_copy = 1
        else:
            is_mirror_copy = 0
        if is_snap_copy:
            is_snap_copy = 1
        else:
            is_snap_copy = 0
        if provisioning_policy is None:
            provisioning_policy = &#34;&#34;
            resource_pool = &#34;&#34;

        is_c2c_target = kwargs.get(&#39;is_c2c_target&#39;, False)
        isNetAppSnapCloudTargetCopy = 1 if is_c2c_target else 0

        job_based_retention = kwargs.get(&#39;job_based_retention&#39;, False)
        job_retention = 1 if job_based_retention else 0

        selectiveRule = kwargs.get(&#39;enable_selective_copy&#39;, None)
        if selectiveRule is None:
            request_xml = &#34;&#34;&#34;
                    &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                        &lt;storagePolicyCopyInfo active=&#34;1&#34; isMirrorCopy=&#34;{1}&#34; isSnapCopy=&#34;{2}&#34; provisioningPolicyName=&#34;{3}&#34;&gt;
                            &lt;StoragePolicyCopy _type_=&#34;18&#34; copyName=&#34;{0}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                            &lt;extendedFlags arrayReplicaCopy=&#34;{5}&#34; isNetAppSnapCloudTargetCopy=&#34;{12}&#34; useOfflineArrayReplication=&#34;{6}&#34; /&gt;
                            &lt;library _type_=&#34;9&#34; libraryName=&#34;{7}&#34; /&gt;
                            &lt;mediaAgent _type_=&#34;11&#34; mediaAgentName=&#34;{8}&#34; /&gt;
                            &lt;spareMediaGroup _type_=&#34;67&#34; libraryName=&#34;{7}&#34; /&gt;
                            &lt;retentionRules jobs=&#34;8&#34; retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;5&#34; retainBackupDataForDays=&#34;1&#34;&gt;
                            &lt;retentionFlags jobBasedRetention=&#34;{11}&#34; /&gt;
                            &lt;/retentionRules&gt;
                            &lt;sourceCopy _type_=&#34;18&#34; copyName=&#34;{9}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                            &lt;resourcePoolsList operation=&#34;1&#34; resourcePoolName=&#34;{10}&#34; /&gt;
                        &lt;/storagePolicyCopyInfo&gt;
                    &lt;/App_CreateStoragePolicyCopyReq&gt;
                    &#34;&#34;&#34;.format(copy_name, is_mirror_copy, is_snap_copy, provisioning_policy,
                               self.storage_policy_name, arrayReplicaCopy, useOfflineReplication,
                               library_name, media_agent_name, source_copy, resource_pool, job_retention, isNetAppSnapCloudTargetCopy)
        else:
            request_xml = &#34;&#34;&#34;
                                        &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                                            &lt;storagePolicyCopyInfo copyType=&#34;2&#34; description=&#34;&#34; isMirrorCopy=&#34;{1}&#34; isSnapCopy=&#34;{2}&#34;&gt;
                                                &lt;StoragePolicyCopy copyName=&#34;{0}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                                                &lt;extendedFlags arrayReplicaCopy=&#34;{5}&#34; isNetAppSnapCloudTargetCopy=&#34;{12}&#34; useOfflineArrayReplication=&#34;{6}&#34; /&gt;
                                                &lt;library  libraryName=&#34;{7}&#34; /&gt;
                                                &lt;mediaAgent _type_=&#34;11&#34; mediaAgentName=&#34;{8}&#34; /&gt;
                                                &lt;retentionRules jobs=&#34;8&#34; retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;5&#34; retainBackupDataForDays=&#34;1&#34;&gt;
                                                &lt;retentionFlags jobBasedRetention=&#34;{11}&#34; /&gt;
                                                &lt;/retentionRules&gt;
                                                &lt;sourceCopy _type_=&#34;18&#34; copyName=&#34;{9}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                                                &lt;selectiveCopyRules selectiveRule=&#34;{13}&#34;/&gt;
                                                &lt;/storagePolicyCopyInfo&gt;
                                        &lt;/App_CreateStoragePolicyCopyReq&gt;
                                        &#34;&#34;&#34;.format(copy_name, is_mirror_copy, is_snap_copy, provisioning_policy,
                                                   self.storage_policy_name, arrayReplicaCopy, useOfflineReplication,
                                                   library_name, media_agent_name, source_copy, resource_pool,
                                                   job_retention, isNetAppSnapCloudTargetCopy, selectiveRule)

        create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, create_copy_service, request_xml
        )

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = &#34;Failed to create {0} Storage Policy copy with error \
                            {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                        else:
                            error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                                copy_name
                            )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def delete_secondary_copy(self, copy_name):
        &#34;&#34;&#34;Deletes the copy associated with this storage policy

            Args:
                copy_name   (str)   --  copy name to be deleted

            Raises:
                SDKException:
                    if type of input parameters is not string

                    if storage policy copy doesn&#39;t exist with given name

                    if failed to delete storage policy copy

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        if not isinstance(copy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        else:
            copy_name = copy_name.lower()

        if not self.has_copy(copy_name):
            err_msg = &#39;Storage Policy copy &#34;{0}&#34; doesn\&#39;t exists.&#39;.format(copy_name)
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        delete_copy_service = self._commcell_object._services[&#39;DELETE_STORAGE_POLICY_COPY&#39;]

        request_xml = &#34;&#34;&#34;
        &lt;App_DeleteStoragePolicyCopyReq&gt;
            &lt;archiveGroupCopy _type_=&#34;18&#34; copyId=&#34;{0}&#34; copyName=&#34;{1}&#34; storagePolicyId=&#34;{2}&#34; storagePolicyName=&#34;{3}&#34; /&gt;
        &lt;/App_DeleteStoragePolicyCopyReq&gt;
        &#34;&#34;&#34;.format(self._copies[copy_name][&#39;copyId&#39;], copy_name, self.storage_policy_id,
                   self.storage_policy_name)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, delete_copy_service, request_xml
        )

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to delete {0} Storage Policy copy&#34;.format(
                            copy_name
                        )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def create_selective_copy(self,
                              copy_name,
                              library_name,
                              media_agent_name,
                              sel_freq,
                              first_or_last_full,
                              backups_from,
                              daystartson=None):
        &#34;&#34;&#34;Creates Selective copy for this storage policy

            Args:
                copy_name           (str)   --  copy name to create
                library_name        (str)   --  library name to be assigned
                media_agent_name    (str)   --  media_agent to be assigned
                drive_pool etc are for tape library

                sel_freq            (str) -- {all,hourly,daily,weekly,monthly,quaterly,half-year,year}
                first_or_last_full  (str) -- {FirstFull, LastFull, LastFullWait}
                backups_from        (str) -- {start date in yyyy-mm-dd format to pick jobs from this date}

            Raises:
                SDKException:
                    if type of inputs in not string

                    if copy with given name already exists

                    if failed to create copy

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and
                isinstance(library_name, str) and
                isinstance(media_agent_name, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if self.has_copy(copy_name):
            err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        media_agent_id = self._commcell_object.media_agents._media_agents[media_agent_name.lower()][&#39;id&#39;]

        selective_copy_freq = {&#39;all&#39;: 2, &#39;hourly&#39;: 262144, &#39;daily&#39;: 524288, &#39;weekly&#39;: 4, &#39;monthly&#39;: 8,
                               &#39;quarterly&#39;: 16, &#39;halfyearly&#39;: 32, &#39;yearly&#39;: 64, &#39;advanced&#39;: 16777216
                               }
        week_starts_on = {&#39;Sunday&#39;: 0, &#39;Monday&#39;: 1, &#39;Tuesday&#39;: 2, &#39;Wednesday&#39;: 3, &#39;Thursday&#39;: 4,
                          &#39;Friday&#39;: 5, &#39;Saturday&#39;: 6
                          }

        selective_rule = selective_copy_freq[sel_freq]
        copyflags = &#34;&#34;
        if first_or_last_full == &#34;LastFull&#34;:
            copyflags = &#34;&#34;&#34;&lt;copyFlags lastFull = &#34;1&#34; /&gt;&#34;&#34;&#34;
        elif first_or_last_full == &#34;LastFullWait&#34;:
            copyflags = &#34;&#34;&#34;&lt;copyFlags lastFull = &#34;1&#34; lastFullWait=&#34;1&#34; /&gt;&#34;&#34;&#34;

        dsostr = &#34;&#34;
        if (sel_freq == &#39;daily&#39; or sel_freq == &#39;hourly&#39;) and daystartson is not None \
                and isinstance(daystartson, dict):
            dsostr = &#34;&#34;&#34;
                        &lt;dayStartsAt amOrPm = &#34;{3}&#34;&gt; 
                        &lt;dayStartsHoursMinutes hours=&#34;{0}&#34; minutes = &#34;{1}&#34;  seconds= &#34;{2}&#34; /&gt;
                        &lt;/dayStartsAt&gt; 
                     &#34;&#34;&#34;.format(daystartson[&#34;hours&#34;], daystartson[&#34;minutes&#34;], daystartson[&#34;seconds&#34;],
                                daystartson[&#34;ampm&#34;])

        day_starts = &#34;&#34;
        if sel_freq == &#39;weekly&#39;:
            if daystartson is not None:
                day_starts = &#34;&#34;&#34; weekDayStartsOn=&#34;{0}&#34; &#34;&#34;&#34;.format(week_starts_on[daystartson])
            else:
                day_starts = &#34;&#34;&#34; weekDayStartsOn=&#34;{0}&#34; &#34;&#34;&#34;.format(week_starts_on[&#39;Friday&#39;])

        # monthStartsOn
        if sel_freq == &#39;monthly&#39;:
            if daystartson is not None:
                day_starts = &#34;&#34;&#34; monthStartsOn=&#34;{0}&#34; &#34;&#34;&#34;.format(daystartson)
            else:
                day_starts = &#34;&#34;&#34; monthStartsOn=&#34;{}&#34; &#34;&#34;&#34;.format(1)

        library_id = self._commcell_object.disk_libraries._libraries[library_name.lower()]
        request_xml = str(&#34;&#34;&#34;&lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                &lt;storagePolicyCopyInfo copyType=&#34;2&#34; isDefault=&#34;0&#34; isMirrorCopy=&#34;0&#34; isSnapCopy=&#34;0&#34; numberOfStreamsToCombine=&#34;1&#34;&gt;
                    &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                    &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                    &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                    &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;100&#34; retainBackupDataForDays=&#34;150&#34; /&gt;
                    &lt;startTime  timeValue = &#34;{7}&#34; /&gt;
                    &lt;selectiveCopyRules selectiveRule=&#34;{8}&#34; {10} &gt; {9} &lt;/selectiveCopyRules&gt; &#34;&#34;&#34; + copyflags +
                              &#34;&#34;&#34;&lt;/storagePolicyCopyInfo&gt;
                          &lt;/App_CreateStoragePolicyCopyReq&gt;&#34;&#34;&#34;).format(copy_name, self.storage_policy_id,
                                                                       self.storage_policy_name,
                                                                       library_id, library_name, media_agent_id,
                                                                       media_agent_name, backups_from,
                                                                       selective_rule, dsostr, day_starts)
        create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, create_copy_service, request_xml)

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = &#34;Failed to create {0} Storage Policy copy with error \
                            {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                        else:
                            error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                                copy_name
                            )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def copies(self):
        &#34;&#34;&#34;Treats the storage policy copies as a read-only attribute&#34;&#34;&#34;
        return self._copies

    @property
    def storage_policy_id(self):
        &#34;&#34;&#34;Treats the storage policy id as a read-only attribute.&#34;&#34;&#34;
        return self._storage_policy_id

    @property
    def name(self):
        &#34;&#34;&#34;Returns the Storage Policy display name&#34;&#34;&#34;
        return self._storage_policy_properties[&#39;storagePolicy&#39;][&#39;storagePolicyName&#39;]

    @property
    def storage_policy_name(self):
        &#34;&#34;&#34;Treats the storage policy name as a read-only attribute.&#34;&#34;&#34;
        return self._storage_policy_name

    @property
    def description(self):
        &#34;&#34;&#34;Returns the Storage Policy Description Field&#34;&#34;&#34;
        if self._storage_policy_advanced_properties is None:
            self._storage_policy_advanced_properties = self._get_storage_policy_advanced_properties()
        return self._storage_policy_advanced_properties.get(&#39;policies&#39;,[{}])[0].get(&#39;description&#39;)

    def get_copy_precedence(self, copy_name):
        &#34;&#34;&#34; returns the copy precedence value associated with the copy name

            Args:
                copy_name           (str)   --  Storage copy name

            Returns:
                copy_precedence     (int)   --  Copy precedence number of
                storage copy

            Raises:
                Exception:
                    if unable to find the given copy name

        &#34;&#34;&#34;
        policy_copies = self.copies
        if policy_copies.get(copy_name):
            if policy_copies[copy_name].get(&#39;copyPrecedence&#39;):
                return policy_copies[copy_name][&#39;copyPrecedence&#39;]
        raise SDKException(
            &#39;Storage&#39;,
            &#39;102&#39;,
            &#39;Failed to get copy precedence from policy&#39;)

    def update_snapshot_options(self, **options):
        &#34;&#34;&#34;
        Method for Updating Storage Policy Snapshot Options like Backup Copy and Snapshot Catalog

        Args:
            Available Snapshot Options:

            enable_backup_copy               (bool)   --  Enables backup copy if the value is True

            source_copy_for_snap_to_tape     (str)    --  Source Copy name for backup copy

            enable_snapshot_catalog          (bool)   --  Enables Snapshot Catalog if value is True

            source_copy_for_snapshot_catalog (str)    --  Source Copy name for Snapshot Catalog

            is_ocum                          (bool)   --  True if Storage policy is enabled with
                                                          ocum server
            enable_selective_copy                 (int)   -- Enable selective copy option based on input value

            disassociate_sc_from_backup_copy    (bool)    -- Associate/Disassociate subclient from backup copy
                                                                True: Disassociate subclient
                                                                False: Associate subclient

        &#34;&#34;&#34;
        enable_backup_copy = options[&#39;enable_backup_copy&#39;]
        enable_snapshot_catalog = options[&#39;enable_snapshot_catalog&#39;]

        if options[&#39;is_ocum&#39;]:
            if enable_backup_copy and enable_snapshot_catalog:
                defferred_catalog_value = backup_copy_value = 16
            else:
                defferred_catalog_value = backup_copy_value = 3
        else:
            if enable_backup_copy:
                defferred_catalog_value = 16
                backup_copy_value = 3
            else:
                defferred_catalog_value = backup_copy_value = 3

        if options[&#39;source_copy_for_snap_to_tape&#39;] is not None:
            source_copy_for_snap_to_tape_id = self._copies[options[&#39;source_copy_for_snap_to_tape&#39;].lower()][&#39;copyId&#39;]
        else:
            source_copy_for_snap_to_tape_id = 0
        if options[&#39;source_copy_for_snapshot_catalog&#39;] is not None:
            source_copy_for_snapshot_catalog_id = self._copies[options[&#39;source_copy_for_snapshot_catalog&#39;].lower(
            )][&#39;copyId&#39;]
        else:
            source_copy_for_snapshot_catalog_id = 0

        selective_type = options.get(&#39;enable_selective_copy&#39;, 0)

        update_snapshot_tab_service = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

        if options[&#39;disassociate_sc_from_backup_copy&#39;] == True:
            disass_sc_xml = f&#34;&#34;&#34;
                               &lt;archGroupToAppListWithExclude _type_=&#34;2&#34;&gt;
                                    &lt;flags include=&#34;1&#34;/&gt;
                               &lt;/archGroupToAppListWithExclude&gt;
                               &lt;archGroupToAppListWithExclude _type_=&#34;27&#34;&gt;
                                    &lt;flags include=&#34;1&#34;/&gt;
                               &lt;/archGroupToAppListWithExclude&gt;
                           &lt;archGroupToAppListWithExclude _type_=&#34;7&#34; 
                           appName=&#34;{options[&#39;appName&#39;]}&#34; applicationId=&#34;{options[&#39;applicationId&#39;]}&#34;
                                backupsetId=&#34;{options[&#39;backupsetId&#39;]}&#34; backupsetName=&#34;{options[&#39;backupsetName&#39;]}&#34; 
                                clientId=&#34;{options[&#39;clientId&#39;]}&#34; clientName=&#34;{options[&#39;clientName&#39;]}&#34; instanceId=&#34;1&#34; 
                                instanceName=&#34;DefaultInstanceName&#34; 
                                subclientId=&#34;{options[&#39;subclientId&#39;]}&#34; subclientName=&#34;{options[&#39;subclientName&#39;]}&#34;&gt;
                                &lt;flags exclude=&#34;1&#34;/&gt;
                           &lt;/archGroupToAppListWithExclude&gt;&#34;&#34;&#34;

            request_xml = f&#34;&#34;&#34;
                        &lt;EVGui_SetSnapOpPropsReq deferredCatalogOperation=&#34;{defferred_catalog_value}&#34; snapshotToTapeOperation=&#34;{backup_copy_value}&#34;&gt;
                            &lt;header localeId=&#34;0&#34; userId=&#34;0&#34; /&gt;
                            &lt;snapshotToTapeProps archGroupId=&#34;{self.storage_policy_id}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                enable=&#34;{int(enable_backup_copy)}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                sourceCopyId=&#34;{source_copy_for_snap_to_tape_id}&#34; startTime=&#34;0&#34; type=&#34;{selective_type}&#34; &gt; &#34;&#34;&#34;.format(
                                    defferred_catalog_value,
                                    backup_copy_value,
                                    self.storage_policy_id,
                                    int(enable_backup_copy),
                                    source_copy_for_snap_to_tape_id, selective_type) + \
                          f&#34;&#34;&#34;{disass_sc_xml}
                            &lt;/snapshotToTapeProps&gt;                           
                        &lt;/EVGui_SetSnapOpPropsReq&gt;
                           &#34;&#34;&#34;

        elif options[&#39;disassociate_sc_from_backup_copy&#39;] == False:
            disass_sc_xml = f&#34;&#34;&#34;
                            &lt;archGroupToAppListWithExclude _type_=&#34;2&#34;&gt;
                                            &lt;flags include=&#34;1&#34;/&gt;
                                           &lt;/archGroupToAppListWithExclude&gt;
                                           &lt;archGroupToAppListWithExclude _type_=&#34;27&#34;&gt;
                                            &lt;flags include=&#34;1&#34;/&gt;
                                           &lt;/archGroupToAppListWithExclude&gt;&#34;&#34;&#34;

            request_xml = &#34;&#34;&#34;
                        &lt;EVGui_SetSnapOpPropsReq deferredCatalogOperation=&#34;{0}&#34; snapshotToTapeOperation=&#34;{1}&#34;&gt;
                                           &lt;header localeId=&#34;0&#34; userId=&#34;0&#34; /&gt;
                                           &lt;snapshotToTapeProps archGroupId=&#34;{2}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                               enable=&#34;{3}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                               sourceCopyId=&#34;{4}&#34; startTime=&#34;0&#34; type=&#34;{5}&#34; &gt; &#34;&#34;&#34;.format(
                        defferred_catalog_value,
                        backup_copy_value, self.storage_policy_id,
                        int(enable_backup_copy), source_copy_for_snap_to_tape_id, selective_type) + \
                        f&#34;&#34;&#34;{disass_sc_xml}
                                        &lt;/snapshotToTapeProps&gt;                                                                    
                                    &lt;/EVGui_SetSnapOpPropsReq&gt;
                           &#34;&#34;&#34;
        elif options[&#39;disassociate_sc_from_backup_copy&#39;] is None:
            request_xml = &#34;&#34;&#34;
                        &lt;EVGui_SetSnapOpPropsReq deferredCatalogOperation=&#34;{0}&#34; snapshotToTapeOperation=&#34;{1}&#34;&gt;
                                               &lt;header localeId=&#34;0&#34; userId=&#34;0&#34; /&gt;
                                               &lt;snapshotToTapeProps archGroupId=&#34;{2}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                                   enable=&#34;{3}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                                   sourceCopyId=&#34;{4}&#34; startTime=&#34;0&#34; type=&#34;{7}&#34; /&gt;
                                               &lt;deferredCatalogProps archGroupId=&#34;{2}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                                   enable=&#34;{5}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                                   sourceCopyId=&#34;{6}&#34; startTime=&#34;0&#34; type=&#34;0&#34; /&gt;
                                           &lt;/EVGui_SetSnapOpPropsReq&gt;
                               &#34;&#34;&#34;.format(defferred_catalog_value, backup_copy_value, self.storage_policy_id,
                                          int(enable_backup_copy), source_copy_for_snap_to_tape_id,
                                          int(enable_snapshot_catalog), source_copy_for_snapshot_catalog_id,
                                          selective_type)


        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, update_snapshot_tab_service, request_xml
        )

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 1:
                        error_message = &#34;Failed to Update {0} Storage Policy&#34;.format(
                            self.storage_policy_name
                        )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def run_backup_copy(self):
        &#34;&#34;&#34;
        Runs the backup copy from Commcell for the given storage policy

        Args:
                None

        Returns:
                object - instance of the Job class for this backup copy job
        Raises:
            SDKException:

                    if backup copy job failed

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        request_json = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ],
                &#34;task&#34;: {
                    &#34;initiatedFrom&#34;: 2,
                    &#34;taskType&#34;: 1,
                    &#34;policyType&#34;: 3,
                    &#34;taskFlags&#34;: {
                        &#34;disabled&#34;: False
                    }
                },
                &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1,
                        &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1,
                            &#34;operationType&#34;: 4028
                        },
                        &#34;options&#34;: {
                            &#34;adminOpts&#34;: {
                                &#34;snapToTapeOption&#34;: {
                                    &#34;allowMaximum&#34;: True,
                                    &#34;noofJobsToRun&#34;: 1
                                }
                            }
                        }
                    }
                ]
            }
        }

        backup_copy = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, backup_copy, request_json)

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;Backup copy job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;106&#39;, o_str)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;106&#39;, &#39;Failed to run the backup copy job&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;106&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def modify_dynamic_stream_allocation(self, enable=True):
        &#34;&#34;&#34;
        Modifies the DSA option for the Storage Policy
            Args:

                    enable      (bool)  --   False - Disable DSA
                                             True - Enable DSA
        &#34;&#34;&#34;
        request_xml = &#39;&#39;&#39;&lt;App_UpdateStoragePolicyReq&gt;
                       &lt;StoragePolicy&gt;
                           &lt;storagePolicyName&gt;{0}&lt;/storagePolicyName&gt;
                       &lt;/StoragePolicy&gt;
                       &lt;flag&gt;
                           &lt;distributeDataEvenlyAmongStreams&gt;{1}&lt;/distributeDataEvenlyAmongStreams&gt;
                       &lt;/flag&gt;
                       &lt;/App_UpdateStoragePolicyReq&gt;
                       &#39;&#39;&#39;.format(self.storage_policy_name, int(enable))
        self._commcell_object.qoperation_execute(request_xml)

    def run_snapshot_cataloging(self):
        &#34;&#34;&#34;
        Runs the deferred catalog job from Commcell for the given storage policy

        Args:
                None

        Returns:
                object - instance of the Job class for this snapshot cataloging job

        Raises:
            SDKException:

                    if snapshot cataloging job failed

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;

        request_json = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ],
                &#34;task&#34;: {
                    &#34;taskType&#34;: 1,
                    &#34;initiatedFrom&#34;: 2,
                    &#34;policyType&#34;: 0,
                    &#34;taskFlags&#34;: {
                        &#34;isEdgeDrive&#34;: False,
                        &#34;disabled&#34;: False
                    }
                },
                &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1,
                        &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1,
                            &#34;operationType&#34;: 4043
                        },
                        &#34;options&#34;: {
                            &#34;backupOpts&#34;: {
                                &#34;backupLevel&#34;: 2,
                                &#34;dataOpt&#34;: {
                                    &#34;useCatalogServer&#34;: True,
                                    &#34;enforceTransactionLogUsage&#34;: False
                                }
                            }
                        }
                    }
                ]
            }
        }

        snapshot_catalog = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, snapshot_catalog, request_json)

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;Deferred catalog job failed\nError: &#34;{0}&#34;&#39;.format(
                        error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;107&#39;, o_str)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;107&#39;, &#39;Failed to run the deferred catalog job&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;107&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def storage_policy_properties(self):
        &#34;&#34;&#34;Returns the storage policy properties

            dict - consists of storage policy properties
        &#34;&#34;&#34;
        return self._storage_policy_properties

    @property
    def storage_policy_advanced_properties(self):
        &#34;&#34;&#34;Returns the  storage policy advanced properties

            dict - consists of storage policy advanced properties
        &#34;&#34;&#34;
        if self._storage_policy_advanced_properties is None:
            self._storage_policy_advanced_properties = self._get_storage_policy_advanced_properties()
        return self._storage_policy_advanced_properties

    @property
    def library_name(self):
        &#34;&#34;&#34;Treats the library name as a read-only attribute.&#34;&#34;&#34;
        primary_copy = self._storage_policy_properties.get(&#39;copy&#39;)
        if &#39;library&#39; in primary_copy[0]:
            library = primary_copy[0].get(&#39;library&#39;, {})
            return library.get(&#39;libraryName&#39;)

    @property
    def library_id(self):
        &#34;&#34;&#34;Treats the library id as a read-only attribute.&#34;&#34;&#34;
        primary_copy = self._storage_policy_properties.get(&#39;copy&#39;)
        if &#39;library&#39; in primary_copy[0]:
            library = primary_copy[0].get(&#39;library&#39;, {})
            return library.get(&#39;libraryId&#39;)

    @property
    def aux_copies(self):
        &#34;&#34;&#34;
        Returns the list of all aux copies in the policy
        Returns:
            list - list of all aux copies in the storage policy
        &#34;&#34;&#34;
        aux_copies = []
        for _copy, value in self.copies.items():
            if not value[&#39;isSnapCopy&#39;] and _copy != &#39;primary&#39;:
                aux_copies.append(_copy)
        return aux_copies

    @property
    def snap_copy(self):
        &#34;&#34;&#34;
        Returns the name of the snap copy
        Returns:
            str - name of the snap copy
        &#34;&#34;&#34;
        snap_copy = None
        for _copy, value in self.copies.items():
            if value[&#39;isSnapCopy&#39;]:
                snap_copy = _copy
        return snap_copy

    def run_aux_copy(self, storage_policy_copy_name=None,
                     media_agent=None, use_scale=True, streams=0,
                     all_copies=True, total_jobs_to_process=1000, schedule_pattern=None, **kwargs):
        &#34;&#34;&#34;Runs the aux copy job from the commcell.
            Args:

                storage_policy_copy_name (str)  --  name of the storage policy copy

                media_agent              (str)  --  name of the media agent

                use_scale                (bool) --  use Scalable Resource Management (True/False)

                streams                  (int)  --  number of streams to use

                all_copies               (bool) -- run auxcopy job on all copies or select copy
                                                   (True/False)

                total_jobs_to_process    (int)  -- Total number jobs to process for the auxcopy job

                **kwargs    --  dict of keyword arguments as follows:
                ignore_dv_failed_jobs  (bool)  -- Ignore DV failed jobs
                job_description     (str)      -- Description for Job

            Returns:
                object - instance of the Job class for this aux copy job

            Raises:
                SDKException:
                    if type of the  argument is not string

                    if aux copy job failed

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(total_jobs_to_process, int) and
                isinstance(streams, int)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        use_max_streams = True
        if streams != 0:
            use_max_streams = False

        if storage_policy_copy_name is not None:
            all_copies = False
            if not media_agent:
                media_agent = &#34;&amp;lt;ANY MEDIAAGENT&amp;gt;&#34;
            if not (isinstance(storage_policy_copy_name, str) and
                    isinstance(media_agent, str)):
                raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        else:
            if all_copies is False:
                raise SDKException(&#39;Storage&#39;, &#39;110&#39;)
            storage_policy_copy_name = &#34;&#34;
            media_agent = &#34;&#34;

        ignore_dv_failed_jobs = False
        if kwargs.get(&#39;ignore_dv_failed_jobs&#39;) is True:
            ignore_dv_failed_jobs = True

        request_json = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;copyName&#34;: storage_policy_copy_name,
                        &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ],
                &#34;task&#34;: {
                    &#34;initiatedFrom&#34;: 2,
                    &#34;taskType&#34;: 1,
                    &#34;policyType&#34;: 0,
                    &#34;taskFlags&#34;: {
                        &#34;disabled&#34;: False
                    }
                },
                &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1,
                        &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1,
                            &#34;operationType&#34;: 4003
                        },
                        &#34;options&#34;: {
                            &#34;backupOpts&#34;: {
                                &#34;mediaOpt&#34;: {
                                    &#34;auxcopyJobOption&#34;: {
                                        &#34;maxNumberOfStreams&#34;: streams,
                                        &#34;useMaximumStreams&#34;: use_max_streams,
                                        &#34;useScallableResourceManagement&#34;: use_scale,
                                        &#34;totalJobsToProcess&#34;: total_jobs_to_process,
                                        &#34;ignoreDataVerificationFailedJobs&#34;: ignore_dv_failed_jobs,
                                        &#34;allCopies&#34;: all_copies,
                                        &#34;mediaAgent&#34;: {
                                            &#34;mediaAgentName&#34;: media_agent
                                        }
                                    }
                                }
                            },
                            &#34;commonOpts&#34;: {
                                &#34;jobDescription&#34;: kwargs.get(&#39;job_description&#39;, &#39;&#39;)
                            }
                        }
                    }
                ]
            }
        }

        if schedule_pattern:
            request_json = SchedulePattern().create_schedule(request_json, schedule_pattern)

        aux_copy = self._commcell_object._services[&#39;CREATE_TASK&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, aux_copy, request_json
        )

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;Restore job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)

                elif &#34;taskId&#34; in response.json():
                    return Schedules(self._commcell_object).get(task_id=response.json()[&#39;taskId&#39;])

                else:
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, &#39;Failed to run the aux copy job&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)

        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def refresh(self):
        &#34;&#34;&#34;Refresh the properties of the StoragePolicy.&#34;&#34;&#34;
        self._initialize_storage_policy_properties()
        self._storage_policy_advanced_properties = None

    def seal_ddb(self, copy_name):
        &#34;&#34;&#34;
        Seals the deduplication database

            Args:
                copy_name   (str)   --  name of the storage policy copy

            Raises:
                SDKException:
                    if type of input parameters is not string
        &#34;&#34;&#34;
        if not isinstance(copy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_xml = &#34;&#34;&#34;
        &lt;App_SealSIDBStoreReq&gt;
            &lt;archiveGroupCopy&gt;
                &lt;copyName&gt;{0}&lt;/copyName&gt;
                &lt;storagePolicyName&gt;{1}&lt;/storagePolicyName&gt;
            &lt;/archiveGroupCopy&gt;
        &lt;/App_SealSIDBStoreReq&gt;

        &#34;&#34;&#34;.format(copy_name, self.storage_policy_name)
        self._commcell_object._qoperation_execute(request_xml)

    def update_transactional_ddb(self, update_value, copy_name, media_agent_name):
        &#34;&#34;&#34;
        Updates TransactionalDDB option on the deduplication database

            Args:
                update_value    (bool)   --   enable(True)/disable(False)

                copy_name       (str)   --   name of the associated copy

                media_agent_name(str)   --   name of the media agent

            Raises:
                SDKException:
                    if type of input parameters is not string
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and isinstance(media_agent_name, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_xml = &#34;&#34;&#34;
        &lt;App_UpdateStoragePolicyCopyReq &gt;
            &lt;storagePolicyCopyInfo &gt;
                &lt;StoragePolicyCopy&gt;
                    &lt;copyName&gt;{0}&lt;/copyName&gt;
                    &lt;storagePolicyName&gt;{1}&lt;/storagePolicyName&gt;
                &lt;/StoragePolicyCopy&gt;
                &lt;DDBPartitionInfo&gt;
                    &lt;maInfoList&gt;
                        &lt;mediaAgent&gt;
                            &lt;mediaAgentName&gt;{2}&lt;/mediaAgentName&gt;
                        &lt;/mediaAgent&gt;
                            &lt;/maInfoList&gt;
                            &lt;sidbStoreInfo&gt;
                                &lt;sidbStoreFlags&gt;
                            &lt;enableTransactionalDDB&gt;{3}&lt;/enableTransactionalDDB&gt;
                        &lt;/sidbStoreFlags&gt;
                            &lt;/sidbStoreInfo&gt;
                    &lt;/DDBPartitionInfo&gt;
           &lt;/storagePolicyCopyInfo&gt;
        &lt;/App_UpdateStoragePolicyCopyReq&gt;
        &#34;&#34;&#34;.format(copy_name, self.storage_policy_name, media_agent_name, int(update_value))

        self._commcell_object._qoperation_execute(request_xml)

    def create_dedupe_secondary_copy(self, copy_name, library_name,
                                     media_agent_name, path, ddb_media_agent,
                                     dash_full=None,
                                     source_side_disk_cache=None,
                                     software_compression=None):
        &#34;&#34;&#34;Creates Synchronous copy for this storage policy

            Args:
                copy_name               (str)   --  copy name to create

                library_name            (str)   --  library name to be assigned

                media_agent_name        (str)   --  media_agent to be assigned

                path                    (str)   --  path where deduplication store is to be hosted

                ddb_media_agent         (str)   --  media agent name on which deduplication store
                                                    is to be hosted

                dash_full               (bool)  --  enable DASH full on deduplication store (True/False)
                Default None

                source_side_disk_cache  (bool)  -- enable source side disk cache (True/False)
                Default None

                software_compression    (bool)  -- enable software compression (True/False)
                Default None

            Raises:
                SDKException:
                    if type of inputs in not string

                    if copy with given name already exists

                    if failed to create copy

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and
                isinstance(library_name, str) and
                isinstance(path, str) and
                isinstance(ddb_media_agent, str) and
                isinstance(media_agent_name, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if dash_full is None:
            dash_full = &#34;2&#34;
        if source_side_disk_cache is None:
            source_side_disk_cache = &#34;2&#34;
        if software_compression is None:
            software_compression = &#34;2&#34;

        if self.has_copy(copy_name):
            err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        library_id = self._commcell_object.disk_libraries.get(library_name).library_id
        media_agent_id = self._commcell_object.media_agents._media_agents[media_agent_name][&#39;id&#39;]

        request_xml = &#34;&#34;&#34;
        &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
            &lt;storagePolicyCopyInfo copyType=&#34;0&#34; isDefault=&#34;0&#34;&gt;
                &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                &lt;copyFlags auxCopyReencryptData=&#34;0&#34; /&gt;
                &lt;dedupeFlags enableDeduplication=&#34;1&#34; enableDASHFull=&#34;{9}&#34; enableSourceSideDiskCache=&#34;{10}&#34;/&gt;
                &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;1&#34; retainBackupDataForDays=&#34;30&#34; /&gt;
                &lt;DDBPartitionInfo&gt;
                    &lt;maInfoList&gt;
                        &lt;mediaAgent mediaAgentName=&#34;{8}&#34;/&gt;
                        &lt;subStoreList&gt;
                            &lt;diskFreeThresholdMB&gt;5120&lt;/diskFreeThresholdMB&gt;
                            &lt;diskFreeWarningThreshholdMB&gt;10240&lt;/diskFreeWarningThreshholdMB&gt;
                            &lt;accessPath path=&#34;{7}&#34;/&gt;
                        &lt;/subStoreList&gt;
                    &lt;/maInfoList&gt;
                    &lt;sidbStoreInfo&gt;
                        &lt;operation&gt;1&lt;/operation&gt;
                        &lt;copyName&gt;{0}&lt;/copyName&gt;
                        &lt;sidbStoreFlags enableSoftwareCompression=&#34;{11}&#34;/&gt;
                    &lt;/sidbStoreInfo&gt;
                &lt;/DDBPartitionInfo&gt;

            &lt;/storagePolicyCopyInfo&gt;
        &lt;/App_CreateStoragePolicyCopyReq&gt;
        &#34;&#34;&#34;.format(copy_name, self._storage_policy_id, self.storage_policy_name,
                   library_id, library_name, media_agent_id, media_agent_name,
                   path, ddb_media_agent, int(dash_full),
                   int(source_side_disk_cache), int(software_compression))

        create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, create_copy_service, request_xml
        )

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = &#34;Failed to create {0} Storage Policy copy with error \
                            {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                        else:
                            error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                                copy_name
                            )

                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def run_ddb_verification(self,
                             copy_name,
                             ver_type,
                             ddb_ver_level,
                             use_scalable=True,
                             orphan_chunk_listing=False):
        &#34;&#34;&#34;
        Runs DDB verification job

            Args:
                copy_name       (str)   --  name of the copy which is associated with the DDB store

                ver_type        (str)   --  backup level (Full/Incremental)

                ddb_ver_level   (str)   --  DDB verification type
                                            (DDB_VERIFICATION/ DDB_AND_DATA_VERIFICATION /
                                            QUICK_DDB_VERIFICATION/ DDB_DEFRAGMENTATION)

                use_scalable    (bool)  --  True/False to use Scalable Resource Allocation
                                            Default: True

                orphan_chunk_listing (bool) --  True/False to run orphan chunk listing phase during DDB Defragmentation

            Returns:
                object - instance of the Job class for this DDB verification job

            Raises:
                SDKException:
                    if type of input parameters is not string

                    if job failed

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and
                isinstance(ver_type, str) and
                isinstance(ddb_ver_level, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        run_defrag = False
        if ddb_ver_level == &#39;DDB_DEFRAGMENTATION&#39;:
            run_defrag = True
        request = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;copyName&#34;: copy_name, &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ], &#34;task&#34;: {
                    &#34;taskType&#34;: 1,
                    &#34;initiatedFrom&#34;: 1,
                    &#34;policyType&#34;: 0,
                    &#34;taskId&#34;: 0,
                    &#34;taskFlags&#34;: {
                        &#34;disabled&#34;: False
                    }
                }, &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1, &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1, &#34;operationType&#34;: 4007
                        },
                        &#34;options&#34;: {
                            &#34;backupOpts&#34;: {
                                &#34;mediaOpt&#34;: {
                                    &#34;auxcopyJobOption&#34;: {
                                        &#34;maxNumberOfStreams&#34;: 0,
                                        &#34;allCopies&#34;: True,
                                        &#34;useMaximumStreams&#34;: True,
                                        &#34;useScallableResourceManagement&#34;: use_scalable,
                                        &#34;mediaAgent&#34;: {
                                            &#34;mediaAgentName&#34;: &#34;&#34;
                                        }
                                    }
                                }
                            }, &#34;adminOpts&#34;: {
                                &#34;archiveCheckOption&#34;: {
                                    &#34;ddbVerificationLevel&#34;: ddb_ver_level,
                                    &#34;jobsToVerify&#34;: 0,
                                    &#34;allCopies&#34;: True,
                                    &#34;backupLevel&#34;: ver_type,
                                    &#34;ocl&#34;: orphan_chunk_listing,
                                    &#34;runDefrag&#34;: run_defrag
                                }
                            }
                        }
                    }
                ]
            }
        }
        data_verf = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, data_verf, request
        )

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;DDB verification job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;109&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def run_data_verification(self, media_agent_name=&#39;&#39;, copy_name=&#39;&#39;, streams=0,
                              jobs_to_verify=&#39;NEW&#39;, use_scalable=True, schedule_pattern=None, **kwargs):
        &#34;&#34;&#34;Runs Data verification job

        Args:
            media_agent_name    (str)  : name of the mediaAgent to use for data reading

            copy_name           (str)  : name of Copy
                                         (default - verifies jobs on all copies)

            streams             (int)  : number of streams to use
                                         (default - use Maximum)

            jobs_to_verify      (str)  : jobs to be Verified
                                         (NEW/ VERF_EXPIRED/ ALL)

            use_scalable       (bool) : True/False to use Scalable Resource Allocation
                                         (default - True)

            kwargs              (dict) : optional arguments
                Available kwargs Options:
                    job_description     (str): Description for Job

        Returns:
            object - instance of the Job class for this Data Verification Job

            errorMessage - If Data Verification Job fails to Start
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and isinstance(jobs_to_verify, str)
                and isinstance(media_agent_name, str) and isinstance(streams, int)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if jobs_to_verify.upper() == &#39;NEW&#39;:
            jobs_to_verify = &#39;NEWLY_AVAILABLE&#39;
        elif jobs_to_verify.upper() == &#39;VERF_EXPIRED&#39;:
            jobs_to_verify = &#39;VERIFICATION_EXP&#39;
        elif jobs_to_verify.upper() == &#39;ALL&#39;:
            jobs_to_verify = &#39;BOTH_NEWLY_AVAILABLE_AND_VERIFICATION_EXP&#39;

        request = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;copyName&#34;: copy_name,
                        &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ],
                &#34;task&#34;: {},
                &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1,
                        &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1,
                            &#34;operationType&#34;: 4007
                        },
                        &#34;options&#34;: {
                            &#34;backupOpts&#34;: {
                                &#34;mediaOpt&#34;: {
                                    &#34;auxcopyJobOption&#34;: {
                                        &#34;maxNumberOfStreams&#34;: streams,
                                        &#34;useMaximumStreams&#34;: not bool(streams),
                                        &#34;useScallableResourceManagement&#34;: use_scalable,
                                        &#34;mediaAgent&#34;: {
                                            &#34;mediaAgentName&#34;: media_agent_name
                                        }
                                    }
                                }
                            },
                            &#34;adminOpts&#34;: {
                                &#34;archiveCheckOption&#34;: {
                                    &#34;jobsToVerify&#34;: jobs_to_verify,
                                }
                            },
                            &#34;commonOpts&#34;: {
                                &#34;jobDescription&#34;: kwargs.get(&#39;job_description&#39;,&#39;&#39;)
                            }
                        }
                    }
                ]
            }
        }

        if schedule_pattern:
            request[&#34;taskInfo&#34;][&#34;task&#34;] = {&#34;taskType&#34;: 2}
            request = SchedulePattern().create_schedule(request, schedule_pattern)

        data_verf = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, data_verf, request
        )
        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]
                    o_str = &#39;Data verification Request failed. Error: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
                elif &#34;taskId&#34; in response.json():
                    return Schedules(self._commcell_object).get(task_id=response.json()[&#39;taskId&#39;])
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;109&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def move_dedupe_store(self,
                          copy_name,
                          dest_path,
                          src_path,
                          dest_media_agent,
                          src_media_agent,
                          config_only=False):
        &#34;&#34;&#34;
        Moves a deduplication store

            Args:
                copy_name               (str)   -- name of the storage policy copy

                dest_path:              (str)   -- path where new partition is to be hosted

                src_path:               (str)   -- path where existing partition is hosted

                dest_media_agent:       (str)   -- media agent name where new partition is to be hosted

                src_media_agent:        (str)   -- media agent name where existing partition is hosted

                config_only             (bool)  -- to only chnage in DB (files need to be moved manually) (True/False)
                Default : False

            Returns:
                object - object - instance of the Job class for this DDB move job

            Raises:
                SDKException:
                    if type of input parameters is not string

                    if job failed

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and
                isinstance(dest_path, str) and
                isinstance(src_path, str) and
                isinstance(dest_media_agent, str) and
                isinstance(src_media_agent, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;copyName&#34;: copy_name, &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ], &#34;task&#34;: {
                    &#34;taskType&#34;: 1,
                    &#34;initiatedFrom&#34;: 1,
                    &#34;policyType&#34;: 0,
                    &#34;taskId&#34;: 0,
                    &#34;taskFlags&#34;: {
                        &#34;disabled&#34;: False
                    }
                }, &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1, &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1, &#34;operationType&#34;: 5013
                        }, &#34;options&#34;: {
                            &#34;adminOpts&#34;: {
                                &#34;libraryOption&#34;: {
                                    &#34;operation&#34;: 20, &#34;ddbMoveOption&#34;: {
                                        &#34;flags&#34;: 2, &#34;subStoreList&#34;: [
                                            {
                                                    &#34;srcPath&#34;: src_path,
                                                    &#34;changeOnlyDB&#34;: config_only,
                                                    &#34;destPath&#34;: dest_path,
                                                    &#34;destMediaAgent&#34;: {
                                                        &#34;name&#34;: dest_media_agent
                                                    }, &#34;srcMediaAgent&#34;: {
                                                        &#34;name&#34;: src_media_agent
                                                    }
                                            }
                                        ]
                                    }
                                }
                            }
                        }
                    }
                ]
            }
        }
        ddb_move = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, ddb_move, request
        )

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;DDB move job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;108&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def add_ddb_partition(self,
                          copy_id,
                          sidb_store_id,
                          sidb_new_path,
                          media_agent):
        &#34;&#34;&#34;
        Adds a new DDB partition
            Args:
                copy_id         (str)   -- storage policy copy id

                sidb_store_id   (str)   -- deduplication store id

                sidb_new_path   (str)   -- path where new partition is to be hosted

                media_agent     (str)   -- media agent on which new partition is to be hosted

            Raises:
                SDKException:
                    if type of input parameters is not string
        &#34;&#34;&#34;
        if not (isinstance(copy_id, str) and
                isinstance(sidb_store_id, str) and
                isinstance(sidb_new_path, str) and
                isinstance(media_agent, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if isinstance(media_agent, MediaAgent):
            media_agent = media_agent
        elif isinstance(media_agent, str):
            media_agent = MediaAgent(self._commcell_object, media_agent)

        request_xml = &#34;&#34;&#34;
        &lt;EVGui_ParallelDedupConfigReq commCellId=&#34;2&#34; copyId=&#34;{0}&#34; operation=&#34;15&#34;&gt;
        &lt;SIDBStore SIDBStoreId=&#34;{1}&#34;/&gt;
        &lt;dedupconfigItem commCellId=&#34;0&#34;&gt;
        &lt;maInfoList&gt;&lt;clientInfo id=&#34;{2}&#34; name=&#34;{3}&#34;/&gt;
        &lt;subStoreList&gt;&lt;accessPath path=&#34;{4}&#34;/&gt;
        &lt;/subStoreList&gt;&lt;/maInfoList&gt;&lt;/dedupconfigItem&gt;
        &lt;/EVGui_ParallelDedupConfigReq&gt;

        &#34;&#34;&#34;.format(copy_id, sidb_store_id, media_agent.media_agent_id,
                   media_agent.media_agent_name, sidb_new_path)
        self._commcell_object._qoperation_execute(request_xml)

    def get_copy(self, copy_name):
        &#34;&#34;&#34;Returns a storage policy copy object if copy exists

            Args:
               copy_name (str)  --  name of the storage policy copy

            Returns:
               object - instance of the StoragePolicyCopy class for the given copy name

            Raises:
               SDKException:
                   if type of the copy name argument is not string

                   if no copy exists with the given name
        &#34;&#34;&#34;
        if not isinstance(copy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if self.has_copy(copy_name):
            return StoragePolicyCopy(self._commcell_object, self.storage_policy_name, copy_name)
        else:
            raise SDKException(
                &#39;Storage&#39;, &#39;102&#39;, &#39;No copy exists with name: {0}&#39;.format(copy_name)
            )

    def get_primary_copy(self):
        &#34;&#34;&#34;Returns the primary copy of the storage policy

            Returns:
                object  -   Instance of the StoragePolicyCopy class of the primary copy

            Raises:
               SDKException:
                   if unable to find a primary copy in the storage policy

        &#34;&#34;&#34;

        for copy_name, copy_info in self.copies.items():
            if copy_info[&#39;isDefault&#39;]:
                return self.get_copy(copy_name)

        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, &#39;Unable to find a primary copy in the storage policy&#39;)

    def get_secondary_copies(self):
        &#34;&#34;&#34;Returns all the secondary copies in the storage policy sorted by copy precedence

            Returns:
                list    -   A list of storage policy copy instances.

        &#34;&#34;&#34;

        sorted_copies = sorted(self.copies.items(), key=lambda x: x[1][&#39;copyPrecedence&#39;])  # Sort by copy precedence
        result = []

        for copy_name, copy_info in sorted_copies:
            if not copy_info[&#39;isDefault&#39;] and not copy_info[&#39;isSnapCopy&#39;]:  # Skip primary copy and snap primary copies
                copy_obj = self.get_copy(copy_name)
                result.append(copy_obj)

        return result

    def delete_job(self, job_id, commcell_id=2):
        &#34;&#34;&#34;Deletes a job on Storage Policy

            Args:
                job_id          (str)   --  ID for the job to be deleted

                commcell_id     (str)   --  The commcell ID of the job to be deleted

            Raises:
                SDKException:
                    if type of input parameters is not string

        &#34;&#34;&#34;

        if not isinstance(job_id, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        job_list_tag = &#39;&#39;
        for copy_name, copy_info in self.copies.items():
            job_list_tag += f&#34;&#34;&#34;&lt;jobList appType=&#34;&#34; commCellId=&#34;{commcell_id}&#34; jobId=&#34;{job_id}&#34;&gt;
            &lt;copyInfo copyName=&#34;{copy_name}&#34; storagePolicyName=&#34;{self.storage_policy_name}&#34;/&gt;&lt;/jobList&gt;&#34;&#34;&#34;

        request_xml = f&#34;&#34;&#34;&lt;App_JobOperationCopyReq operationType=&#34;2&#34;&gt;{job_list_tag}
        &lt;commCellInfo commCellId=&#34;{commcell_id}&#34;/&gt;
        &lt;/App_JobOperationCopyReq&gt;
        &#34;&#34;&#34;

        self._commcell_object._qoperation_execute(request_xml)

    def mark_for_recovery(self, store_id, sub_store_id, media_agent_name, dedupe_path):
        &#34;&#34;&#34; Marks Deduplication store for recovery

            Args:
               store_id         (str)  --  SIDB store id

               sub_store_id     (str)  --  SIDB substore id

               media_agent_name (str)  --  name of the media agent on which DDB is hosted

               dedupe_path      (str)  --  SIDB store path
        &#34;&#34;&#34;

        request_xml = &#34;&#34;&#34;
                &lt;EVGui_IdxSIDBSubStoreOpReq&gt;&lt;info SIDBStoreId=&#34;{0}&#34; SubStoreId=&#34;{1}&#34; opType=&#34;1&#34; path=&#34;{3}&#34;&gt;
                &lt;mediaAgent name=&#34;{2}&#34;/&gt;
                &lt;/info&gt;
                &lt;/EVGui_IdxSIDBSubStoreOpReq&gt;
                &#34;&#34;&#34;.format(store_id, sub_store_id, media_agent_name, dedupe_path)
        self._commcell_object._qoperation_execute(request_xml)

    def run_recon(self, copy_name, sp_name, store_id, full_reconstruction=0, use_scalable_resource=&#39;false&#39;):
        &#34;&#34;&#34; Runs non-mem DB Reconstruction job

            Args:
               copy_name    (str)  --  name of the storage policy copy

               sp_name      (str)  --  name of the storage policy

               store_id     (str)  --  SIDB store id associated with the copy

               full_reconstruction      (int)  --  flag to enable full reconstruction job
                                                   Valid values:
                                                   0: to start regular reconstruction job
                                                   1: to start full reconstruction job

               use_scalable_resource    (str)  --  to enable scalable resources
                                                   Valid values:
                                                   &#39;true&#39;: to start old way reconstruction job
                                                   &#39;false&#39;: to start reconstruction job with scalable resources
        &#34;&#34;&#34;
        request_xml = &#34;&#34;&#34;
        &lt;TMMsg_DedupSyncTaskReq flags=&#34;0&#34;&gt;
            &lt;taskInfo&gt;&lt;associations _type_=&#34;0&#34; appName=&#34;&#34; applicationId=&#34;0&#34; backupsetId=&#34;0&#34; backupsetName=&#34;&#34;
            clientId=&#34;0&#34; clientName=&#34;&#34; clientSidePackage=&#34;1&#34; commCellId=&#34;0&#34; consumeLicense=&#34;1&#34; copyName=&#34;{0}&#34;
            instanceId=&#34;1&#34; instanceName=&#34;&#34; srmReportSet=&#34;0&#34; srmReportType=&#34;0&#34; storagePolicyName=&#34;{1}&#34;
            subclientId=&#34;0&#34; subclientName=&#34;&#34; type=&#34;0&#34;/&gt;
            &lt;subTasks&gt;
                &lt;options&gt;
                    &lt;adminOpts&gt;
                        &lt;contentIndexingOption subClientBasedAnalytics=&#34;0&#34;/&gt;
                        &lt;dedupDBSyncOption SIDBStoreId=&#34;{2}&#34;/&gt;
                        &lt;reconstructDedupDBOption allowMaximum=&#34;0&#34; flags=&#34;{4}&#34; noOfStreams=&#34;0&#34; useScallableResourceManagement=&#34;{3}&#34;&gt;
                        &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;0&#34; mediaAgentName=&#34;&amp;lt;ANY MEDIAAGENT&gt;&#34;/&gt;
                        &lt;/reconstructDedupDBOption&gt;
                    &lt;/adminOpts&gt;
                    &lt;restoreOptions&gt;
                        &lt;virtualServerRstOption isBlockLevelReplication=&#34;0&#34;/&gt;
                    &lt;/restoreOptions&gt;
                &lt;/options&gt;
                &lt;subTask operationType=&#34;4036&#34; subTaskType=&#34;1&#34;/&gt;
            &lt;/subTasks&gt;
            &lt;task initiatedFrom=&#34;1&#34; ownerId=&#34;1&#34; ownerName=&#34;admin&#34; policyType=&#34;0&#34; sequenceNumber=&#34;0&#34;
            taskId=&#34;0&#34; taskType=&#34;1&#34;&gt;&lt;taskFlags disabled=&#34;0&#34;/&gt;
            &lt;/task&gt;
            &lt;/taskInfo&gt;
        &lt;/TMMsg_DedupSyncTaskReq&gt;
        &#34;&#34;&#34;.format(copy_name, sp_name, store_id, use_scalable_resource, full_reconstruction)
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
        )

        if flag:
            if response.json():
                return response.json()

    def reassociate_all_subclients(self, dest_storage_policy_name=&#39;CV_DEFAULT&#39;):
        &#34;&#34;&#34;
        Reassociates all subclients associated to Storage Policy
        Args:
            dest_storage_policy_name(str):  Name of a Storage Policy to which the Subclients are to
                                            be reassociated.
                                            Default Value:
                                            &#39;CV_DEFAULT&#39;: &#39;Not Assigned&#39; to any Policy.
        Raises:
            SDKException    :   If failed to reassociate
        &#34;&#34;&#34;
        request_json = {
            &#34;App_ReassociateStoragePolicyReq&#34;: {
                &#34;forceNextBkpToFull&#34;: True,
                &#34;newStoragePolicy&#34;: {
                    &#34;storagePolicyName&#34;: dest_storage_policy_name
                },
                &#34;currentStoragePolicy&#34;: {
                    &#34;storagePolicyName&#34;: self.storage_policy_name
                }
            }
        }
        reassociate_subclients = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, reassociate_subclients, request_json
        )
        if flag:
            if response.json():
                if &#39;errorCode&#39; in response.json():
                    error_code = int(response.json()[&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to Reassociate the Subclients&#34;
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        self.refresh()

    def start_over(self):
        &#34;&#34;&#34;
        performs a start over operation on the specified storage policy/gdsp

            Args:

            Raises:
                  SDKException -- if response is bad/ flag is false

        returns None
        &#34;&#34;&#34;
        dependent_flag = self.storage_policy_properties[&#34;copy&#34;][0][&#34;dedupeFlags&#34;].get(&#34;useGlobalDedupStore&#34;, 0)
        if dependent_flag == 1:
            raise Exception(&#34;Dependent policy cannot be started over ...&#34;)

        request = {
            &#34;MediaManager_MMStartOverReq&#34;: {
                    &#34;bSealDDB&#34;: True,
                    &#34;storagePolicy&#34;: {
                        &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                }
            }

        startover = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, startover, request
        )

        if flag:
            if response.json():
                if &#39;errorCode&#39; in response.json():
                    error_code = int(response.json()[&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to Start Over&#34;
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        self.refresh()

    def run_data_forecast(self, **kwargs):
        &#34;&#34;&#34;runs data forecast and retention report generation operation

            Args:

                **kwargs    --  dict of keyword arguments as follows:

                    localeName      str     localeName for report [defaults to &#34;en-us&#34;]

            Raises:
                  SDKException -- if response is bad/ flag is false

            Returns None
                &#34;&#34;&#34;
        request = {
                    &#34;processinginstructioninfo&#34;: {},
                    &#34;taskInfo&#34;: {
                        &#34;task&#34;: {
                            &#34;taskType&#34;: 1,
                            &#34;initiatedFrom&#34;: 2,
                            &#34;taskFlags&#34;: {
                                &#34;disabled&#34;: False
                            }
                        },
                        &#34;appGroup&#34;: {},
                        &#34;subTasks&#34;: [
                            {
                                &#34;subTaskOperation&#34;: 1,
                                &#34;subTask&#34;: {
                                    &#34;subTaskName&#34;: &#34;&#34;,
                                    &#34;subTaskType&#34;: 1,
                                    &#34;operationType&#34;: 4004
                                },
                                &#34;options&#34;: {
                                    &#34;adminOpts&#34;: {
                                        &#34;reportOption&#34;: {
                                            &#34;showHiddenStoragePolicies&#34;: False,
                                            &#34;showGlobalStoragePolicies&#34;: False,
                                            &#34;storagePolicyCopyList&#34;: [
                                                {
                                                    &#34;storagePolicyName&#34;: self.storage_policy_name
                                                }
                                            ],
                                            &#34;mediaInfoReport&#34;: {
                                                &#34;mediaLocIn&#34;: True,
                                                &#34;mediaLocOut&#34;: True
                                            },
                                            &#34;commonOpt&#34;: {
                                                &#34;dateFormat&#34;: &#34;mm/dd/yyyy&#34;,
                                                &#34;overrideDateTimeFormat&#34;: 0,
                                                &#34;reportType&#34;: 7738,
                                                &#34;summaryOnly&#34;: False,
                                                &#34;reportCustomName&#34;: &#34;&#34;,
                                                &#34;timeFormat&#34;: &#34;hh:mm:ss am/pm&#34;,
                                                &#34;onCS&#34;: True,
                                                &#34;locale&#34;: {
                                                    &#34;country&#34;: &#34;English&#34;,
                                                    &#34;language&#34;: &#34;UnitedStates&#34;,
                                                    &#34;localeName&#34;: kwargs.get(&#34;localeName&#34;, &#34;en-us&#34;)
                                                },
                                                &#34;outputFormat&#34;: {
                                                    &#34;outputType&#34;: 1,
                                                    &#34;isNetworkDrive&#34;: False
                                                }
                                            },
                                            &#34;computerSelectionList&#34;: {
                                                &#34;includeAll&#34;: True
                                            },
                                            &#34;jobSummaryReport&#34;: {
                                                &#34;subclientFilter&#34;: False
                                            },
                                            &#34;dataRetentionForecastReport&#34;: {
                                                &#34;pruneData&#34;: True,
                                                &#34;retainedBeyondBasicRet&#34;: False,
                                                &#34;forecastDays&#34;: 0,
                                                &#34;unPrunableData&#34;: True,
                                                &#34;sortByOption&#34;: 2
                                            },
                                            &#34;agentList&#34;: [
                                                {
                                                    &#34;type&#34;: 0,
                                                    &#34;flags&#34;: {
                                                        &#34;include&#34;: True
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                }
                            }
                        ]
                    }
                }

        forecast = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, forecast, request)

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;Failed to Run Data Forecast\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;108&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

class StoragePolicyCopy(object):
    &#34;&#34;&#34;Class for performing storage policy copy operations for a specific storage policy copy&#34;&#34;&#34;

    def __init__(self, commcell_object, storage_policy, copy_name, copy_id=None):
        &#34;&#34;&#34;Initialise the Storage Policy Copy class instance.

            Args:
                commcell_object (object)        --  instance of the Commcell class
                storage_policy  (str/object)    -- storage policy to which copy is associated with
                copy_name       (str)           -- copy name
                copy_id         (str)           -- copy ID
                Default : None

            Returns:
                object - instance of the StoragePolicyCopy class

        &#34;&#34;&#34;
        self._copy_name = copy_name.lower()
        self._commcell_object = commcell_object
        self._cvpysdk_object = self._commcell_object._cvpysdk_object
        self._services = self._commcell_object._services

        if isinstance(storage_policy, StoragePolicy):
            self.storage_policy = storage_policy
        else:
            self.storage_policy = StoragePolicy(self._commcell_object, storage_policy)

        self.storage_policy_id = self.storage_policy.storage_policy_id
        self._storage_policy_name = self.storage_policy.storage_policy_name
        self.storage_policy._initialize_storage_policy_properties()

        if copy_id is not None:
            self.copy_id = str(copy_id)
        else:
            self.copy_id = str(self.get_copy_id())

        self._copy_properties = None
        self._STORAGE_POLICY_COPY = self._services[&#39;STORAGE_POLICY_COPY&#39;] % (
            self.storage_policy_id, self.copy_id)
        self.refresh()

    def __repr__(self):
        &#34;&#34;&#34;String representation of the instance of this class.&#34;&#34;&#34;
        representation_string = &#39;Storage Policy Copy class instance for Storage Policy/ Copy: &#34;{0}/{1}&#34;&#39;
        return representation_string.format(self._storage_policy_name, self._copy_name)

    @property
    def all_copies(self):
        &#34;&#34;&#34;Returns dict of  the storage policy copy associated with this storage policy

            dict - consists of stoarge policy copy properties
                    &#34;copyType&#34;: copy_type,
                    &#34;active&#34;: active,
                    &#34;copyId&#34;: copy_id,
                    &#34;libraryName&#34;: library_name,
                    &#34;copyPrecedence&#34;: copy_precedence
        &#34;&#34;&#34;
        return self.storage_policy._copies[self._copy_name]

    def get_copy_id(self):
        &#34;&#34;&#34;Gets the storage policy id asscoiated with the storage policy&#34;&#34;&#34;
        return self.all_copies[&#34;copyId&#34;]

    def get_copy_Precedence(self):
        &#34;&#34;&#34;Gets the copyprecendence asscoiated with the storage policy copy&#34;&#34;&#34;
        return self.all_copies[&#34;copyPrecedence&#34;]

    @property
    def is_active(self):
        &#34;&#34;&#34;Gets whether the Storage Policy Copy is active or not&#34;&#34;&#34;
        return bool(self._copy_properties.get(&#39;active&#39;))

    @is_active.setter
    def is_active(self, active):
        &#34;&#34;&#34;Marks the Storage Policy Copy as active/inactive (True/False)
            Args:
                active    (bool):    mark the Storage Policy Copy as active/inactive (True/False)

            Raises:
                SDKException:
                    if failed to update the property

                    if the type of &#39;active&#39; input is not correct
        &#34;&#34;&#34;
        if not isinstance(active, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_properties[&#39;active&#39;] = int(active)
        self._set_copy_properties()

    def refresh(self):
        &#34;&#34;&#34;Refresh the properties of the StoragePolicy.&#34;&#34;&#34;
        self._get_copy_properties()

    def _get_request_json(self):
        &#34;&#34;&#34; Gets all the storage policy copy properties .

           Returns:
                dict - all storage policy copy properties put inside a dict

        &#34;&#34;&#34;
        self._copy_properties[&#34;StoragePolicyCopy&#34;][&#34;storagePolicyName&#34;] = self._storage_policy_name
        copy_json = {
            &#34;storagePolicyCopyInfo&#34;: self._copy_properties
        }
        return copy_json

    def _get_copy_properties(self):
        &#34;&#34;&#34;Gets the storage policy copy properties.

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;

        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, self._STORAGE_POLICY_COPY)
        if flag:
            if response.json() and &#39;copy&#39; in response.json():
                self._copy_properties = response.json()[&#39;copy&#39;]

                self._storage_policy_flags = self._copy_properties.get(&#39;StoragePolicyFlags&#39;)

                self._copy_flags = self._copy_properties.get(&#39;copyFlags&#39;)

                self._extended_flags = self._copy_properties.get(&#39;extendedFlags&#39;)

                self._data_path_config = self._copy_properties.get(&#39;dataPathConfiguration&#39;)

                self._media_properties = self._copy_properties.get(&#39;mediaProperties&#39;)

                self._retention_rules = self._copy_properties.get(&#39;retentionRules&#39;)

                self._data_encryption = self._copy_properties.get(&#39;dataEncryption&#39;)

                self._dedupe_flags = self._copy_properties.get(&#39;dedupeFlags&#39;)

                self._media_agent = self._copy_properties.get(&#39;mediaAgent&#39;)

            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, self._commcell_object._update_response_(response.text))

    def _set_copy_properties(self):
        &#34;&#34;&#34;sets the properties of this storage policy copy.

            Raises:
                SDKException:
                    if failed to update number properties for subclient

        &#34;&#34;&#34;
        request_json = self._get_request_json()
        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._STORAGE_POLICY_COPY,
                                                           request_json)
        self.refresh()
        if flag:
            if response.json():
                if &#34;response&#34; in response.json():
                    error_code = str(
                        response.json()[&#34;response&#34;][0][&#34;errorCode&#34;])

                    if error_code == &#34;0&#34;:
                        return True, &#34;0&#34;, &#34;&#34;
                    else:
                        error_message = &#34;&#34;

                        if &#34;errorString&#34; in response.json()[&#34;response&#34;][0]:
                            error_message = response.json(
                            )[&#34;response&#34;][0][&#34;errorString&#34;]

                        if error_message:
                            return (False, error_code, error_message)
                        else:
                            return (False, error_code, &#34;&#34;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;111&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def copy_name(self):
        &#34;&#34;&#34;Returns the name of the copy&#34;&#34;&#34;
        return self._copy_name

    @property
    def override_pool_retention(self):
        &#34;&#34;&#34;Returns if Override Pool Retention flag is set or not&#34;&#34;&#34;
        return bool(self._extended_flags.get(&#39;overRideGACPRetention&#39;, 0))

    @override_pool_retention.setter
    def override_pool_retention(self, override):
        &#34;&#34;&#34;Sets/Unsets the override Pool Retention Flag. Not Applicable for Storage Pool Copies

        Args:
            override(bool)  :   Override the pool Retention (True/False)
        &#34;&#34;&#34;
        self._extended_flags[&#39;overRideGACPRetention&#39;] = int(override)
        self._set_copy_properties()

    @property
    def copy_retention(self):
        &#34;&#34;&#34;Treats the copy retention as a read-only attribute.&#34;&#34;&#34;
        retention_values = {}
        retention_values[&#34;days&#34;] = self._retention_rules[&#39;retainBackupDataForDays&#39;]
        retention_values[&#34;cycles&#34;] = self._retention_rules[&#39;retainBackupDataForCycles&#39;]
        retention_values[&#34;archiveDays&#34;] = self._retention_rules[&#39;retainArchiverDataForDays&#39;]
        retention_values[&#34;jobs&#34;] = self._retention_rules[&#39;jobs&#39;]
        return retention_values

    @copy_retention.setter
    def copy_retention(self, retention_values):
        &#34;&#34;&#34;Sets the copy retention as the value provided as input.
            Args:
                retention_values    (tuple) --  retention values to be set on a copy

                    tuple:

                        **int** -   value to specify retainBackupDataForDays

                        **int** -   value to specify retainBackupDataForCycles

                        **int** -   value to specify retainArchiverDataForDays

                        **int** -   value to specify jobs

                    e.g. :
                         storage_policy_copy.copy_retention = (30, 15, 1, 8)

            Raises:
                SDKException:
                    if failed to update retention values on the copy

        &#34;&#34;&#34;
        if retention_values[0] &gt;= 0:
            self._retention_rules[&#39;retainBackupDataForDays&#39;] = retention_values[0]
        if retention_values[1] &gt;= 0:
            self._retention_rules[&#39;retainBackupDataForCycles&#39;] = retention_values[1]
        if retention_values[2] &gt;= 0:
            self._retention_rules[&#39;retainArchiverDataForDays&#39;] = retention_values[2]
        if len(retention_values) &gt; 3:
            self._retention_rules[&#39;jobs&#39;] = retention_values[3]
            if retention_values[3] &gt; 0:
                self._retention_rules[&#39;retentionFlags&#39;][&#39;jobBasedRetention&#39;] = 1
            else:
                self._retention_rules[&#39;retentionFlags&#39;][&#39;jobBasedRetention&#39;] = 0

        self._set_copy_properties()

    @property
    def copy_software_compression(self):
        &#34;&#34;&#34;Treats the copy software compression setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;compressionOnClients&#39; in self._extended_flags

    def set_copy_software_compression(self, value):
        &#34;&#34;&#34;Sets the copy software compression setting as the value provided as input.
            Args:
                value    (bool) --  software compression value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update compression values on copy

                    if the type of value input is not correct

        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if value is False:
            if &#39;compressionOnClients&#39; in self._extended_flags:
                self._extended_flags[&#39;compressionOnClients&#39;] = 0

        self._extended_flags[&#39;compressionOnClients&#39;] = int(value)
        self._set_copy_properties()

    @property
    def copy_dedupe_dash_full(self):
        &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;enableDASHFull&#39; in self._dedupe_flags

    @copy_dedupe_dash_full.setter
    def copy_dedupe_dash_full(self, value):
        &#34;&#34;&#34;Sets the copy deduplication setting as the value provided as input.
            Args:
                value    (bool) --  dash full value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update deduplication values on copy

                    if the type of value input is not correct

        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if value is False:
            if &#39;enableSourceSideDiskCache&#39; in self._dedupe_flags:
                self._dedupe_flags[&#39;enableSourceSideDiskCache&#39;] = 0

        self._dedupe_flags[&#39;enableDASHFull&#39;] = int(value)
        self._set_copy_properties()

    @property
    def copy_dedupe_disk_cache(self):
        &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;enableSourceSideDiskCache&#39; in self._dedupe_flags

    @copy_dedupe_disk_cache.setter
    def copy_dedupe_disk_cache(self, value):
        &#34;&#34;&#34;Sets the copy deduplication setting as the value provided as input.
            Args:
                value    (bool) --  disk cache value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update deduplication values on copy

                    if the type of value input is not correct
        &#34;&#34;&#34;

        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        self._dedupe_flags[&#39;enableSourceSideDiskCache&#39;] = int(value)

        self._set_copy_properties()

    @property
    def store_priming(self):
        &#34;&#34;&#34;Treats the copy store priming setting as a read-only attribute.&#34;&#34;&#34;
        return self._dedupe_flags.get(&#39;useDDBPrimingOption&#39;, 0) &gt; 0

    @store_priming.setter
    def store_priming(self, value):
        &#34;&#34;&#34;Sets the copy store priming setting as the value provided as input.
            Args:
                value    (bool) --  store priming flag to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update deduplication values on copy

                    if the type of value input is not correct

        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._dedupe_flags[&#39;useDDBPrimingOption&#39;] = int(value)

        self._set_copy_properties()

    @property
    def copy_client_side_dedup(self):
        &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;enableClientSideDedup&#39; in self._dedupe_flags

    @copy_client_side_dedup.setter
    def copy_client_side_dedup(self, value):
        &#34;&#34;&#34;Sets the copy deduplication setting as the value provided as input.
            Args:
                value    (bool) --  client side dedupe value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update deduplication values on copy

                    if the type of value input is not correct

        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._dedupe_flags[&#39;enableClientSideDedup&#39;] = int(value)

        self._set_copy_properties()

    def is_dedupe_enabled(self):
        &#34;&#34;&#34;
        checks whether deduplication is enabled on the give storage policy copy
        returns Boolean
        &#34;&#34;&#34;
        return bool(self._dedupe_flags.get(&#39;enableDeduplication&#39;, 0))

    @property
    def source_copy(self):
        &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
        return self._copy_properties.get(&#39;sourceCopy&#39;, {}).get(&#39;copyName&#39;)

    @source_copy.setter
    def source_copy(self, copy_name):
        &#34;&#34;&#34;Sets the source copy as provided in the input.

                    Args:
                    copy_name            (str)       name of the source copy

                    Raises:
                        SDKException:
                            if failed to update source on copy

                            if the type of input is not correct

        **************************************************************************************
        eg :-
                tertiary_copy.source_copy = &#34;secondary_copy&#34;

        &#34;&#34;&#34;
        policy = self._commcell_object.storage_policies.get(self._storage_policy_name)
        copy = policy.get_copy(copy_name)

        if not isinstance(copy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if not self._copy_properties.get(&#39;sourceCopy&#39;, False):
            self._copy_properties[&#39;sourceCopy&#39;] = {}

        self._copy_properties[&#39;sourceCopy&#39;][&#39;copyId&#39;] = copy.get_copy_id()
        self._copy_properties[&#39;sourceCopy&#39;][&#39;copyName&#39;] = copy.copy_name

        self._set_copy_properties()

    def set_encryption_properties(self, **props):
        &#34;&#34;&#34;sets copy encryption properties based on given inputs

            Args:

                **props         dict of keyword arguments as follows:

                    preserve            (Bool)      whether to set preserve source encryption or not    default:False

                    plain_text          (Bool)      whether to store as plaintext or not                default:False

                    network_encryption       (Bool)      whether to set network encryption or not       default:False

                    re_encryption          (Bool)      whether to set re-encryption or not              default:False

                    encryption_type            (str)       encryption type specification             default:&#34;BlowFish&#34;

                    encryption_length          (int)       encryption key length specification          default:128

            Returns:
                  SDKException:
                            if failed to set copy encryption
                            if the type of inputs are not correct

            ***********************************************************************************************************

            to preserve encryption --&gt; set_encryption_properties(preserve=True)

            to store as plaintext --&gt; set_encryption_properties(plaintext=True)

            to set network encryption --&gt; set_encryption_properties(plaintext=True, network_encryption=True,
                                                                    encryption_type=&#34;BlowFish&#34;, encryption_length=128)

            to set re-encryption --&gt; set_encryption_properties(re_encryption=True,
                                                               encryption_type=&#34;BlowFish&#34;, encryption_length=128)

            ***********************************************************************************************************

            &lt;Encryption_type&gt;   &lt;Encryption_length&gt;

            &#34;Blowfish&#34;                  128
            &#34;Blowfish&#34;                  256
            &#34;TwoFish&#34;                   128
            &#34;TwoFish&#34;                   256
            &#34;Serpent&#34;                   128
            &#34;Serpent&#34;                   256
            &#34;GOST&#34;                      256
            &#34;AES&#34;                       128
            &#34;AES&#34;                       256
            &#34;DES3&#34;                      192
        &#34;&#34;&#34;
        preserve = props.get(&#39;preserve&#39;, False)
        plain_text = props.get(&#39;plain_text&#39;, False)
        network_encryption = props.get(&#39;network_encryption&#39;, False)
        re_encryption = props.get(&#39;re_encryption&#39;, False)
        encryption_type = props.get(&#39;encryption_type&#39;, &#39;BlowFish&#39;)
        encryption_length = props.get(&#39;encryption_length&#39;, 128)

        if not isinstance(preserve, bool) or \
                not isinstance(plain_text, bool) or \
                not isinstance(network_encryption, bool) or \
                not isinstance(re_encryption, bool) or \
                not isinstance(encryption_type, str) or \
                not isinstance(encryption_length, int):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_flags[&#39;preserveEncryptionModeAsInSource&#39;] = int(preserve)
        self._copy_flags[&#39;auxCopyReencryptData&#39;] = int(re_encryption)
        self._copy_flags[&#39;storePlainText&#39;] = int(plain_text)
        self._copy_flags[&#39;encryptOnNetworkUsingSelectedCipher&#39;] = int(network_encryption)

        self._copy_properties[&#39;extendedFlags&#39;][&#39;encryptOnDependentPrimary&#39;] = 0

        if plain_text and not network_encryption:

            self._copy_properties[&#39;dataEncryption&#39;] = {}

        else:

            if &#34;dataEncryption&#34; not in self._copy_properties:
                self._copy_properties[&#34;dataEncryption&#34;] = {
                    &#34;encryptData&#34;: 0
                }
                self._data_encryption = self._copy_properties[&#34;dataEncryption&#34;]

        if re_encryption or network_encryption:

            self._data_encryption[&#39;encryptData&#39;] = 1
            self._data_encryption[&#39;encryptionType&#39;] = encryption_type
            self._data_encryption[&#39;encryptionKeyLength&#39;] = encryption_length

            if re_encryption:
                self._copy_properties[&#39;extendedFlags&#39;][&#39;encryptOnDependentPrimary&#39;] = 1

        self._set_copy_properties()

    @property
    def copy_reencryption(self):
        &#34;&#34;&#34;Treats the secondary copy encryption as a read-only attribute.&#34;&#34;&#34;
        if &#39;auxCopyReencryptData&#39; in self._copy_flags:
            if self._copy_flags[&#39;auxCopyReencryptData&#39;] == 1:
                encryption_setting = &#34;True&#34;

        if &#39;preserveEncryptionModeAsInSource&#39; in self._copy_flags:
            if self._copy_flags[&#39;preserveEncryptionModeAsInSource&#39;] == 1:
                encryption_setting = &#34;False&#34;

        return encryption_setting

    @copy_reencryption.setter
    def copy_reencryption(self, encryption_values):
        &#34;&#34;&#34;Sets the secondary copy encryption as the value provided as input.
            Args:
                encryption_values    (tuple) --  encryption values to be set on a copy

                    tuple:

                        **bool** -   value to specify encrypt data [True/False]

                        **str** -   value to specify cipher type

                        **int** -   value to specify key length [128/256]

                        **int** -   value to specify GDSP dependent copy [True/False]

                    e.g. :
                        to enable encryption:
                            storage_policy_copy.copy_reencryption = (True, &#34;TWOFISH&#34;, &#34;128&#34;, False)

                        to disable encryption:
                            storage_policy_copy.copy_reencryption = (False, &#34;&#34;,0, False)

            Raises:
                SDKException:
                    if failed to update encryption settings for copy

                    if the type of value input is not correct
        &#34;&#34;&#34;
        if &#34;dataEncryption&#34; not in self._copy_properties:
            self._copy_properties[&#34;dataEncryption&#34;] = {
                &#34;encryptData&#34;: &#34;&#34;,
                &#34;encryptionType&#34;: &#34;&#34;,
                &#34;encryptionKeyLength&#34;: &#34;&#34;}
            self._data_encryption = self._copy_properties[&#34;dataEncryption&#34;]

        if not isinstance(encryption_values[0], bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if int(encryption_values[0]) == 0:
            if int(encryption_values[3]) == 1:
                self._copy_properties[&#39;extendedFlags&#39;][&#39;encryptOnDependentPrimary&#39;] = 0
            self._copy_properties[&#34;dataEncryption&#34;] = {
                &#34;encryptData&#34;: 0
            }
            self._copy_flags[&#39;auxCopyReencryptData&#39;] = 0
            self._copy_flags[&#39;preserveEncryptionModeAsInSource&#39;] = 1

        if int(encryption_values[0]) == 1:
            if (isinstance(encryption_values[1], str)
                    and isinstance(encryption_values[2], int)):
                self._copy_properties[&#39;extendedFlags&#39;][&#39;encryptOnDependentPrimary&#39;] = 1
                self._copy_flags[&#39;auxCopyReencryptData&#39;] = 1
                self._copy_flags[&#39;preserveEncryptionModeAsInSource&#39;] = 0
                self._data_encryption[&#39;encryptData&#39;] = 1
                self._data_encryption[&#39;encryptionType&#39;] = encryption_values[1]
                self._data_encryption[&#39;encryptionKeyLength&#39;] = encryption_values[2]
            else:
                raise SDKException(&#39;Response&#39;, &#39;110&#39;)

        self._set_copy_properties()

    @property
    def copy_precedence(self):
        &#34;&#34;&#34;Gets the copy precedence of the copy&#34;&#34;&#34;
        return self.all_copies[&#34;copyPrecedence&#34;]

    @property
    def media_agent(self):
        &#34;&#34;&#34;Gets the media agent name of the copy&#34;&#34;&#34;
        return self._media_agent.get(&#39;mediaAgentName&#39;)

    def get_jobs_on_copy(self, from_date=None, to_date=None, backup_type=None, retained_by=0,
                         include_to_be_copied_jobs=False, list_partial_jobs_only=False):
        &#34;&#34;&#34;Fetches the Details of jobs on Storage Policy Copy

        Args:
            from_date      (str): Start Date Range for the Jobs
                                    [format-&#39;yyyy/mm/dd&#39;] [default: from start]

            to_date        (str): End Date Range for the Jobs
                                    [format-&#39;yyyy/mm/dd&#39;] [default: till date]

            backup_type    (str): Filter by backup type [default: None(all backup types)]
                                    Valid values: &#39;full&#39;/&#39;incr&#39;

            retained_by    (int): Filter by retention type of jobs [default: 0]
                                    Valid values:
                                    1: basic retention
                                    2: extended retention
                                    4: manual retention

            include_to_be_copied_jobs   (bool): Include details on jobs that are in to be copied state [default: False]

            list_partial_jobs_only      (bool): Get details of jobs that are in partially copied state only
                                                  [default: False]

        Returns:
            (list)  :   List of dict&#39;s with each dict containing details of a job
        Raises:
            SDKException:   if the response/fetch operation failed
        &#34;&#34;&#34;
        command = f&#34;qoperation execscript -sn QS_JobsinSPCopy -si @i_policyName=&#39;{self._storage_policy_name}&#39;&#34; \
                  f&#34; -si @i_copyName=&#39;{self.copy_name}&#39;&#34;
        if from_date:
            command = f&#34;{command} -si @i_fromTime=&#39;{from_date}&#39;&#34;
        if to_date:
            command = f&#34;{command} -si @i_toTime=&#39;{to_date}&#39;&#34;
        if backup_type:
            command = f&#34;{command} -si @i_backupType=&#39;{backup_type.lower()}&#39;&#34;
        if retained_by:
            command = f&#34;{command} -si @i_retention=&#39;{retained_by}&#39;&#34;
        if include_to_be_copied_jobs:
            command = f&#34;{command} -si @i_includeToBeCopiedJobs=&#39;1&#39;&#34;
        if list_partial_jobs_only:
            command = f&#34;{command} -si @i_includePartialJobsOnly=&#39;1&#39;&#34;

        response = self._commcell_object.execute_qcommand(command)
        if response.json():
            json_response = response.json()
            if json_response.get(&#34;ExecScriptOutput&#34;):
                if isinstance(json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;), list):
                    return json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;)
                if isinstance(json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;), dict):
                    if json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;).get(&#34;@JobID&#34;):
                        return [json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;)]
                return []
            else:
                response_string = self._commcell_object._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;102&#39;, response_string)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def delete_job(self, job_id):
        &#34;&#34;&#34;
        Deletes a job on Storage Policy
            Args:
                job_id      (str)   --  ID for the job to be deleted

        Raises:
            SDKException:
                if type of input parameters is not string
        &#34;&#34;&#34;
        if not isinstance(job_id, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_xml = &#34;&#34;&#34;
        &lt;App_JobOperationCopyReq operationType=&#34;2&#34;&gt;
        &lt;jobList appType=&#34;&#34; commCellId=&#34;2&#34; jobId=&#34;{0}&#34;&gt;&lt;copyInfo copyName=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34;/&gt;&lt;/jobList&gt;
        &lt;commCellInfo commCellId=&#34;2&#34;/&gt;&lt;/App_JobOperationCopyReq&gt;
        &#34;&#34;&#34;.format(job_id, self._copy_name, self._storage_policy_name)

        self._commcell_object._qoperation_execute(request_xml)

    def _mark_jobs_on_copy(self, job_id, operation):
        &#34;&#34;&#34;Marks job(s) for given operation on a secondary copy

        Args:
            job_id      (int or str or list): Job Id(s) that needs to be marked
            operation   (str):  Operation that the job(s) needs to be marked for.
                                Operations Supported: (allowcopy/recopy/donotcopy/
                                markJobsBad/pickForVerification/donotPickForVerification)
        Raises:
            SDKException:
                if type of input parameters is not string or List of strings
        &#34;&#34;&#34;
        if not isinstance(job_id, str) and not isinstance(job_id, int):
            if not isinstance(job_id, list) or\
                    (not all(isinstance(id, int) for id in job_id) and not all(isinstance(id, str) for id in job_id)):
                raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        # send multiple requests to counter limit of URL length in IIS
        job_strings = []
        if isinstance(job_id, list):
            string = &#39;&#39;
            for id in job_id:
                string += f&#39;,{id}&#39;
                if len(string) &gt; 200:
                    job_strings.append(string.strip(&#39;,&#39;))
                    string = &#39;&#39;
            if string:
                job_strings.append(string.strip(&#39;,&#39;))
        else:
            job_strings.append(job_id)

        for string in job_strings:
            qcommand = f&#39; -sn MarkJobsOnCopy -si {self._storage_policy_name} -si {self._copy_name} -si {operation} -si {string}&#39;
            url = self._services[&#39;EXECUTE_QSCRIPT&#39;] % (qcommand)
            flag, response = self._commcell_object._cvpysdk_object.make_request(&#34;POST&#34;, url)
            if flag:
                if response.text:
                    if &#39;jobs do not belong&#39; in response.text.lower():
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, response.text.strip())
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                response_string = self._commcell_object._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def pick_for_copy(self, job_id):
        &#34;&#34;&#34;Marks job(s) to be Picked for Copy to a secondary copy

        Args:
            job_id      (int or str or list): Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;allowcopy&#39;)

    def recopy_jobs(self, job_id):
        &#34;&#34;&#34;Marks job(s) to be picked for ReCopying to a secondary copy

        Args:
            job_id      (int or str or list): Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;recopy&#39;)

    def do_not_copy_jobs(self, job_id):
        &#34;&#34;&#34;Marks job(s) as Do Not Copy to a secondary copy

        Args:
            job_id      (int or str or list):   Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;donotcopy&#39;)

    def pick_jobs_for_data_verification(self, job_id):
        &#34;&#34;&#34;Marks job(s) on a copy to be Picked for Data Verification

        Args:
            job_id      (int or str or list):   Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;pickForVerification&#39;)

    def do_not_verify_data(self, job_id):
        &#34;&#34;&#34;Marks job(s) on a copy to not be Picked for Data Verification

        Args:
            job_id      (int or str or list):   Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;donotPickForVerification&#39;)

    def mark_jobs_bad(self, job_id):
        &#34;&#34;&#34;Marks job(s) on a copy as Bad

        Args:
            job_id      (int or str or list):   Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;markJobsBad&#39;)

    def pick_jobs_for_backupcopy(self, job_id):
        &#34;&#34;&#34;This method is used to re-pick the job from backup which are unpick manually

        Args:
            job_id      (int or str or list):   Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;pickforbackupcopy&#39;)

    @property
    def extended_retention_rules(self):
        &#34;&#34;&#34;Treats the extended retention rules setting as a read-only attribute.&#34;&#34;&#34;

        mapping = {
            2: &#34;EXTENDED_ALLFULL&#34;,
            4: &#34;EXTENDED_WEEK&#34;,
            8: &#34;EXTENDED_MONTH&#34;,
            16: &#34;EXTENDED_QUARTER&#34;,
            32: &#34;EXTENDED_HALFYEAR&#34;,
            64: &#34;EXTENDED_YEAR&#34;,
            128: &#34;MANUALLY_PIN&#34;,
            256: &#34;EXTENDED_GRACE_WEEK&#34;,
            512: &#34;EXTENDED_GRACE_MONTH&#34;,
            1024: &#34;EXTENDED_GRACE_QUARTER&#34;,
            2048: &#34;EXTENDED_GRACE_HALFYEAR&#34;,
            4096: &#34;EXTENDED_GRACE_YEAR&#34;,
            8192: &#34;EXTENDED_CANDIDATE_WEEK&#34;,
            16384: &#34;EXTENDED_CANDIDATE_MONTH&#34;,
            32768: &#34;EXTENDED_CANDIDATE_QUARTER&#34;,
            65536: &#34;EXTENDED_CANDIDATE_HALFYEAR&#34;,
            131072: &#34;EXTENDED_CANDIDATE_YEAR&#34;,
            262144: &#34;EXTENDED_HOUR&#34;,
            524288: &#34;EXTENDED_DAY&#34;,
            1048576: &#34;EXTENDED_CANDIDATE_HOUR&#34;,
            2097152: &#34;EXTENDED_CANDIDATE_DAY&#34;,
            4194304: &#34;EXTENDED_GRACE_HOUR&#34;,
            8388608: &#34;EXTENDED_GRACE_DAY&#34;,
            16777216: &#34;EXTENDED_LAST_JOB&#34;,
            33554432: &#34;EXTENDED_FIRST&#34;,
        }
        rule_one = dict()
        rule_two = dict()
        rule_three = dict()
        if &#39;extendedRetentionRuleOne&#39; in self._retention_rules:
            rule_one[&#39;isEnabled&#39;] = self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;isEnabled&#39;]
            rule_one[&#39;rule&#39;] = mapping[self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;rule&#39;]]
            rule_one[&#39;endDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;endDays&#39;]
            rule_one[&#39;graceDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;graceDays&#39;]
        else:
            rule_one = False

        if &#39;extendedRetentionRuleTwo&#39; in self._retention_rules:
            rule_two[&#39;isEnabled&#39;] = self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;isEnabled&#39;]
            rule_two[&#39;rule&#39;] = mapping[self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;rule&#39;]]
            rule_two[&#39;endDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;endDays&#39;]
            rule_two[&#39;graceDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;graceDays&#39;]
        else:
            rule_two = False

        if &#39;extendedRetentionRuleThree&#39; in self._retention_rules:
            rule_three[&#39;isEnabled&#39;] = self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;isEnabled&#39;]
            rule_three[&#39;rule&#39;] = mapping[self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;rule&#39;]]
            rule_three[&#39;endDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;endDays&#39;]
            rule_three[&#39;graceDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;graceDays&#39;]
        else:
            rule_three = False
        return rule_one, rule_two, rule_three

    @extended_retention_rules.setter
    def extended_retention_rules(self, extended_retention):
        &#34;&#34;&#34;Sets the copy extended retention rules as the value provided as input

            Args:
                extended_retention   (tuple)     --  to set extended_retention rules

                    tuple:
                        **int**    -   which rule to set (1/2/3)

                        **bool**    -   value for isEnabled

                        **str**     -   value for rule

                        Example valid values:
                            EXTENDED_ALLFULL
                            EXTENDED_WEEK
                            EXTENDED_MONTH
                            EXTENDED_QUARTER
                            EXTENDED_HALFYEAR
                            EXTENDED_YEAR

                        **int**     -   value for endDays

                        **int**     -   value for graceDays

                    e.g.:

                        &gt;&gt;&gt; copy_obj.extended_retention_rules = [1, True, &#34;EXTENDED_ALLFULL&#34;, 0, 0]

            Raises:
                SDKException:
                    if failed to update extended Retention Rule on copy

        &#34;&#34;&#34;
        mapping = {
            1: &#39;extendedRetentionRuleOne&#39;,
            2: &#39;extendedRetentionRuleTwo&#39;,
            3: &#39;extendedRetentionRuleThree&#39;
        }

        rule = mapping[extended_retention[0]]
        if rule not in self._copy_properties:
            self._retention_rules[rule] = {
                &#34;isEnabled&#34;: &#34;&#34;,
                &#34;rule&#34;: &#34;&#34;,
                &#34;endDays&#34;: &#34;&#34;,
                &#34;graceDays&#34;: &#34;&#34;}

        if extended_retention[0] is not None:
            self._retention_rules[rule][&#39;isEnabled&#39;] = int(extended_retention[1])
            self._retention_rules[rule][&#39;rule&#39;] = extended_retention[2]
            self._retention_rules[rule][&#39;endDays&#39;] = extended_retention[3]
            self._retention_rules[rule][&#39;graceDays&#39;] = extended_retention[4]
        else:
            raise SDKException(&#39;Storage&#39;, &#39;110&#39;)

        self._set_copy_properties()

    @property
    def copy_retention_managed_disk_space(self):
        &#34;&#34;&#34;Treats managed disk space setting as a read-only attribute&#34;&#34;&#34;
        return &#39;enableManagedDiskSpace&#39; in self._retention_rules

    @copy_retention_managed_disk_space.setter
    def copy_retention_managed_disk_space(self, managed_disk_space_value):
        &#34;&#34;&#34;Sets managed disk space attribute value with provided input value

            Args:
             managed_disk_space_value (Bool) -- managed disk space value to be enabled/disabled

            Raises:
                SDKException:

                    if the type of value input is not correct

        &#34;&#34;&#34;
        if not isinstance(managed_disk_space_value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if not managed_disk_space_value:
            self._retention_rules[&#39;retentionFlags&#39;][&#39;enableManagedDiskSpace&#39;] = 0
        if managed_disk_space_value:
            self._retention_rules[&#39;retentionFlags&#39;][&#39;enableManagedDiskSpace&#39;] = 1
        self._set_copy_properties()

    @property
    def is_parallel_copy(self):
        &#34;&#34;&#34;Treats the parallel copy setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;enableParallelCopy&#39; in self._copy_flags

    def set_parallel_copy(self, value):
        &#34;&#34;&#34; Sets the parallel copy on storage policy copy as the value provided as input.
            Args:
                value    (bool) --  parallel copy on storage policy copy value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update parallel copy on storage policy copy

                    if the type of value input is not correct
        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_flags[&#39;enableParallelCopy&#39;] = int(value)

        self._set_copy_properties()

    @property
    def space_optimized_auxillary_copy(self):
        &#34;&#34;&#34;Treats the space optimized auxillary copy setting as a read-only attribute.&#34;&#34;&#34;
        if self._copy_properties.get(&#39;extendedFlags&#39;, {}).get(&#39;spaceOptimizedAuxCopy&#39;):
            return True
        return False

    @space_optimized_auxillary_copy.setter
    def space_optimized_auxillary_copy(self, value):
        &#34;&#34;&#34;Sets the space optimized auxillary copy setting as the value provided as input.
            Args:
                value    (bool) --  Enable/Disable Space Optimized Auxillary Copy
            Raises:
                SDKException:
                    if failed to update property

                    if the type of value input is not correct
        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        self._copy_properties[&#39;extendedFlags&#39;][&#39;spaceOptimizedAuxCopy&#39;] = int(value)

        self._set_copy_properties()

    @property
    def is_inline_copy(self):
        &#34;&#34;&#34;Treats the inline copy setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;inlineAuxCopy&#39; in self._copy_flags

    def set_inline_copy(self, value):
        &#34;&#34;&#34; Sets the inline copy on storage policy copy as the value provided as input.
            Args:
                value    (bool) --  inline copy on storage policy copy value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update inline copy on storage policy copy

                    if the type of value input is not correct
        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_flags[&#39;inlineAuxCopy&#39;] = int(value)

        self._set_copy_properties()

    @property
    def network_throttle_bandwidth(self):
        &#34;&#34;&#34;Treats the Network Throttle Bandwidth as a read-only attribute.

            Returns:
                (int) : Value of Network Throttle Bandwidth set in MBPH
        &#34;&#34;&#34;
        return int(self._copy_properties.get(&#39;throttleNetworkBandWidthMBHR&#39;))

    @network_throttle_bandwidth.setter
    def network_throttle_bandwidth(self, value):
        &#34;&#34;&#34; Sets the Network Throttle Bandwidth on storage policy copy as the value provided as input.
            Args:
                value    (int):  value of Network Throttle Bandwidth in MBPH

            Raises:
                SDKException:
                    if failed to update Network Throttle Bandwidth on storage policy copy

                    if the type of value input is not correct
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_properties[&#39;throttleNetworkBandWidthMBHR&#39;] = value
        self._set_copy_properties()

    def add_svm_association(self, src_array_id, source_array, tgt_array_id,
                            target_array, **kwargs):
        &#34;&#34;&#34; Method to add SVM association on Replica/vault and Mirror Copy

            Agrs:
                src_array_id    (int)   --  Controlhost id of source SVM

                source_array    (str)   --  Name of the source Array

                tgt_array_id    (int)   --  Controlhost id of target SVM

                target_array    (str)   --  Name of the Target Array

                target_vendor   (str)   --  Target Vendor Name
                
                tgt_vendor_id   (int)   --  Target Vendor id

        &#34;&#34;&#34;
        target_vendor = kwargs.get(&#39;target_vendor&#39;, &#34;&#34;)
        tgt_vendor_id = kwargs.get(&#39;tgt_vendor_id&#39;, 0)

        request_json = {
            &#34;EVGui_MMSMArrayReplicaPairReq&#34;: {
                &#34;processinginstructioninfo&#34;: {
                    &#34;locale&#34;: {
                        &#34;_type_&#34;: 66,
                        &#34;localeId&#34;: 0
                    },
                    &#34;formatFlags&#34;: {
                        &#34;ignoreUnknownTags&#34;: True,
                        &#34;elementBased&#34;: False,
                        &#34;skipIdToNameConversion&#34;: True,
                        &#34;formatted&#34;: False,
                        &#34;filterUnInitializedFields&#34;: False,
                        &#34;skipNameToIdConversion&#34;: False,
                        &#34;continueOnError&#34;: False
                    },
                    &#34;user&#34;: {
                        &#34;_type_&#34;: 13,
                        &#34;userName&#34;: &#34;admin&#34;,
                        &#34;userId&#34;: 1
                    }
                },
                &#34;copyId&#34;: self.copy_id,
                &#34;flags&#34;: 0,
                &#34;operation&#34;: 2,
                &#34;userId&#34;: 1,
                &#34;replPairList&#34;: [
                    {
                        &#34;copyId&#34;: 0,
                        &#34;flags&#34;: 0,
                        &#34;replicaPairId&#34;: 0,
                        &#34;srcArray&#34;: {
                            &#34;name&#34;: source_array,
                            &#34;id&#34;: src_array_id
                        },
                        &#34;vendor&#34;: {
                            &#34;name&#34;: &#34;&#34;,
                            &#34;id&#34;: 0
                        },
                        &#34;tgtVendor&#34;: {
                            &#34;name&#34;: target_vendor,
                            &#34;id&#34;: tgt_vendor_id
                        },
                        &#34;tgtArray&#34;: {
                            &#34;name&#34;: target_array,
                            &#34;id&#34;: tgt_array_id
                        }
                    }
                ]
            }
        }

        add_svm_association_service = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, add_svm_association_service, request_json
        )
        self.refresh()

        if flag:
            if response.json():
                if &#39;errorCode&#39; in response.json():
                    error_code = int(response.json()[&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to Update SVM Association on Copy: {0}&#34;.format(
                            self._copy_name
                        )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def set_key_management_server(self, kms_name):
        &#34;&#34;&#34;Sets the Key Management Server to this copy

            Args:
                kms_name  (str) -- The Key Management Server&#39;s name

            Raises SDKException:
                If input is not valid

                If API response is not successful

        &#34;&#34;&#34;
        if not isinstance(kms_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_properties[&#34;dataEncryption&#34;] = {
            &#34;keyProviderName&#34;: kms_name,
            &#34;rotateMasterKey&#34;: True
        }
        self._set_copy_properties()
    
    def set_multiplexing_factor(self, mux_factor):
        &#34;&#34;&#34;Sets/Unset the multiplexing factor for the storage policy copy

            Args:
                mux_factor  (int) -- The value for multiplexing factor

            Raises SDKException:
                If input is not valid

                If API response is not successful
        &#34;&#34;&#34;
        if not isinstance(mux_factor, int):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_properties[&#39;mediaProperties&#39;] = {
            &#34;multiplexingFactor&#34; : mux_factor
        }
        self._set_copy_properties()    

    @property
    def ddb_resiliency(self):
        &#34;&#34;&#34;Treats the Resiliency Flag as a read-only attribute.
            Returns:
                (bool) : Value of Resiliency Flag
        &#34;&#34;&#34;
        return bool(self._dedupe_flags.get(&#39;allowJobsToRunWithoutAllPartitions&#39;))

    def set_ddb_resiliency(self, is_enabled, min_num_partitions):
        &#34;&#34;&#34;Sets Resiliency On or Off, and set partition threshold for Resiliency
            Args:
                is_enabled  (Boolean) -- True or False to enable and disable resiliency respectively.
                min_num_partitions (int) -- Number of partitions required to be online for Resiliency to take affect.
            Raises SDKException:
                If input is not valid
                If min_num_partitions &lt; 1
                If API response is not successful
        &#34;&#34;&#34;
        if isinstance(is_enabled, bool) or isinstance(min_num_partitions, int):
            SDKException(&#39;Storage&#39;, &#39;101&#39;)
        if is_enabled:
            if min_num_partitions &lt; 1:
                SDKException(&#39;Storage&#39;, &#39;102&#39;, &#34;error min_num_partitions should be greater than or equal to 1&#34;)
            self._copy_properties[&#39;minimumNumberOfPartitionsForJobsToRun&#39;] = min_num_partitions
            self._dedupe_flags[&#39;allowJobsToRunWithoutAllPartitions&#39;] = 1
            self._set_copy_properties()
        else:
            self._dedupe_flags[&#39;allowJobsToRunWithoutAllPartitions&#39;] = 0
            self._set_copy_properties()

    def delete_datapath(self, library_name, media_agent_name):
        &#34;&#34;&#34;
        Delete DataPath from the storage policy copy

            Args:
                library_name    (str)   --   name of the library

                media_agent_name(str)   --   name of the media agent

            Raises:
                SDKException:
                    - If type of required input parameters is not string
                    - If API response is not successful
        &#34;&#34;&#34;
        if not (isinstance(media_agent_name, str)) and isinstance(library_name):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_json = {
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;dataPathProperties&#34;: [
                    {
                        &#34;operationFlags&#34;: {
                            &#34;removeDataPath&#34;: True
                        },
                        &#34;mediaAgent&#34;: {
                            &#34;mediaAgentName&#34;: media_agent_name
                        },
                        &#34;library&#34;: {
                            &#34;libraryName&#34;: library_name
                        }
                    }
                ]
            }
        }

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._STORAGE_POLICY_COPY,
                                                           request_json)
        self.refresh()
        if flag:
            if response.json():
                response = response.json()
                if &#34;error&#34; in response and response.get(&#34;error&#34;, {}).get(&#34;errorCode&#34;) != 0:
                    error_message = response.get(&#34;error&#34;, {}).get(&#34;errorMessage&#34;)
                    raise SDKException(&#39;Response&#39;, &#39;101&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            error_message = response.json().get(&#34;errorMessage&#34;)
            raise SDKException(&#39;Response&#39;, &#39;111&#39;, error_message)

    def rotate_encryption_master_key(self):
        &#34;&#34;&#34;
        Rotates the encryption key for this copy
        &#34;&#34;&#34;
        self._copy_properties[&#34;dataEncryption&#34;] = {
            &#34;rotateMasterKey&#34;: True
        }
        self._set_copy_properties()
        
    def set_default_datapath(self, library_name, media_agent_name):
        &#34;&#34;&#34;
        Set default data path for that storage policy copy.

            Args:
                library_name    (str)   --   name of the library

                media_agent_name(str)   --   name of the media agent

            Raises:
                SDKException:
                    - If type of required input parameters is not string
                    - If API response is not successful
        &#34;&#34;&#34;
        if not (isinstance(media_agent_name, str)) and isinstance(library_name):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_json = {
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;dataPathProperties&#34;: [
                    {
                        &#34;operationFlags&#34;: {
                            &#34;setDefault&#34;: True
                        },
                        &#34;mediaAgent&#34;: {
                            &#34;mediaAgentName&#34;: media_agent_name
                        },
                        &#34;library&#34;: {
                            &#34;libraryName&#34;: library_name
                        }
                    }
                ]
            }
        }

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._STORAGE_POLICY_COPY,
                                                           request_json)
        self.refresh()
        if flag:
            if response.json():
                response = response.json()
                if &#34;error&#34; in response and response.get(&#34;error&#34;, {}).get(&#34;errorCode&#34;) != 0:
                    error_message = response.get(&#34;error&#34;, {}).get(&#34;errorMessage&#34;)
                    raise SDKException(&#39;Response&#39;, &#39;101&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            error_message = response.json().get(&#34;errorMessage&#34;)
            raise SDKException(&#39;Response&#39;, &#39;111&#39;, error_message)

    @property
    def is_compliance_lock_enabled(self):
        &#34;&#34;&#34;Checks whether compliance lock on copy is enabled or not&#34;&#34;&#34;
        return &#39;wormCopy&#39; in self._copy_flags

    def get_store_seal_frequency(self):
        &#34;&#34;&#34;Gets the store seal frequency for the copy

        Returns:
            dict -- store seal frequency for the copy
                    Eg: {&#39;size&#39;: 0, &#39;days&#39;: 2, &#39;months&#39;: 0}
        &#34;&#34;&#34;
        request_json = {
            &#34;EVGui_StoragePolicySummaryReq&#34;: {
                &#34;spId&#34;: self.storage_policy_id,
                &#34;spCopyId&#34;: self.copy_id,
                &#34;reportType&#34;: 5 # storage policy copy&#39;s dedup information summary
            }
        }

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_json
        )
        if flag:
            if response and response.json():
                dedup_summary = response.json()
                dedup_options = dedup_summary[&#39;options&#39;][&#39;dedupOptions&#39;]
                seal_frequency_dict = {
                    &#39;size&#39;: dedup_options[&#39;storeCreationSize&#39;],
                    &#39;days&#39;: dedup_options[&#39;storeCreationDays&#39;],
                    &#39;months&#39;: dedup_options[&#39;storeCreationMonths&#39;]
                }
                return seal_frequency_dict
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def enable_compliance_lock(self):
        &#34;&#34;&#34;Sets compliance lock (wormCopy flag)

        Raises:
            SDKException:
                if response is not success.
                if response is empty.
        &#34;&#34;&#34;
        self._copy_properties[&#39;copyFlags&#39;][&#39;wormCopy&#39;] = 1
        self._set_copy_properties()

        if not self.is_compliance_lock_enabled:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, &#39;Failed to set compliance lock&#39;)

    def disable_compliance_lock(self):
        &#34;&#34;&#34;Unsets compliance lock (wormCopy flag)

        Raises:
            SDKException:
                if response is not success.
                if response is empty.
        &#34;&#34;&#34;

        disable_compliance_lock_url = self._services[&#39;DISABLE_STORAGE_POLICY_COMPLIANCE_LOCK&#39;] % (
            self.storage_policy_id, self.copy_id)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, disable_compliance_lock_url
        )

        # Adding a refresh to ensure we have the latest properties to verify if the compliance lock is disabled.
        self.refresh()

        if flag:
            if response.json():
                if (&#39;genericError&#39; in response.json()) and (&#39;errorCode&#39; in response.json()[&#39;genericError&#39;]):
                    error_code = int(response.json()[&#39;genericError&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to disable compliance lock&#34;
                        if &#34;errorMessage&#34; in response.json()[&#34;copies&#34;][0][&#39;genericError&#39;]:
                            error_message = response.json()[&#34;copies&#34;][0][&#39;genericError&#39;][&#34;errorMessage&#34;]
                        raise SDKException(&#39;Storage&#39;, &#39;111&#39;, error_message)
                else:
                    if &#34;error&#34; in response.json():
                        warning_message = &#34;&#34;
                        if &#34;warningMessage&#34; in response.json()[&#34;error&#34;]:
                            warning_message = response.json()[&#34;error&#34;][&#34;warningMessage&#34;]
                        raise SDKException(&#39;Storage&#39;, &#39;111&#39;, warning_message)
                    else:
                        raise SDKException(&#39;Storage&#39;, &#39;111&#39;)
            else:
                raise SDKException(&#39;Storage&#39;, &#39;111&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        if self.is_compliance_lock_enabled:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, &#39;Failed to unset compliance lock&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cvpysdk.policies.storage_policies.StoragePolicies"><code class="flex name class">
<span>class <span class="ident">StoragePolicies</span></span>
<span>(</span><span>commcell_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for getting all the storage policies associated with the commcell.</p>
<p>Initialize object of the StoragePolicies class.</p>
<h2 id="args">Args</h2>
<p>commcell_object (object)
&ndash;
instance of the Commcell class</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the StoragePolicies class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L254-L966" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StoragePolicies(object):
    &#34;&#34;&#34;Class for getting all the storage policies associated with the commcell.&#34;&#34;&#34;

    def __init__(self, commcell_object):
        &#34;&#34;&#34;Initialize object of the StoragePolicies class.

            Args:
                commcell_object (object)  --  instance of the Commcell class

            Returns:
                object - instance of the StoragePolicies class
        &#34;&#34;&#34;
        self._commcell_object = commcell_object
        self._POLICY = self._commcell_object._services[&#39;STORAGE_POLICY&#39;]
        self._DELETE_POLICY =  self._commcell_object._services[&#39;DELETE_STORAGE_POLICY&#39;]
        self._policies = None
        self.refresh()

    def __str__(self):
        &#34;&#34;&#34;Representation string consisting of all storage policies of the commcell.

            Returns:
                str - string of all the storage policies associated with the commcell
        &#34;&#34;&#34;
        representation_string = &#39;{:^5}\t{:^20}\n\n&#39;.format(&#39;S. No.&#39;, &#39;Storage Policy&#39;)

        for index, policy in enumerate(self._policies):
            sub_str = &#39;{:^5}\t{:20}\n&#39;.format(index + 1, policy)
            representation_string += sub_str

        return representation_string.strip()

    def __repr__(self):
        &#34;&#34;&#34;Representation string for the instance of the Clients class.&#34;&#34;&#34;
        return &#34;StoragePolicies class instance for Commcell: &#39;{0}&#39;&#34;.format(
            self._commcell_object.commserv_name
        )

    def _get_policies(self):
        &#34;&#34;&#34;Gets all the storage policies associated to the commcell specified by commcell object.

            Returns:
                dict - consists of all storage policies of the commcell
                    {
                         &#34;storage_policy1_name&#34;: storage_policy1_id,
                         &#34;storage_policy2_name&#34;: storage_policy2_id
                    }

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;GET&#39;, self._POLICY + &#34;?getAll=TRUE&#34;)

        if flag:
            if response.json() and &#39;policies&#39; in response.json():
                policies = response.json()[&#39;policies&#39;]

                if policies == []:
                    return {}

                policies_dict = {}

                for policy in policies:
                    temp_name = policy[&#39;storagePolicyName&#39;].lower()
                    temp_id = str(policy[&#39;storagePolicyId&#39;]).lower()
                    policies_dict[temp_name] = temp_id

                return policies_dict
            else:
                return {}
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def all_storage_policies(self):
        &#34;&#34;&#34;Returns dict of all the storage policies on this commcell

            dict - consists of all storage policies of the commcell
                    {
                         &#34;storage_policy1_name&#34;: storage_policy1_id,
                         &#34;storage_policy2_name&#34;: storage_policy2_id
                    }
        &#34;&#34;&#34;
        return self._policies

    def has_policy(self, policy_name):
        &#34;&#34;&#34;Checks if a storage policy exists in the commcell with the input storage policy name.

            Args:
                policy_name (str)  --  name of the storage policy

            Returns:
                bool - boolean output whether the storage policy exists in the commcell or not

            Raises:
                SDKException:
                    if type of the storage policy name argument is not string
        &#34;&#34;&#34;
        if not isinstance(policy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        return self._policies and policy_name.lower() in self._policies

    def get(self, storage_policy_name):
        &#34;&#34;&#34;Returns a StoragePolicy object of the specified storage policy name.

            Args:
                storage_policy_name     (str)   --  name of the storage policy

            Returns:
                object - instance of the StoragePolicy class for the given policy name

            Raises:
                SDKException:
                    if type of the storage policy name argument is not string

                    if no storage policy exists with the given name
        &#34;&#34;&#34;
        if not isinstance(storage_policy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        storage_policy_name = storage_policy_name.lower()

        if self.has_policy(storage_policy_name):
            return StoragePolicy(
                self._commcell_object, storage_policy_name, self._policies[storage_policy_name]
            )
        else:
            raise SDKException(
                &#39;Storage&#39;, &#39;102&#39;, &#39;No policy exists with name: {0}&#39;.format(storage_policy_name)
            )

    def add_global_storage_policy(self,
                                  global_storage_policy_name,
                                  library,
                                  media_agent,
                                  dedup_path=None,
                                  dedup_path_media_agent=None):
        &#34;&#34;&#34;adds a global storage policy

            Args:
                global_storage_policy_name   (str)  --  name of the global storage policy which you want to add

                library                      (str)  --  name of the library which you want to be associated with your
                global storage policy

                media_agent                  (str)  --  name of the media agent which you want to be associated with
                the global storage policy

                        *enter BOTH, the dedup_path and dedup_path_media_agent if you want the deduplication
                         to be enabled.

                dedup_path                    (str) -- path of the deduplication database
                default- None

                dedup_path_media_agent:       (str) -- name of the media agent where the deduplication database
                                                       is stored
                default- None

            Returns:
                    the success message along with the name of the global storage policy if created successfully
                    else the error messages or the exceptions raised

            Raises:
                SDKException:
                        if the global_storage_policy_name,library,media_agent,dedup_path,dedup_path_media_agent
                        is not of type String

                        if response is empty

                        if response is not success

        &#34;&#34;&#34;

        if not (isinstance(global_storage_policy_name, str) and
                isinstance(library, str) and
                isinstance(media_agent, str)):
            raise SDKException(&#34;Storage&#34;, &#34;101&#34;)

        if ((dedup_path is not None and not isinstance(dedup_path, str)) or
                dedup_path_media_agent is not None and not isinstance(dedup_path_media_agent, str)):
            raise SDKException(&#34;Storage&#34;, &#34;101&#34;)

        request_json = {
            &#34;storagePolicyName&#34;: global_storage_policy_name,
            &#34;copyName&#34;: &#34;Primary_Global&#34;,
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;storagePolicyFlags&#34;: {
                    &#34;globalStoragePolicy&#34;: 1
                },
                &#34;library&#34;: {
                    &#34;libraryName&#34;: library
                },
                &#34;mediaAgent&#34;: {
                    &#34;mediaAgentName&#34;: media_agent
                },
                &#34;retentionRules&#34;: {
                    &#34;retainArchiverDataForDays&#34;: -1,
                    &#34;retainBackupDataForCycles&#34;: -1,
                    &#34;retainBackupDataForDays&#34;: -1
                }
            }
        }

        if dedup_path is not None and dedup_path_media_agent is not None:
            storage_policy_copy_info = {
                &#34;dedupeFlags&#34;: {
                    &#34;enableDASHFull&#34;: 1,
                    &#34;hostGlobalDedupStore&#34;: 1,
                    &#34;enableDeduplication&#34;: 1
                },
                &#34;storagePolicyFlags&#34;: {
                    &#34;blockLevelDedup&#34;: 1,
                    &#34;enableGlobalDeduplication&#34;: 1
                },
                &#34;DDBPartitionInfo&#34;: {
                    &#34;maInfoList&#34;: [
                        {
                            &#34;mediaAgent&#34;: {
                                &#34;mediaAgentName&#34;: dedup_path_media_agent
                            },
                            &#34;subStoreList&#34;: [
                                {
                                    &#34;diskFreeWarningThreshholdMB&#34;: 10240,
                                    &#34;diskFreeThresholdMB&#34;: 5120,
                                    &#34;accessPath&#34;: {
                                        &#34;path&#34;: dedup_path
                                    }
                                }
                            ]
                        }
                    ]
                }
            }
            request_json[&#34;storagePolicyCopyInfo&#34;].update(storage_policy_copy_info)

        # don&#39;t create dedup global storage policy if the arguments are not supplied
        elif(dedup_path or dedup_path_media_agent):
            raise SDKException(&#34;Storage&#34;, &#34;101&#34;, &#34;cannot create dedup global policy without complete arguments \n&#34;
                               &#34;supply both dedup path and dedup path media agent&#34;)

        # checking to create non dedup global storage policy
        elif(dedup_path is None and dedup_path_media_agent is None):
            storage_policy_copyinfo = {
                &#34;extendedFlags&#34;: {
                    &#34;globalStoragePolicy&#34;: 1
                }
            }
            request_json[&#34;storagePolicyCopyInfo&#34;].update(storage_policy_copyinfo)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._POLICY, request_json
        )

        if flag:
            if response.json():
                if &#39;error&#39; in response.json() and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                    # initialize the policies again
                    # so the policies object has all the policies
                    self.refresh()

                else:
                    error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                    o_str = &#39;Failed to create storage policy\nError: &#34;{0}&#34;&#39;

                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        return self.get(global_storage_policy_name)

    def add(self,
            storage_policy_name,
            library=None,
            media_agent=None,
            dedup_path=None,
            incremental_sp=None,
            retention_period=5,
            number_of_streams=None,
            ocum_server=None,
            dedup_media_agent=None,
            dr_sp=False,
            **kwargs):
        &#34;&#34;&#34;Adds a new Storage Policy to the Commcell.

            Args:
                storage_policy_name (str)         --  name of the new storage policy to add

                library             (str/object)  --  name or instance of the library
                to add the policy to

                media_agent         (str/object)  --  name or instance of media agent
                to add the policy to

                dedup_path          (str)         --  the path of the deduplication database
                default: None

                incremental_sp      (str)         --  the name of the incremental storage policy
                associated with the storage policy
                default: None

                retention_period    (int)         --  time period in days to retain
                the data backup for
                default:5

                number_of_streams   (int)         --  the number of streams for the storage policy
                default: None

                ocum_server         (str)         --  On Command Unified Server Name
                default: None

                dedup_media_agent   (str)          --  name of media agent where deduplication database is hosted.
                default:None

                dr_sp                (bool)         --  if True creates dr storage policy
                                                        if False creates data protection policy
                default:False

                **kwargs    --  dict of keyword arguments as follows:

                    global_policy_name   (str)         --  name of the global storage policy on which you want
                                                           the policy being created to be dependent.

                    global_dedup_policy (bool)  -- whether the global storage policy has a global deduplication pool
                                                   or not
                    default:True                  (meaning the global storage policy will have deduplication enabled)

            Raises:
                SDKException:
                    if type of the storage policy name argument is not string

                    if type of the retention period argument is not int

                    if type of the library argument is not either string or DiskLibrary instance

                    if type of the media agent argument is not either string or MediaAgent instance

                    if failed to create storage policy

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;

        extra_arguments = {
            &#39;global_policy_name&#39;: None,
            &#39;global_dedup_policy&#39;: True
        }
        # if global_dedup_policy will always have some value
        # global_policy_name decides if user wants to create sp using existing global dedup policy or not
        extra_arguments.update(kwargs)

        if ((dedup_path is not None and not isinstance(dedup_path, str)) or
                (not (isinstance(storage_policy_name, str) and
                      isinstance(retention_period, int))) or
                (incremental_sp is not None and not isinstance(incremental_sp, str))):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if isinstance(library, DiskLibrary):
            disk_library = library
        elif isinstance(library, str):
            disk_library = DiskLibrary(self._commcell_object, library)
        elif extra_arguments[&#34;global_policy_name&#34;] is not None:
            pass
            # when existing global_dedup_policy is used then library details not needed
        else:
            raise SDKException(&#39;Storage&#39;, &#39;104&#39;)

        if isinstance(media_agent, MediaAgent):
            media_agent = media_agent
        elif isinstance(media_agent, str):
            media_agent = MediaAgent(self._commcell_object, media_agent)
        elif extra_arguments[&#34;global_policy_name&#34;] is not None:
            pass
            # when existing global_dedup_policy is used then MA details not needed
        else:
            raise SDKException(&#39;Storage&#39;, &#39;103&#39;)

        sp_type = 2 if dr_sp else 1

        if extra_arguments[&#34;global_policy_name&#34;] is None:
            # then populate request json using supplied Library, MA and dedup path
            request_json = {
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;library&#34;: {
                        &#34;libraryId&#34;: int(disk_library.library_id)
                    },
                    &#34;mediaAgent&#34;: {
                        &#34;mediaAgentId&#34;: int(media_agent.media_agent_id)
                    },
                    &#34;retentionRules&#34;: {
                        &#34;retainBackupDataForDays&#34;: retention_period
                    }
                },
                &#34;storagePolicyName&#34;: storage_policy_name,
                &#34;type&#34;: sp_type
            }

            if dedup_path:
                if dedup_media_agent is None:
                    dedup_media_agent = media_agent
                elif self._commcell_object.media_agents.has_media_agent(dedup_media_agent):
                    dedup_media_agent = MediaAgent(self._commcell_object, dedup_media_agent)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;103&#39;)

                dedup_info = {
                    &#34;storagePolicyCopyInfo&#34;: {
                        &#34;dedupeFlags&#34;: {
                            &#34;enableDeduplication&#34;: 1
                        },
                        &#34;DDBPartitionInfo&#34;: {
                            &#34;maInfoList&#34;: [{
                                &#34;mediaAgent&#34;: {
                                    &#34;mediaAgentName&#34;: dedup_media_agent.media_agent_name
                                },
                                &#34;subStoreList&#34;: [{
                                    &#34;accessPath&#34;: {
                                        &#34;path&#34;: dedup_path
                                    }
                                }]
                            }]
                        }
                    }
                }

                request_json[&#34;storagePolicyCopyInfo&#34;].update(dedup_info[&#34;storagePolicyCopyInfo&#34;])

        # since we are supplying a global policy thus there is no need of the
        # dedup store details and the library details which got included above,
        # it will take up the settings of the global storage policy
        # thus defining request_json

        if extra_arguments[&#34;global_policy_name&#34;] is not None and extra_arguments[&#34;global_dedup_policy&#34;] is True:
            pool_obj = self._commcell_object.storage_pools.get(extra_arguments[&#34;global_policy_name&#34;])
            request_json = {
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;useGlobalPolicy&#34;: {
                        &#34;storagePolicyName&#34;: extra_arguments[&#34;global_policy_name&#34;]
                    },
                    &#34;retentionRules&#34;: {
                        &#34;retainBackupDataForDays&#34;: retention_period
                    },
                    &#34;dedupeFlags&#34;: {
                        &#34;useGlobalDedupStore&#34;: 1,
                        &#34;enableClientSideDedup&#34;: 1,
                        &#34;enableDASHFull&#34;: 1,
                        &#34;enableDeduplication&#34;: 1
                    },
                    &#34;extendedFlags&#34;: {
                        &#34;overRideGACPRetention&#34;: &#34;SET_FALSE&#34; if pool_obj.is_worm_storage_lock_enabled else &#34;SET_TRUE&#34;
                    }
                },
                &#34;storagePolicyName&#34;: storage_policy_name
            }

        elif extra_arguments[&#34;global_policy_name&#34;] is not None and extra_arguments[&#34;global_dedup_policy&#34;] is False:
            request_json = {
                &#34;storagePolicyName&#34;: storage_policy_name,
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;dedupeFlags&#34;: {
                        &#34;enableDASHFull&#34;: 1
                    },
                    &#34;retentionRules&#34;: {
                        &#34;retainBackupDataForDays&#34;: retention_period
                    },
                    &#34;extendedFlags&#34;: {
                        &#34;useGlobalStoragePolicy&#34;: 1
                    },
                    &#34;useGlobalPolicy&#34;: {
                        &#34;storagePolicyName&#34;: extra_arguments[&#34;global_policy_name&#34;]
                    }
                }
            }

        if number_of_streams is not None:
            number_of_streams_dict = {
                &#34;numberOfStreams&#34;: number_of_streams
            }
            request_json.update(number_of_streams_dict)

        if ocum_server is not None:
            ocum_server_dict1 = {
                &#34;dfmServer&#34;: {
                    &#34;name&#34;: ocum_server,
                    &#34;id&#34;: 0
                }
            }
            ocum_server_dict2 = {
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;snapLibrary&#34;: {
                        &#34;libraryName&#34;: &#34;Use primary copy&#39;s library and mediaAgent&#34;
                    },
                    &#34;storagePolicyFlags&#34;: {
                        &#34;enableSnapshot&#34;: 1
                    }
                }
            }

            request_json[&#34;storagePolicyCopyInfo&#34;].update(ocum_server_dict2[&#34;storagePolicyCopyInfo&#34;])
            request_json.update(ocum_server_dict1)

        if incremental_sp:
            incremental_sp_info = {
                &#34;incrementalStoragePolicy&#34;: {
                    &#34;storagePolicyName&#34;: incremental_sp
                }
            }

            request_json.update(incremental_sp_info)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._POLICY, request_json
        )

        if flag:
            if response.json():
                if &#39;error&#39; in response.json() and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                    # initialize the policies again
                    # so the policies object has all the policies
                    self.refresh()

                else:
                    error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                    o_str = &#39;Failed to create storage policy\nError: &#34;{0}&#34;&#39;

                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        return self.get(storage_policy_name)

    def add_tape_sp(self, storage_policy_name, library, media_agent, drive_pool, scratch_pool, retention_period_days=15,
                    ocum_server=None):
        &#34;&#34;&#34;
        Adds storage policy with tape data path
        Args:
                storage_policy_name (str)         --  name of the new storage policy to add

                library             (str)     --  name or instance of the library
                to add the policy to

                media_agent         (str/object)  --  name or instance of media agent
                to add the policy to

                drive_pool          (str)         --  Drive pool name of the tape library

                scratch_pool      (str)          --  Scratch pool name of the tape library

                retention_period_days    (int)         --  time period in days to retain
                the data backup for
                default: 15

                ocum_server         (str)         --  On Command Unified Server Name
                default: None

            Raises:
                SDKException:
                    if type of the storage policy name argument is not string

                    if type of the retention period argument is not int

                    if type of the library argument is not either string or DiskLibrary instance

                    if type of the media agent argument is not either string or MediaAgent instance

                    if failed to create storage policy

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        tape_library = library
        if not (isinstance(drive_pool, str) and
                isinstance(scratch_pool, str) and
                isinstance(tape_library, str) and
                isinstance(media_agent, str) and
                isinstance(storage_policy_name, str) and
                (retention_period_days is None or isinstance(retention_period_days, int))):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_json = {
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;retentionRules&#34;: {
                    &#34;retainBackupDataForDays&#34;: retention_period_days
                },
                &#34;library&#34;: {
                    &#34;libraryName&#34;: tape_library
                },
                &#34;mediaAgent&#34;: {
                    &#34;mediaAgentName&#34;: media_agent
                }
            },
            &#34;drivePool&#34;: drive_pool,
            &#34;scratchpool&#34;: scratch_pool,
            &#34;storagePolicyName&#34;: storage_policy_name
        }

        if ocum_server is not None:
            ocum_server_dict1 = {
                &#34;dfmServer&#34;: {
                    &#34;name&#34;: ocum_server,
                    &#34;id&#34;: 0
                }
            }

            ocum_server_dict2 = {
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;snapLibrary&#34;: {
                        &#34;libraryName&#34;: &#34;Use primary copy&#39;s library and mediaAgent&#34;
                    },
                    &#34;storagePolicyFlags&#34;: {
                        &#34;enableSnapshot&#34;: 1
                    }
                }
            }

            request_json[&#34;storagePolicyCopyInfo&#34;].update(ocum_server_dict2[&#34;storagePolicyCopyInfo&#34;])
            request_json.update(ocum_server_dict1)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._POLICY, request_json
        )

        if flag:
            if response.json():
                if &#39;error&#39; in response.json() and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                    # initialize the policies again
                    # so the policies object has all the policies
                    self.refresh()

                else:
                    error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                    o_str = &#39;Failed to create storage policy with tape data path\nError: &#34;{0}&#34;&#39;

                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        return self.get(storage_policy_name)

    def delete(self, storage_policy_name):
        &#34;&#34;&#34;Deletes a storage policy from the commcell.

            Args:
                storage_policy_name (str)  --  name of the storage policy to delete

            Raises:
                SDKException:
                    if type of the storage policy name argument is not string

                    if failed to delete storage policy

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        if not isinstance(storage_policy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if self.has_policy(storage_policy_name):
            storagepolicy_id = self.all_storage_policies[storage_policy_name.lower()]
            policy_delete_service = self._DELETE_POLICY + &#39;/{0}&#39;.format(storagepolicy_id)

            flag, response = self._commcell_object._cvpysdk_object.make_request(
                &#39;DELETE&#39;, policy_delete_service
            )

            if flag:
                try:
                    if response.json():
                        if &#39;error&#39; in response.json():
                            if &#39;errorCode&#39; in response.json()[&#39;error&#39;] and &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                                error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                                o_str = &#39;Failed to delete storage policy\nError: &#34;{0}&#34;&#39;

                                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
                            elif &#39;errorCode&#39; in response.json()[&#39;error&#39;] and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                                self.refresh()
                                return response.text.strip()
                except ValueError:
                    if response.text:
                        if &#39;errorCode&#39; in response.text and &#39;errorMessage&#39; in response.text:
                            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, response.text.strip())
                        self.refresh()
                        return response.text.strip()
                    else:
                        raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                response_string = self._commcell_object._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        else:
            raise SDKException(
                &#39;Storage&#39;, &#39;102&#39;, &#39;No policy exists with name: {0}&#39;.format(storage_policy_name)
            )

    def refresh(self):
        &#34;&#34;&#34;Refresh the storage policies associated with the Commcell.&#34;&#34;&#34;
        self._policies = self._get_policies()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="cvpysdk.policies.storage_policies.StoragePolicies.all_storage_policies"><code class="name">var <span class="ident">all_storage_policies</span></code></dt>
<dd>
<div class="desc"><p>Returns dict of all the storage policies on this commcell</p>
<p>dict - consists of all storage policies of the commcell
{
"storage_policy1_name": storage_policy1_id,
"storage_policy2_name": storage_policy2_id
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L332-L342" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def all_storage_policies(self):
    &#34;&#34;&#34;Returns dict of all the storage policies on this commcell

        dict - consists of all storage policies of the commcell
                {
                     &#34;storage_policy1_name&#34;: storage_policy1_id,
                     &#34;storage_policy2_name&#34;: storage_policy2_id
                }
    &#34;&#34;&#34;
    return self._policies</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cvpysdk.policies.storage_policies.StoragePolicies.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, storage_policy_name, library=None, media_agent=None, dedup_path=None, incremental_sp=None, retention_period=5, number_of_streams=None, ocum_server=None, dedup_media_agent=None, dr_sp=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new Storage Policy to the Commcell.</p>
<h2 id="args">Args</h2>
<p>storage_policy_name (str)
&ndash;
name of the new storage policy to add</p>
<p>library
(str/object)
&ndash;
name or instance of the library
to add the policy to</p>
<p>media_agent
(str/object)
&ndash;
name or instance of media agent
to add the policy to</p>
<dl>
<dt>dedup_path
(str)
&ndash;
the path of the deduplication database</dt>
<dt><strong><code>default</code></strong></dt>
<dd>None</dd>
<dt>incremental_sp
(str)
&ndash;
the name of the incremental storage policy</dt>
<dt>associated with the storage policy</dt>
<dt><strong><code>default</code></strong></dt>
<dd>None</dd>
</dl>
<p>retention_period
(int)
&ndash;
time period in days to retain
the data backup for
default:5</p>
<dl>
<dt>number_of_streams
(int)
&ndash;
the number of streams for the storage policy</dt>
<dt><strong><code>default</code></strong></dt>
<dd>None</dd>
<dt>ocum_server
(str)
&ndash;
On Command Unified Server Name</dt>
<dt><strong><code>default</code></strong></dt>
<dd>None</dd>
</dl>
<p>dedup_media_agent
(str)
&ndash;
name of media agent where deduplication database is hosted.
default:None</p>
<p>dr_sp
(bool)
&ndash;
if True creates dr storage policy
if False creates data protection policy
default:False</p>
<p>**kwargs
&ndash;
dict of keyword arguments as follows:</p>
<pre><code>global_policy_name   (str)         --  name of the global storage policy on which you want
                                       the policy being created to be dependent.

global_dedup_policy (bool)  -- whether the global storage policy has a global deduplication pool
                               or not
default:True                  (meaning the global storage policy will have deduplication enabled)
</code></pre>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the storage policy name argument is not string</p>
<pre><code>if type of the retention period argument is not int

if type of the library argument is not either string or DiskLibrary instance

if type of the media agent argument is not either string or MediaAgent instance

if failed to create storage policy

if response is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L533-L795" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add(self,
        storage_policy_name,
        library=None,
        media_agent=None,
        dedup_path=None,
        incremental_sp=None,
        retention_period=5,
        number_of_streams=None,
        ocum_server=None,
        dedup_media_agent=None,
        dr_sp=False,
        **kwargs):
    &#34;&#34;&#34;Adds a new Storage Policy to the Commcell.

        Args:
            storage_policy_name (str)         --  name of the new storage policy to add

            library             (str/object)  --  name or instance of the library
            to add the policy to

            media_agent         (str/object)  --  name or instance of media agent
            to add the policy to

            dedup_path          (str)         --  the path of the deduplication database
            default: None

            incremental_sp      (str)         --  the name of the incremental storage policy
            associated with the storage policy
            default: None

            retention_period    (int)         --  time period in days to retain
            the data backup for
            default:5

            number_of_streams   (int)         --  the number of streams for the storage policy
            default: None

            ocum_server         (str)         --  On Command Unified Server Name
            default: None

            dedup_media_agent   (str)          --  name of media agent where deduplication database is hosted.
            default:None

            dr_sp                (bool)         --  if True creates dr storage policy
                                                    if False creates data protection policy
            default:False

            **kwargs    --  dict of keyword arguments as follows:

                global_policy_name   (str)         --  name of the global storage policy on which you want
                                                       the policy being created to be dependent.

                global_dedup_policy (bool)  -- whether the global storage policy has a global deduplication pool
                                               or not
                default:True                  (meaning the global storage policy will have deduplication enabled)

        Raises:
            SDKException:
                if type of the storage policy name argument is not string

                if type of the retention period argument is not int

                if type of the library argument is not either string or DiskLibrary instance

                if type of the media agent argument is not either string or MediaAgent instance

                if failed to create storage policy

                if response is empty

                if response is not success
    &#34;&#34;&#34;

    extra_arguments = {
        &#39;global_policy_name&#39;: None,
        &#39;global_dedup_policy&#39;: True
    }
    # if global_dedup_policy will always have some value
    # global_policy_name decides if user wants to create sp using existing global dedup policy or not
    extra_arguments.update(kwargs)

    if ((dedup_path is not None and not isinstance(dedup_path, str)) or
            (not (isinstance(storage_policy_name, str) and
                  isinstance(retention_period, int))) or
            (incremental_sp is not None and not isinstance(incremental_sp, str))):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    if isinstance(library, DiskLibrary):
        disk_library = library
    elif isinstance(library, str):
        disk_library = DiskLibrary(self._commcell_object, library)
    elif extra_arguments[&#34;global_policy_name&#34;] is not None:
        pass
        # when existing global_dedup_policy is used then library details not needed
    else:
        raise SDKException(&#39;Storage&#39;, &#39;104&#39;)

    if isinstance(media_agent, MediaAgent):
        media_agent = media_agent
    elif isinstance(media_agent, str):
        media_agent = MediaAgent(self._commcell_object, media_agent)
    elif extra_arguments[&#34;global_policy_name&#34;] is not None:
        pass
        # when existing global_dedup_policy is used then MA details not needed
    else:
        raise SDKException(&#39;Storage&#39;, &#39;103&#39;)

    sp_type = 2 if dr_sp else 1

    if extra_arguments[&#34;global_policy_name&#34;] is None:
        # then populate request json using supplied Library, MA and dedup path
        request_json = {
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;library&#34;: {
                    &#34;libraryId&#34;: int(disk_library.library_id)
                },
                &#34;mediaAgent&#34;: {
                    &#34;mediaAgentId&#34;: int(media_agent.media_agent_id)
                },
                &#34;retentionRules&#34;: {
                    &#34;retainBackupDataForDays&#34;: retention_period
                }
            },
            &#34;storagePolicyName&#34;: storage_policy_name,
            &#34;type&#34;: sp_type
        }

        if dedup_path:
            if dedup_media_agent is None:
                dedup_media_agent = media_agent
            elif self._commcell_object.media_agents.has_media_agent(dedup_media_agent):
                dedup_media_agent = MediaAgent(self._commcell_object, dedup_media_agent)
            else:
                raise SDKException(&#39;Storage&#39;, &#39;103&#39;)

            dedup_info = {
                &#34;storagePolicyCopyInfo&#34;: {
                    &#34;dedupeFlags&#34;: {
                        &#34;enableDeduplication&#34;: 1
                    },
                    &#34;DDBPartitionInfo&#34;: {
                        &#34;maInfoList&#34;: [{
                            &#34;mediaAgent&#34;: {
                                &#34;mediaAgentName&#34;: dedup_media_agent.media_agent_name
                            },
                            &#34;subStoreList&#34;: [{
                                &#34;accessPath&#34;: {
                                    &#34;path&#34;: dedup_path
                                }
                            }]
                        }]
                    }
                }
            }

            request_json[&#34;storagePolicyCopyInfo&#34;].update(dedup_info[&#34;storagePolicyCopyInfo&#34;])

    # since we are supplying a global policy thus there is no need of the
    # dedup store details and the library details which got included above,
    # it will take up the settings of the global storage policy
    # thus defining request_json

    if extra_arguments[&#34;global_policy_name&#34;] is not None and extra_arguments[&#34;global_dedup_policy&#34;] is True:
        pool_obj = self._commcell_object.storage_pools.get(extra_arguments[&#34;global_policy_name&#34;])
        request_json = {
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;useGlobalPolicy&#34;: {
                    &#34;storagePolicyName&#34;: extra_arguments[&#34;global_policy_name&#34;]
                },
                &#34;retentionRules&#34;: {
                    &#34;retainBackupDataForDays&#34;: retention_period
                },
                &#34;dedupeFlags&#34;: {
                    &#34;useGlobalDedupStore&#34;: 1,
                    &#34;enableClientSideDedup&#34;: 1,
                    &#34;enableDASHFull&#34;: 1,
                    &#34;enableDeduplication&#34;: 1
                },
                &#34;extendedFlags&#34;: {
                    &#34;overRideGACPRetention&#34;: &#34;SET_FALSE&#34; if pool_obj.is_worm_storage_lock_enabled else &#34;SET_TRUE&#34;
                }
            },
            &#34;storagePolicyName&#34;: storage_policy_name
        }

    elif extra_arguments[&#34;global_policy_name&#34;] is not None and extra_arguments[&#34;global_dedup_policy&#34;] is False:
        request_json = {
            &#34;storagePolicyName&#34;: storage_policy_name,
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;dedupeFlags&#34;: {
                    &#34;enableDASHFull&#34;: 1
                },
                &#34;retentionRules&#34;: {
                    &#34;retainBackupDataForDays&#34;: retention_period
                },
                &#34;extendedFlags&#34;: {
                    &#34;useGlobalStoragePolicy&#34;: 1
                },
                &#34;useGlobalPolicy&#34;: {
                    &#34;storagePolicyName&#34;: extra_arguments[&#34;global_policy_name&#34;]
                }
            }
        }

    if number_of_streams is not None:
        number_of_streams_dict = {
            &#34;numberOfStreams&#34;: number_of_streams
        }
        request_json.update(number_of_streams_dict)

    if ocum_server is not None:
        ocum_server_dict1 = {
            &#34;dfmServer&#34;: {
                &#34;name&#34;: ocum_server,
                &#34;id&#34;: 0
            }
        }
        ocum_server_dict2 = {
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;snapLibrary&#34;: {
                    &#34;libraryName&#34;: &#34;Use primary copy&#39;s library and mediaAgent&#34;
                },
                &#34;storagePolicyFlags&#34;: {
                    &#34;enableSnapshot&#34;: 1
                }
            }
        }

        request_json[&#34;storagePolicyCopyInfo&#34;].update(ocum_server_dict2[&#34;storagePolicyCopyInfo&#34;])
        request_json.update(ocum_server_dict1)

    if incremental_sp:
        incremental_sp_info = {
            &#34;incrementalStoragePolicy&#34;: {
                &#34;storagePolicyName&#34;: incremental_sp
            }
        }

        request_json.update(incremental_sp_info)

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, self._POLICY, request_json
    )

    if flag:
        if response.json():
            if &#39;error&#39; in response.json() and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                # initialize the policies again
                # so the policies object has all the policies
                self.refresh()

            else:
                error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                o_str = &#39;Failed to create storage policy\nError: &#34;{0}&#34;&#39;

                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    return self.get(storage_policy_name)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicies.add_global_storage_policy"><code class="name flex">
<span>def <span class="ident">add_global_storage_policy</span></span>(<span>self, global_storage_policy_name, library, media_agent, dedup_path=None, dedup_path_media_agent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>adds a global storage policy</p>
<h2 id="args">Args</h2>
<p>global_storage_policy_name
(str)
&ndash;
name of the global storage policy which you want to add</p>
<p>library
(str)
&ndash;
name of the library which you want to be associated with your
global storage policy</p>
<p>media_agent
(str)
&ndash;
name of the media agent which you want to be associated with
the global storage policy</p>
<pre><code>    *enter BOTH, the dedup_path and dedup_path_media_agent if you want the deduplication
     to be enabled.
</code></pre>
<p>dedup_path
(str) &ndash; path of the deduplication database
default- None</p>
<dl>
<dt><strong><code>dedup_path_media_agent</code></strong></dt>
<dd>
<p>(str) &ndash; name of the media agent where the deduplication database
is stored</p>
</dd>
</dl>
<p>default- None</p>
<h2 id="returns">Returns</h2>
<p>the success message along with the name of the global storage policy if created successfully
else the error messages or the exceptions raised</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if the global_storage_policy_name,library,media_agent,dedup_path,dedup_path_media_agent
is not of type String</p>
<pre><code>    if response is empty

    if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L391-L531" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_global_storage_policy(self,
                              global_storage_policy_name,
                              library,
                              media_agent,
                              dedup_path=None,
                              dedup_path_media_agent=None):
    &#34;&#34;&#34;adds a global storage policy

        Args:
            global_storage_policy_name   (str)  --  name of the global storage policy which you want to add

            library                      (str)  --  name of the library which you want to be associated with your
            global storage policy

            media_agent                  (str)  --  name of the media agent which you want to be associated with
            the global storage policy

                    *enter BOTH, the dedup_path and dedup_path_media_agent if you want the deduplication
                     to be enabled.

            dedup_path                    (str) -- path of the deduplication database
            default- None

            dedup_path_media_agent:       (str) -- name of the media agent where the deduplication database
                                                   is stored
            default- None

        Returns:
                the success message along with the name of the global storage policy if created successfully
                else the error messages or the exceptions raised

        Raises:
            SDKException:
                    if the global_storage_policy_name,library,media_agent,dedup_path,dedup_path_media_agent
                    is not of type String

                    if response is empty

                    if response is not success

    &#34;&#34;&#34;

    if not (isinstance(global_storage_policy_name, str) and
            isinstance(library, str) and
            isinstance(media_agent, str)):
        raise SDKException(&#34;Storage&#34;, &#34;101&#34;)

    if ((dedup_path is not None and not isinstance(dedup_path, str)) or
            dedup_path_media_agent is not None and not isinstance(dedup_path_media_agent, str)):
        raise SDKException(&#34;Storage&#34;, &#34;101&#34;)

    request_json = {
        &#34;storagePolicyName&#34;: global_storage_policy_name,
        &#34;copyName&#34;: &#34;Primary_Global&#34;,
        &#34;storagePolicyCopyInfo&#34;: {
            &#34;storagePolicyFlags&#34;: {
                &#34;globalStoragePolicy&#34;: 1
            },
            &#34;library&#34;: {
                &#34;libraryName&#34;: library
            },
            &#34;mediaAgent&#34;: {
                &#34;mediaAgentName&#34;: media_agent
            },
            &#34;retentionRules&#34;: {
                &#34;retainArchiverDataForDays&#34;: -1,
                &#34;retainBackupDataForCycles&#34;: -1,
                &#34;retainBackupDataForDays&#34;: -1
            }
        }
    }

    if dedup_path is not None and dedup_path_media_agent is not None:
        storage_policy_copy_info = {
            &#34;dedupeFlags&#34;: {
                &#34;enableDASHFull&#34;: 1,
                &#34;hostGlobalDedupStore&#34;: 1,
                &#34;enableDeduplication&#34;: 1
            },
            &#34;storagePolicyFlags&#34;: {
                &#34;blockLevelDedup&#34;: 1,
                &#34;enableGlobalDeduplication&#34;: 1
            },
            &#34;DDBPartitionInfo&#34;: {
                &#34;maInfoList&#34;: [
                    {
                        &#34;mediaAgent&#34;: {
                            &#34;mediaAgentName&#34;: dedup_path_media_agent
                        },
                        &#34;subStoreList&#34;: [
                            {
                                &#34;diskFreeWarningThreshholdMB&#34;: 10240,
                                &#34;diskFreeThresholdMB&#34;: 5120,
                                &#34;accessPath&#34;: {
                                    &#34;path&#34;: dedup_path
                                }
                            }
                        ]
                    }
                ]
            }
        }
        request_json[&#34;storagePolicyCopyInfo&#34;].update(storage_policy_copy_info)

    # don&#39;t create dedup global storage policy if the arguments are not supplied
    elif(dedup_path or dedup_path_media_agent):
        raise SDKException(&#34;Storage&#34;, &#34;101&#34;, &#34;cannot create dedup global policy without complete arguments \n&#34;
                           &#34;supply both dedup path and dedup path media agent&#34;)

    # checking to create non dedup global storage policy
    elif(dedup_path is None and dedup_path_media_agent is None):
        storage_policy_copyinfo = {
            &#34;extendedFlags&#34;: {
                &#34;globalStoragePolicy&#34;: 1
            }
        }
        request_json[&#34;storagePolicyCopyInfo&#34;].update(storage_policy_copyinfo)

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, self._POLICY, request_json
    )

    if flag:
        if response.json():
            if &#39;error&#39; in response.json() and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                # initialize the policies again
                # so the policies object has all the policies
                self.refresh()

            else:
                error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                o_str = &#39;Failed to create storage policy\nError: &#34;{0}&#34;&#39;

                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    return self.get(global_storage_policy_name)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicies.add_tape_sp"><code class="name flex">
<span>def <span class="ident">add_tape_sp</span></span>(<span>self, storage_policy_name, library, media_agent, drive_pool, scratch_pool, retention_period_days=15, ocum_server=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds storage policy with tape data path</p>
<h2 id="args">Args</h2>
<pre><code>storage_policy_name (str)         --  name of the new storage policy to add

library             (str)     --  name or instance of the library
to add the policy to

media_agent         (str/object)  --  name or instance of media agent
to add the policy to

drive_pool          (str)         --  Drive pool name of the tape library

scratch_pool      (str)          --  Scratch pool name of the tape library

retention_period_days    (int)         --  time period in days to retain
the data backup for
default: 15

ocum_server         (str)         --  On Command Unified Server Name
default: None
</code></pre>
<p>Raises:
SDKException:
if type of the storage policy name argument is not string</p>
<pre><code>    if type of the retention period argument is not int

    if type of the library argument is not either string or DiskLibrary instance

    if type of the media agent argument is not either string or MediaAgent instance

    if failed to create storage policy

    if response is empty

    if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L797-L907" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_tape_sp(self, storage_policy_name, library, media_agent, drive_pool, scratch_pool, retention_period_days=15,
                ocum_server=None):
    &#34;&#34;&#34;
    Adds storage policy with tape data path
    Args:
            storage_policy_name (str)         --  name of the new storage policy to add

            library             (str)     --  name or instance of the library
            to add the policy to

            media_agent         (str/object)  --  name or instance of media agent
            to add the policy to

            drive_pool          (str)         --  Drive pool name of the tape library

            scratch_pool      (str)          --  Scratch pool name of the tape library

            retention_period_days    (int)         --  time period in days to retain
            the data backup for
            default: 15

            ocum_server         (str)         --  On Command Unified Server Name
            default: None

        Raises:
            SDKException:
                if type of the storage policy name argument is not string

                if type of the retention period argument is not int

                if type of the library argument is not either string or DiskLibrary instance

                if type of the media agent argument is not either string or MediaAgent instance

                if failed to create storage policy

                if response is empty

                if response is not success
    &#34;&#34;&#34;
    tape_library = library
    if not (isinstance(drive_pool, str) and
            isinstance(scratch_pool, str) and
            isinstance(tape_library, str) and
            isinstance(media_agent, str) and
            isinstance(storage_policy_name, str) and
            (retention_period_days is None or isinstance(retention_period_days, int))):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    request_json = {
        &#34;storagePolicyCopyInfo&#34;: {
            &#34;retentionRules&#34;: {
                &#34;retainBackupDataForDays&#34;: retention_period_days
            },
            &#34;library&#34;: {
                &#34;libraryName&#34;: tape_library
            },
            &#34;mediaAgent&#34;: {
                &#34;mediaAgentName&#34;: media_agent
            }
        },
        &#34;drivePool&#34;: drive_pool,
        &#34;scratchpool&#34;: scratch_pool,
        &#34;storagePolicyName&#34;: storage_policy_name
    }

    if ocum_server is not None:
        ocum_server_dict1 = {
            &#34;dfmServer&#34;: {
                &#34;name&#34;: ocum_server,
                &#34;id&#34;: 0
            }
        }

        ocum_server_dict2 = {
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;snapLibrary&#34;: {
                    &#34;libraryName&#34;: &#34;Use primary copy&#39;s library and mediaAgent&#34;
                },
                &#34;storagePolicyFlags&#34;: {
                    &#34;enableSnapshot&#34;: 1
                }
            }
        }

        request_json[&#34;storagePolicyCopyInfo&#34;].update(ocum_server_dict2[&#34;storagePolicyCopyInfo&#34;])
        request_json.update(ocum_server_dict1)

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, self._POLICY, request_json
    )

    if flag:
        if response.json():
            if &#39;error&#39; in response.json() and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                # initialize the policies again
                # so the policies object has all the policies
                self.refresh()

            else:
                error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                o_str = &#39;Failed to create storage policy with tape data path\nError: &#34;{0}&#34;&#39;

                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    return self.get(storage_policy_name)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicies.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, storage_policy_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a storage policy from the commcell.</p>
<h2 id="args">Args</h2>
<p>storage_policy_name (str)
&ndash;
name of the storage policy to delete</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the storage policy name argument is not string</p>
<pre><code>if failed to delete storage policy

if response is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L909-L962" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delete(self, storage_policy_name):
    &#34;&#34;&#34;Deletes a storage policy from the commcell.

        Args:
            storage_policy_name (str)  --  name of the storage policy to delete

        Raises:
            SDKException:
                if type of the storage policy name argument is not string

                if failed to delete storage policy

                if response is empty

                if response is not success
    &#34;&#34;&#34;
    if not isinstance(storage_policy_name, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    if self.has_policy(storage_policy_name):
        storagepolicy_id = self.all_storage_policies[storage_policy_name.lower()]
        policy_delete_service = self._DELETE_POLICY + &#39;/{0}&#39;.format(storagepolicy_id)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;DELETE&#39;, policy_delete_service
        )

        if flag:
            try:
                if response.json():
                    if &#39;error&#39; in response.json():
                        if &#39;errorCode&#39; in response.json()[&#39;error&#39;] and &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = response.json()[&#39;error&#39;][&#39;errorMessage&#39;]
                            o_str = &#39;Failed to delete storage policy\nError: &#34;{0}&#34;&#39;

                            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str.format(error_message))
                        elif &#39;errorCode&#39; in response.json()[&#39;error&#39;] and response.json()[&#39;error&#39;][&#39;errorCode&#39;] == 0:
                            self.refresh()
                            return response.text.strip()
            except ValueError:
                if response.text:
                    if &#39;errorCode&#39; in response.text and &#39;errorMessage&#39; in response.text:
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, response.text.strip())
                    self.refresh()
                    return response.text.strip()
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
    else:
        raise SDKException(
            &#39;Storage&#39;, &#39;102&#39;, &#39;No policy exists with name: {0}&#39;.format(storage_policy_name)
        )</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicies.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, storage_policy_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a StoragePolicy object of the specified storage policy name.</p>
<h2 id="args">Args</h2>
<p>storage_policy_name
(str)
&ndash;
name of the storage policy</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the StoragePolicy class for the given policy name</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the storage policy name argument is not string</p>
<pre><code>if no storage policy exists with the given name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L362-L389" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get(self, storage_policy_name):
    &#34;&#34;&#34;Returns a StoragePolicy object of the specified storage policy name.

        Args:
            storage_policy_name     (str)   --  name of the storage policy

        Returns:
            object - instance of the StoragePolicy class for the given policy name

        Raises:
            SDKException:
                if type of the storage policy name argument is not string

                if no storage policy exists with the given name
    &#34;&#34;&#34;
    if not isinstance(storage_policy_name, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    storage_policy_name = storage_policy_name.lower()

    if self.has_policy(storage_policy_name):
        return StoragePolicy(
            self._commcell_object, storage_policy_name, self._policies[storage_policy_name]
        )
    else:
        raise SDKException(
            &#39;Storage&#39;, &#39;102&#39;, &#39;No policy exists with name: {0}&#39;.format(storage_policy_name)
        )</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicies.has_policy"><code class="name flex">
<span>def <span class="ident">has_policy</span></span>(<span>self, policy_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a storage policy exists in the commcell with the input storage policy name.</p>
<h2 id="args">Args</h2>
<p>policy_name (str)
&ndash;
name of the storage policy</p>
<h2 id="returns">Returns</h2>
<p>bool - boolean output whether the storage policy exists in the commcell or not</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the storage policy name argument is not string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L344-L360" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_policy(self, policy_name):
    &#34;&#34;&#34;Checks if a storage policy exists in the commcell with the input storage policy name.

        Args:
            policy_name (str)  --  name of the storage policy

        Returns:
            bool - boolean output whether the storage policy exists in the commcell or not

        Raises:
            SDKException:
                if type of the storage policy name argument is not string
    &#34;&#34;&#34;
    if not isinstance(policy_name, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    return self._policies and policy_name.lower() in self._policies</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicies.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the storage policies associated with the Commcell.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L964-L966" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Refresh the storage policies associated with the Commcell.&#34;&#34;&#34;
    self._policies = self._get_policies()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy"><code class="flex name class">
<span>class <span class="ident">StoragePolicy</span></span>
<span>(</span><span>commcell_object, storage_policy_name, storage_policy_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for performing storage policy operations for a specific storage policy</p>
<p>Initialise the Storage Policy class instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L969-L3374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StoragePolicy(object):
    &#34;&#34;&#34;Class for performing storage policy operations for a specific storage policy&#34;&#34;&#34;

    def __init__(self, commcell_object, storage_policy_name, storage_policy_id=None):
        &#34;&#34;&#34;Initialise the Storage Policy class instance.&#34;&#34;&#34;
        self._storage_policy_name = storage_policy_name.lower()
        self._commcell_object = commcell_object

        if storage_policy_id:
            self._storage_policy_id = str(storage_policy_id)
        else:
            self._storage_policy_id = self._get_storage_policy_id()

        self._STORAGE_POLICY = self._commcell_object._services[&#39;GET_STORAGE_POLICY&#39;] % (
            self.storage_policy_id
        )
        self._STORAGE_POLICY_ADVANCED = self._commcell_object._services[&#39;GET_STORAGE_POLICY_ADVANCED&#39;] % (
            self.storage_policy_id
        )
        self._storage_policy_properties = None
        self._storage_policy_advanced_properties = None
        self._copies = {}
        self.refresh()

    def __repr__(self):
        &#34;&#34;&#34;String representation of the instance of this class.&#34;&#34;&#34;
        representation_string = &#39;Storage Policy class instance for Storage Policy: &#34;{0}&#34;&#39;
        return representation_string.format(self.storage_policy_name)

    def _get_storage_policy_id(self):
        &#34;&#34;&#34;Gets the storage policy id asscoiated with the storage policy&#34;&#34;&#34;

        storage_policies = StoragePolicies(self._commcell_object)
        return storage_policies.get(self.storage_policy_name).storage_policy_id

    def _get_storage_policy_advanced_properties(self):
        &#34;&#34;&#34;Gets the advanced storage policy properties of this storage policy.

            Returns:
                dict - dictionary consisting of the advanced properties of this storage policy

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;GET&#39;, self._STORAGE_POLICY_ADVANCED
        )

        if flag:
            if response.json():
                return response.json()
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _get_storage_policy_properties(self):
        &#34;&#34;&#34;Gets the storage policy properties of this storage policy.

            Returns:
                dict - dictionary consisting of the properties of this storage policy

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;GET&#39;, self._STORAGE_POLICY
        )

        if flag:
            if response.json():
                return response.json()
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def _initialize_storage_policy_properties(self):
        &#34;&#34;&#34;Initializes the common properties for the storage policy.&#34;&#34;&#34;
        self._storage_policy_properties = self._get_storage_policy_properties()
        self._copies = {}

        if &#39;copy&#39; in self._storage_policy_properties:
            for copy in self._storage_policy_properties[&#39;copy&#39;]:
                copy_type = copy[&#39;copyType&#39;]
                active = copy[&#39;active&#39;]
                copy_id = copy[&#39;StoragePolicyCopy&#39;][&#39;copyId&#39;]
                copy_name = copy[&#39;StoragePolicyCopy&#39;][&#39;copyName&#39;].lower()
                try:
                    library_name = copy[&#39;library&#39;][&#39;libraryName&#39;]
                except:
                    library_name = None
                copy_precedence = copy[&#39;copyPrecedence&#39;]
                is_snap_copy = bool(int(copy[&#39;isSnapCopy&#39;]))
                is_default_copy = bool(int(copy.get(&#39;isDefault&#39;, 0)))
                temp = {
                    &#34;copyType&#34;: copy_type,
                    &#34;active&#34;: active,
                    &#34;copyId&#34;: copy_id,
                    &#34;libraryName&#34;: library_name,
                    &#34;copyPrecedence&#34;: copy_precedence,
                    &#34;isSnapCopy&#34;: is_snap_copy,
                    &#34;isDefault&#34;: is_default_copy
                }
                self._copies[copy_name] = temp

    def edit_block_size_on_gdsp(self,
                                size=512):
        &#34;&#34;&#34;
        edit the block size on the gdsp

        Args:
                size (int) - SIDB block size to be changed to


        Raises:
            SDKException:
                    if error in response

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        request_json = {
                        &#34;App_UpdateStoragePolicyReq&#34;: {
                            &#34;StoragePolicy&#34;: {
                                &#34;storagePolicyName&#34;: self._storage_policy_name
                            },
                            &#34;sidbBlockSizeKB&#34;: size
                          }
                        }

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_json
        )

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = &#34;Failed to update block size factor on gdsp with error \
                                    {0}&#34;.format(str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                        else:
                            error_message = &#34;Failed to update block size factor on gdsp&#34;
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def has_copy(self, copy_name):
        &#34;&#34;&#34;Checks if a storage policy copy exists for this storage
            policy with the input storage policy name.

            Args:
                copy_name (str)  --  name of the storage policy copy

            Returns:
                bool - boolean output whether the storage policy copy exists or not

            Raises:
                SDKException:
                    if type of the storage policy copy name argument is not string
        &#34;&#34;&#34;
        if not isinstance(copy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        return self._copies and copy_name.lower() in self._copies

    def create_secondary_copy(self,
                              copy_name,
                              library_name=None,
                              media_agent_name=None,
                              drive_pool=None,
                              spare_pool=None,
                              tape_library_id=None,
                              drive_pool_id=None,
                              spare_pool_id=None,
                              snap_copy=False,
                              global_policy=None,
                              retention_days=30):
        &#34;&#34;&#34;Creates Synchronous copy for this storage policy

            Args:
                copy_name           (str)   --  copy name to create

                library_name        (str)   --  library name to be assigned

                media_agent_name    (str)   --  media_agent to be assigned

                snap_copy           (bool)  --  boolean on whether copy should be a snap copy
                default: False

                global_policy       (str)   --  name of the global policy to be assigned

            Raises:
                SDKException:
                    if type of inputs in not string

                    if copy with given name already exists

                    if failed to create copy

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        if global_policy is not None:
            if not (isinstance(copy_name, str) and isinstance(global_policy, str)):
                raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

            if self.has_copy(copy_name):
                err_msg = f&#39;Storage Policy copy &#34;{copy_name}&#34; already exists.&#39;
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

            if not self._commcell_object.storage_pools.has_storage_pool(global_policy):
                err_msg = f&#39;No Global Storage Policy &#34;{global_policy}&#34; exists.&#39;
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

            global_policy = self._commcell_object.storage_pools.get(global_policy)

            global_policy_copy = StoragePolicyCopy (self._commcell_object, global_policy.storage_pool_name, global_policy.copy_name)

            is_global_dedupe_policy = global_policy_copy._dedupe_flags.get(&#39;enableDeduplication&#39;, 0)
            
            request = {
                       &#34;copyName&#34;: copy_name,
                       &#34;storagePolicyCopyInfo&#34;: {
                          &#34;copyType&#34;: 0,
                          &#34;isDefault&#34;: 0,
                          &#34;isMirrorCopy&#34;: 0,
                          &#34;isSnapCopy&#34;: 0,
                          &#34;numberOfStreamsToCombine&#34;: 1,
                          &#34;StoragePolicyCopy&#34;: {
                             &#34;_type_&#34;: 18,
                             &#34;storagePolicyName&#34;: self.storage_policy_name
                          },
                          &#34;retentionRules&#34;: {
                             &#34;retainArchiverDataForDays&#34;: -1,
                             &#34;retainBackupDataForCycles&#34;: 1,
                             &#34;retainBackupDataForDays&#34;: retention_days
                          },
                          &#34;dedupeFlags&#34;: {
                              &#34;enableDeduplication&#34;: is_global_dedupe_policy,
                              &#34;useGlobalDedupStore&#34;: is_global_dedupe_policy
                          },
                           &#34;useGlobalPolicy&#34;:{
                               &#34;storagePolicyName&#34;: global_policy.storage_pool_name
                           },
                           &#34;extendedFlags&#34;:{
                               &#34;useGlobalStoragePolicy&#34;: 1
                           }
                       }
                    }

        else:
            if not (isinstance(copy_name, str) and
                    isinstance(library_name, str) and
                    isinstance(media_agent_name, str)):
                raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

            if self.has_copy(copy_name):
                err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

            media_agent_id = self._commcell_object.media_agents._media_agents[media_agent_name.lower()][&#39;id&#39;]

            snap_copy = int(snap_copy)

            if drive_pool is not None:
                    request = &#34;&#34;&#34;
                            &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                                &lt;storagePolicyCopyInfo copyType=&#34;0&#34; isDefault=&#34;0&#34; isMirrorCopy=&#34;0&#34; isSnapCopy=&#34;{11}&#34; numberOfStreamsToCombine=&#34;1&#34;&gt;
                                    &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                                    &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                                    &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                                    &lt;drivePool drivePoolId = &#34;{7}&#34; drivePoolName = &#34;{8}&#34;  libraryName = &#34;{4}&#34; /&gt;
                                    &lt;spareMediaGroup spareMediaGroupId = &#34;{9}&#34; spareMediaGroupName = &#34;{10}&#34; libraryName = &#34;{4}&#34; /&gt;
                                    &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;1&#34; retainBackupDataForDays=&#34;30&#34; /&gt;
                                &lt;/storagePolicyCopyInfo&gt;
                            &lt;/App_CreateStoragePolicyCopyReq&gt;
                            &#34;&#34;&#34;.format(copy_name, self.storage_policy_id, self.storage_policy_name,
                                       tape_library_id, library_name, media_agent_id, media_agent_name,
                                       drive_pool_id, drive_pool, spare_pool_id, spare_pool, snap_copy)

            else:
                library_id = self._commcell_object.disk_libraries._libraries[library_name.lower()]
                request = &#34;&#34;&#34;
                &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                    &lt;storagePolicyCopyInfo copyType=&#34;0&#34; isDefault=&#34;0&#34; isMirrorCopy=&#34;0&#34; isSnapCopy=&#34;{7}&#34; numberOfStreamsToCombine=&#34;1&#34;&gt;
                        &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                        &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                        &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                        &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;1&#34; retainBackupDataForDays=&#34;30&#34; /&gt;
                    &lt;/storagePolicyCopyInfo&gt;
                &lt;/App_CreateStoragePolicyCopyReq&gt;
                &#34;&#34;&#34;.format(copy_name, self.storage_policy_id, self.storage_policy_name,
                           library_id, library_name, media_agent_id, media_agent_name, snap_copy)

        create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, create_copy_service, request
        )

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = &#34;Failed to create {0} Storage Policy copy with error \
                            {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                        else:
                            error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                                copy_name
                            )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def run_content_indexing(self):
        &#34;&#34;&#34;starts the offline CI job for this storage policy

            Args:
                None

            Returns:
                object - instance of the Job class for this CI job

            Raises:
                SDKException:
                        if type of inputs is not valid

                        if failed to start content indexing job

                        if response received is empty

                        if response is not success
        &#34;&#34;&#34;
        request_xml = &#34;&#34;&#34;&lt;TMMsg_CreateTaskReq&gt;
        &lt;taskInfo&gt;
        &lt;associations subclientId=&#34;0&#34; storagePolicyId=&#34;{0}&#34; applicationId=&#34;0&#34; clientName=&#34;&#34; backupsetId=&#34;0&#34;
        instanceId=&#34;0&#34; commCellId=&#34;0&#34; clientId=&#34;0&#34; subclientName=&#34;&#34; mediaAgentId=&#34;0&#34; mediaAgentName=&#34;&#34; backupsetName=&#34;&#34;
        instanceName=&#34;&#34; storagePolicyName=&#34;{1}&#34; _type_=&#34;0&#34; appName=&#34;&#34; /&gt;
        &lt;task ownerId=&#34;1&#34; taskType=&#34;1&#34; ownerName=&#34;admin&#34; sequenceNumber=&#34;0&#34; initiatedFrom=&#34;1&#34; policyType=&#34;0&#34; taskId=&#34;0&#34;&gt;
        &lt;taskFlags disabled=&#34;0&#34; /&gt;&lt;/task&gt;
        &lt;subTasks subTaskOperation=&#34;1&#34;&gt;&lt;subTask subTaskType=&#34;1&#34; operationType=&#34;4022&#34; /&gt;
        &lt;options&gt;&lt;backupOpts&gt;&lt;mediaOpt&gt;
        &lt;auxcopyJobOption maxNumberOfStreams=&#34;0&#34; allCopies=&#34;1&#34; useMaximumStreams=&#34;1&#34;&gt;&lt;mediaAgent mediaAgentId=&#34;0&#34;
        _type_=&#34;11&#34; mediaAgentName=&#34;&#34; /&gt;
        &lt;/auxcopyJobOption&gt;&lt;/mediaOpt&gt;&lt;/backupOpts&gt;&lt;adminOpts&gt;
        &lt;contentIndexingOption fileAnalytics=&#34;0&#34; subClientBasedAnalytics=&#34;0&#34; reanalyze=&#34;0&#34; /&gt;
        &lt;/adminOpts&gt;
        &lt;restoreOptions&gt;&lt;virtualServerRstOption isBlockLevelReplication=&#34;0&#34; /&gt;&lt;commonOptions syncRestore=&#34;0&#34; /&gt;
        &lt;/restoreOptions&gt;&lt;/options&gt;&lt;/subTasks&gt;
        &lt;/taskInfo&gt;&lt;/TMMsg_CreateTaskReq&gt;&#34;&#34;&#34;.format(self._storage_policy_id, self._storage_policy_name)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
        )

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, &#39;Unable to get job id for CI job&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;, &#39;Empty response&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;)

    def enable_content_indexing(
            self,
            cloud_id,
            include_doc_type=None,
            max_doc_size=None,
            min_doc_size=None,
            exclude_doc_type=None):
        &#34;&#34;&#34;configures offline CI for this storage policy

                Args:

                    cloud_id            (str)   --  cloud id of the search engine

                    include_doc_type    (str)   --  include document types for content indexing

                        Example : &#34;*.csv,*.ppt&#34;

                    exclude_doc_type    (str)   --  exclude document types for content indexing

                        Example : &#34;*.py,*.txt&#34;

                    max_doc_size        (str)   --  maximum document size for CI in KB

                    min_doc_size        (str)   --  minimum document size for CI in KB

                Returns:
                    None

                Raises:

                    SDKException:
                            if type of inputs is not valid

                            if failed to configure content indexing

                            if response received is empty

                            if response is not success
        &#34;&#34;&#34;
        if not isinstance(cloud_id, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if include_doc_type is None:
            include_doc_type = &#34;*.bmp,*.csv,*.doc,*.docx,*.dot,*.eml,*.htm,*.html,*.jpeg,*.jpg,*.log,*.msg,*.odg,&#34; \
                               &#34;*.odp,*.ods,*.odt,*.pages,*.pdf,*.png,*.ppt,*.pptx,*.rtf,*.txt,*.xls,*.xlsx,*.xmind,*.xml&#34;
        if max_doc_size is None:
            max_doc_size = &#34;51200&#34;

        if min_doc_size is None:
            min_doc_size = &#34;0&#34;

        if exclude_doc_type is None:
            exclude_doc_type = &#34;&#34;

        request_xml = &#34;&#34;&#34;&lt;EVGui_ContentIndexingControlReq operation=&#34;16&#34;&gt;&lt;header localeId=&#34;0&#34; userId=&#34;0&#34;/&gt;
        &lt;ciProps archGroupId=&#34;{0}&#34; calendarId=&#34;1&#34; cloudId=&#34;{1}&#34; contentIndexDataOver=&#34;0&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
         enable=&#34;1&#34; entityIds=&#34;&#34; excludeDocTypes=&#34;{5}&#34; filterSelected=&#34;1&#34; flags=&#34;0&#34;
         includeDocTypes=&#34;{2}&#34; indexType=&#34;0&#34; jobsOlderThan=&#34;0&#34;
         maxDocSizeKB=&#34;{3}&#34; minDocSizeKB=&#34;{4}&#34; numPeriod=&#34;1&#34; retentionDays=&#34;-1&#34; sourceCopyId=&#34;0&#34; startTime=&#34;0&#34;
         synchronizeOn=&#34;0&#34; type=&#34;0&#34;/&gt;&lt;/EVGui_ContentIndexingControlReq&gt;&#34;&#34;&#34;\
            .format(self._storage_policy_id, cloud_id, include_doc_type, max_doc_size, min_doc_size, exclude_doc_type)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
        )

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 1:
                        error_message = &#34;Failed to enable content indexing for this storage policy&#34;
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;, &#39;No success error code found in response&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def enable_entity_extraction(self, entity_details, entity_names, ca_client_name):
        &#34;&#34;&#34;configures offline CI entity extraction for given subclient id&#39;s on this storage policy

                Args:
                    entity_details     (list)     --  List of subclient to configure for Entity Extraction

                    Format : [[clientname,agent type,backup set name,subclient name]]

                    entity_names         (list)   --  list of entity names to be configured for Entity Extraction

                    Example : [Email,SSN]

                    ca_client_name       (str)    --  client name where Content Analyzer package is installed

                Raises:
                    SDKException:
                        if type of inputs is not valid

                        if failed to configure EE

                        if response received is empty

                        if response is not success
        &#34;&#34;&#34;
        if not (isinstance(entity_details, list) and isinstance(entity_names, list)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        if not isinstance(ca_client_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        request_xml = &#34;&#34;&#34;&lt;EVGui_SetEntityExtractionListReq archGroupId=&#34;{0}&#34;&gt;
        &lt;entityExtraction isConfigured=&#34;1&#34;&gt;&#34;&#34;&#34;.format(self._storage_policy_id)
        for subclient in entity_details:
            client_name = subclient[0]
            app_name = subclient[1]
            backup_set_name = subclient[2]
            subclient_name = subclient[3]
            client_obj = self._commcell_object.clients.get(client_name)
            agent_obj = client_obj.agents.get(app_name)
            backup_set_obj = agent_obj.backupsets.get(backup_set_name)
            subclient_obj = backup_set_obj.subclients.get(subclient_name)
            if subclient_obj.storage_policy.lower() != self._storage_policy_name.lower():
                err_msg = &#39;Subclient &#34;{0}&#34; is not a part of this storage policy&#39;.format(subclient_name)
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)
            subclient_prop = subclient_obj.properties
            request_xml = request_xml + &#34;&#34;&#34;&lt;appList appOperation=&#34;0&#34; appTypeId=&#34;{0}&#34; archGroupId=&#34;0&#34;
                backupSetId=&#34;{1}&#34; clientId=&#34;{2}&#34; instanceId=&#34;{3}&#34; subClientId=&#34;{4}&#34;/&gt;&#34;&#34;&#34;.format(
                subclient_prop[&#39;subClientEntity&#39;][&#39;applicationId&#39;],
                subclient_prop[&#39;subClientEntity&#39;][&#39;backupsetId&#39;],
                subclient_prop[&#39;subClientEntity&#39;][&#39;clientId&#39;],
                subclient_prop[&#39;subClientEntity&#39;][&#39;instanceId&#39;],
                subclient_prop[&#39;subClientEntity&#39;][&#39;subclientId&#39;],
            )

        for entity in entity_names:
            entity_obj = self._commcell_object.activate.entity_manager().get(entity)
            request_xml = request_xml + &#34;&#34;&#34;&lt;entities enabled=&#34;1&#34; entityId=&#34;{0}&#34; entityName=&#34;{1}&#34;/&gt;&#34;&#34;&#34;\
                .format(entity_obj.entity_id, entity)

        client_obj = self._commcell_object.clients.get(ca_client_name)
        request_xml = request_xml + &#34;&#34;&#34;&lt;extractingClientList enabled=&#34;1&#34;&gt;
        &lt;eeClient clientId=&#34;{0}&#34; clientName=&#34;{1}&#34;/&gt;
        &lt;/extractingClientList&gt;&lt;/entityExtraction&gt;&lt;/EVGui_SetEntityExtractionListReq&gt;&#34;&#34;&#34;\
            .format(client_obj.client_id, ca_client_name)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
        )

        if flag:
            if response.json():
                if &#39;errorCode&#39; in response.json():
                    error_code = int(response.json()[&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to enable entity extraction for this storage policy&#34;
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;, &#39;No success error code found in response&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def create_snap_copy(self,
                         copy_name,
                         is_mirror_copy,
                         is_snap_copy,
                         library_name,
                         media_agent_name,
                         source_copy,
                         provisioning_policy=None,
                         resource_pool=None,
                         is_replica_copy=None,
                         **kwargs):
        &#34;&#34;&#34;Creates Snap copy for this storage policy

            Args:
                copy_name           (str)   --  copy name to create

                is_mirror_copy      (bool)   --  if true then copyType will be Mirror

                is_snap_copy        (bool)   --  if true then copyType will be Snap

                library_name        (str)   --  library name to be assigned

                media_agent_name    (str)   --  media_agent to be assigned

                source_copy         (str)   --  Name of the Source Copy for this copy

                provisioning_policy (str)   --  Name of the provisioning Policy to add
                default : None

                resource_pool       (str)   --  Name of the resource pool to add
                default : None

                is_replica_copy     (bool)   --  if true then Replica Copy will be created
                default : None

                is_c2c_target       (bool)   -- if true then NetApp Cloud target copy will be created 
                default : False

                job_retention       (bool)  -- if true job based retention will be set
                default : False

                enable_selective_copy (int) -- Enable selective copy with value selectiveRule

            Raises:
                SDKException:
                    if type of inputs in not string

                    if copy with given name already exists

                    if failed to create copy

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and
                isinstance(library_name, str) and
                isinstance(media_agent_name, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if self.has_copy(copy_name):
            err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        if is_replica_copy:
            arrayReplicaCopy = &#34;1&#34;
            useOfflineReplication = &#34;1&#34;
        else:
            arrayReplicaCopy = &#34;0&#34;
            useOfflineReplication = &#34;0&#34;
        if is_mirror_copy:
            is_mirror_copy = 1
        else:
            is_mirror_copy = 0
        if is_snap_copy:
            is_snap_copy = 1
        else:
            is_snap_copy = 0
        if provisioning_policy is None:
            provisioning_policy = &#34;&#34;
            resource_pool = &#34;&#34;

        is_c2c_target = kwargs.get(&#39;is_c2c_target&#39;, False)
        isNetAppSnapCloudTargetCopy = 1 if is_c2c_target else 0

        job_based_retention = kwargs.get(&#39;job_based_retention&#39;, False)
        job_retention = 1 if job_based_retention else 0

        selectiveRule = kwargs.get(&#39;enable_selective_copy&#39;, None)
        if selectiveRule is None:
            request_xml = &#34;&#34;&#34;
                    &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                        &lt;storagePolicyCopyInfo active=&#34;1&#34; isMirrorCopy=&#34;{1}&#34; isSnapCopy=&#34;{2}&#34; provisioningPolicyName=&#34;{3}&#34;&gt;
                            &lt;StoragePolicyCopy _type_=&#34;18&#34; copyName=&#34;{0}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                            &lt;extendedFlags arrayReplicaCopy=&#34;{5}&#34; isNetAppSnapCloudTargetCopy=&#34;{12}&#34; useOfflineArrayReplication=&#34;{6}&#34; /&gt;
                            &lt;library _type_=&#34;9&#34; libraryName=&#34;{7}&#34; /&gt;
                            &lt;mediaAgent _type_=&#34;11&#34; mediaAgentName=&#34;{8}&#34; /&gt;
                            &lt;spareMediaGroup _type_=&#34;67&#34; libraryName=&#34;{7}&#34; /&gt;
                            &lt;retentionRules jobs=&#34;8&#34; retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;5&#34; retainBackupDataForDays=&#34;1&#34;&gt;
                            &lt;retentionFlags jobBasedRetention=&#34;{11}&#34; /&gt;
                            &lt;/retentionRules&gt;
                            &lt;sourceCopy _type_=&#34;18&#34; copyName=&#34;{9}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                            &lt;resourcePoolsList operation=&#34;1&#34; resourcePoolName=&#34;{10}&#34; /&gt;
                        &lt;/storagePolicyCopyInfo&gt;
                    &lt;/App_CreateStoragePolicyCopyReq&gt;
                    &#34;&#34;&#34;.format(copy_name, is_mirror_copy, is_snap_copy, provisioning_policy,
                               self.storage_policy_name, arrayReplicaCopy, useOfflineReplication,
                               library_name, media_agent_name, source_copy, resource_pool, job_retention, isNetAppSnapCloudTargetCopy)
        else:
            request_xml = &#34;&#34;&#34;
                                        &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                                            &lt;storagePolicyCopyInfo copyType=&#34;2&#34; description=&#34;&#34; isMirrorCopy=&#34;{1}&#34; isSnapCopy=&#34;{2}&#34;&gt;
                                                &lt;StoragePolicyCopy copyName=&#34;{0}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                                                &lt;extendedFlags arrayReplicaCopy=&#34;{5}&#34; isNetAppSnapCloudTargetCopy=&#34;{12}&#34; useOfflineArrayReplication=&#34;{6}&#34; /&gt;
                                                &lt;library  libraryName=&#34;{7}&#34; /&gt;
                                                &lt;mediaAgent _type_=&#34;11&#34; mediaAgentName=&#34;{8}&#34; /&gt;
                                                &lt;retentionRules jobs=&#34;8&#34; retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;5&#34; retainBackupDataForDays=&#34;1&#34;&gt;
                                                &lt;retentionFlags jobBasedRetention=&#34;{11}&#34; /&gt;
                                                &lt;/retentionRules&gt;
                                                &lt;sourceCopy _type_=&#34;18&#34; copyName=&#34;{9}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                                                &lt;selectiveCopyRules selectiveRule=&#34;{13}&#34;/&gt;
                                                &lt;/storagePolicyCopyInfo&gt;
                                        &lt;/App_CreateStoragePolicyCopyReq&gt;
                                        &#34;&#34;&#34;.format(copy_name, is_mirror_copy, is_snap_copy, provisioning_policy,
                                                   self.storage_policy_name, arrayReplicaCopy, useOfflineReplication,
                                                   library_name, media_agent_name, source_copy, resource_pool,
                                                   job_retention, isNetAppSnapCloudTargetCopy, selectiveRule)

        create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, create_copy_service, request_xml
        )

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = &#34;Failed to create {0} Storage Policy copy with error \
                            {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                        else:
                            error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                                copy_name
                            )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def delete_secondary_copy(self, copy_name):
        &#34;&#34;&#34;Deletes the copy associated with this storage policy

            Args:
                copy_name   (str)   --  copy name to be deleted

            Raises:
                SDKException:
                    if type of input parameters is not string

                    if storage policy copy doesn&#39;t exist with given name

                    if failed to delete storage policy copy

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        if not isinstance(copy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        else:
            copy_name = copy_name.lower()

        if not self.has_copy(copy_name):
            err_msg = &#39;Storage Policy copy &#34;{0}&#34; doesn\&#39;t exists.&#39;.format(copy_name)
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        delete_copy_service = self._commcell_object._services[&#39;DELETE_STORAGE_POLICY_COPY&#39;]

        request_xml = &#34;&#34;&#34;
        &lt;App_DeleteStoragePolicyCopyReq&gt;
            &lt;archiveGroupCopy _type_=&#34;18&#34; copyId=&#34;{0}&#34; copyName=&#34;{1}&#34; storagePolicyId=&#34;{2}&#34; storagePolicyName=&#34;{3}&#34; /&gt;
        &lt;/App_DeleteStoragePolicyCopyReq&gt;
        &#34;&#34;&#34;.format(self._copies[copy_name][&#39;copyId&#39;], copy_name, self.storage_policy_id,
                   self.storage_policy_name)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, delete_copy_service, request_xml
        )

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to delete {0} Storage Policy copy&#34;.format(
                            copy_name
                        )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def create_selective_copy(self,
                              copy_name,
                              library_name,
                              media_agent_name,
                              sel_freq,
                              first_or_last_full,
                              backups_from,
                              daystartson=None):
        &#34;&#34;&#34;Creates Selective copy for this storage policy

            Args:
                copy_name           (str)   --  copy name to create
                library_name        (str)   --  library name to be assigned
                media_agent_name    (str)   --  media_agent to be assigned
                drive_pool etc are for tape library

                sel_freq            (str) -- {all,hourly,daily,weekly,monthly,quaterly,half-year,year}
                first_or_last_full  (str) -- {FirstFull, LastFull, LastFullWait}
                backups_from        (str) -- {start date in yyyy-mm-dd format to pick jobs from this date}

            Raises:
                SDKException:
                    if type of inputs in not string

                    if copy with given name already exists

                    if failed to create copy

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and
                isinstance(library_name, str) and
                isinstance(media_agent_name, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if self.has_copy(copy_name):
            err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        media_agent_id = self._commcell_object.media_agents._media_agents[media_agent_name.lower()][&#39;id&#39;]

        selective_copy_freq = {&#39;all&#39;: 2, &#39;hourly&#39;: 262144, &#39;daily&#39;: 524288, &#39;weekly&#39;: 4, &#39;monthly&#39;: 8,
                               &#39;quarterly&#39;: 16, &#39;halfyearly&#39;: 32, &#39;yearly&#39;: 64, &#39;advanced&#39;: 16777216
                               }
        week_starts_on = {&#39;Sunday&#39;: 0, &#39;Monday&#39;: 1, &#39;Tuesday&#39;: 2, &#39;Wednesday&#39;: 3, &#39;Thursday&#39;: 4,
                          &#39;Friday&#39;: 5, &#39;Saturday&#39;: 6
                          }

        selective_rule = selective_copy_freq[sel_freq]
        copyflags = &#34;&#34;
        if first_or_last_full == &#34;LastFull&#34;:
            copyflags = &#34;&#34;&#34;&lt;copyFlags lastFull = &#34;1&#34; /&gt;&#34;&#34;&#34;
        elif first_or_last_full == &#34;LastFullWait&#34;:
            copyflags = &#34;&#34;&#34;&lt;copyFlags lastFull = &#34;1&#34; lastFullWait=&#34;1&#34; /&gt;&#34;&#34;&#34;

        dsostr = &#34;&#34;
        if (sel_freq == &#39;daily&#39; or sel_freq == &#39;hourly&#39;) and daystartson is not None \
                and isinstance(daystartson, dict):
            dsostr = &#34;&#34;&#34;
                        &lt;dayStartsAt amOrPm = &#34;{3}&#34;&gt; 
                        &lt;dayStartsHoursMinutes hours=&#34;{0}&#34; minutes = &#34;{1}&#34;  seconds= &#34;{2}&#34; /&gt;
                        &lt;/dayStartsAt&gt; 
                     &#34;&#34;&#34;.format(daystartson[&#34;hours&#34;], daystartson[&#34;minutes&#34;], daystartson[&#34;seconds&#34;],
                                daystartson[&#34;ampm&#34;])

        day_starts = &#34;&#34;
        if sel_freq == &#39;weekly&#39;:
            if daystartson is not None:
                day_starts = &#34;&#34;&#34; weekDayStartsOn=&#34;{0}&#34; &#34;&#34;&#34;.format(week_starts_on[daystartson])
            else:
                day_starts = &#34;&#34;&#34; weekDayStartsOn=&#34;{0}&#34; &#34;&#34;&#34;.format(week_starts_on[&#39;Friday&#39;])

        # monthStartsOn
        if sel_freq == &#39;monthly&#39;:
            if daystartson is not None:
                day_starts = &#34;&#34;&#34; monthStartsOn=&#34;{0}&#34; &#34;&#34;&#34;.format(daystartson)
            else:
                day_starts = &#34;&#34;&#34; monthStartsOn=&#34;{}&#34; &#34;&#34;&#34;.format(1)

        library_id = self._commcell_object.disk_libraries._libraries[library_name.lower()]
        request_xml = str(&#34;&#34;&#34;&lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                &lt;storagePolicyCopyInfo copyType=&#34;2&#34; isDefault=&#34;0&#34; isMirrorCopy=&#34;0&#34; isSnapCopy=&#34;0&#34; numberOfStreamsToCombine=&#34;1&#34;&gt;
                    &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                    &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                    &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                    &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;100&#34; retainBackupDataForDays=&#34;150&#34; /&gt;
                    &lt;startTime  timeValue = &#34;{7}&#34; /&gt;
                    &lt;selectiveCopyRules selectiveRule=&#34;{8}&#34; {10} &gt; {9} &lt;/selectiveCopyRules&gt; &#34;&#34;&#34; + copyflags +
                              &#34;&#34;&#34;&lt;/storagePolicyCopyInfo&gt;
                          &lt;/App_CreateStoragePolicyCopyReq&gt;&#34;&#34;&#34;).format(copy_name, self.storage_policy_id,
                                                                       self.storage_policy_name,
                                                                       library_id, library_name, media_agent_id,
                                                                       media_agent_name, backups_from,
                                                                       selective_rule, dsostr, day_starts)
        create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, create_copy_service, request_xml)

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = &#34;Failed to create {0} Storage Policy copy with error \
                            {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                        else:
                            error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                                copy_name
                            )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def copies(self):
        &#34;&#34;&#34;Treats the storage policy copies as a read-only attribute&#34;&#34;&#34;
        return self._copies

    @property
    def storage_policy_id(self):
        &#34;&#34;&#34;Treats the storage policy id as a read-only attribute.&#34;&#34;&#34;
        return self._storage_policy_id

    @property
    def name(self):
        &#34;&#34;&#34;Returns the Storage Policy display name&#34;&#34;&#34;
        return self._storage_policy_properties[&#39;storagePolicy&#39;][&#39;storagePolicyName&#39;]

    @property
    def storage_policy_name(self):
        &#34;&#34;&#34;Treats the storage policy name as a read-only attribute.&#34;&#34;&#34;
        return self._storage_policy_name

    @property
    def description(self):
        &#34;&#34;&#34;Returns the Storage Policy Description Field&#34;&#34;&#34;
        if self._storage_policy_advanced_properties is None:
            self._storage_policy_advanced_properties = self._get_storage_policy_advanced_properties()
        return self._storage_policy_advanced_properties.get(&#39;policies&#39;,[{}])[0].get(&#39;description&#39;)

    def get_copy_precedence(self, copy_name):
        &#34;&#34;&#34; returns the copy precedence value associated with the copy name

            Args:
                copy_name           (str)   --  Storage copy name

            Returns:
                copy_precedence     (int)   --  Copy precedence number of
                storage copy

            Raises:
                Exception:
                    if unable to find the given copy name

        &#34;&#34;&#34;
        policy_copies = self.copies
        if policy_copies.get(copy_name):
            if policy_copies[copy_name].get(&#39;copyPrecedence&#39;):
                return policy_copies[copy_name][&#39;copyPrecedence&#39;]
        raise SDKException(
            &#39;Storage&#39;,
            &#39;102&#39;,
            &#39;Failed to get copy precedence from policy&#39;)

    def update_snapshot_options(self, **options):
        &#34;&#34;&#34;
        Method for Updating Storage Policy Snapshot Options like Backup Copy and Snapshot Catalog

        Args:
            Available Snapshot Options:

            enable_backup_copy               (bool)   --  Enables backup copy if the value is True

            source_copy_for_snap_to_tape     (str)    --  Source Copy name for backup copy

            enable_snapshot_catalog          (bool)   --  Enables Snapshot Catalog if value is True

            source_copy_for_snapshot_catalog (str)    --  Source Copy name for Snapshot Catalog

            is_ocum                          (bool)   --  True if Storage policy is enabled with
                                                          ocum server
            enable_selective_copy                 (int)   -- Enable selective copy option based on input value

            disassociate_sc_from_backup_copy    (bool)    -- Associate/Disassociate subclient from backup copy
                                                                True: Disassociate subclient
                                                                False: Associate subclient

        &#34;&#34;&#34;
        enable_backup_copy = options[&#39;enable_backup_copy&#39;]
        enable_snapshot_catalog = options[&#39;enable_snapshot_catalog&#39;]

        if options[&#39;is_ocum&#39;]:
            if enable_backup_copy and enable_snapshot_catalog:
                defferred_catalog_value = backup_copy_value = 16
            else:
                defferred_catalog_value = backup_copy_value = 3
        else:
            if enable_backup_copy:
                defferred_catalog_value = 16
                backup_copy_value = 3
            else:
                defferred_catalog_value = backup_copy_value = 3

        if options[&#39;source_copy_for_snap_to_tape&#39;] is not None:
            source_copy_for_snap_to_tape_id = self._copies[options[&#39;source_copy_for_snap_to_tape&#39;].lower()][&#39;copyId&#39;]
        else:
            source_copy_for_snap_to_tape_id = 0
        if options[&#39;source_copy_for_snapshot_catalog&#39;] is not None:
            source_copy_for_snapshot_catalog_id = self._copies[options[&#39;source_copy_for_snapshot_catalog&#39;].lower(
            )][&#39;copyId&#39;]
        else:
            source_copy_for_snapshot_catalog_id = 0

        selective_type = options.get(&#39;enable_selective_copy&#39;, 0)

        update_snapshot_tab_service = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

        if options[&#39;disassociate_sc_from_backup_copy&#39;] == True:
            disass_sc_xml = f&#34;&#34;&#34;
                               &lt;archGroupToAppListWithExclude _type_=&#34;2&#34;&gt;
                                    &lt;flags include=&#34;1&#34;/&gt;
                               &lt;/archGroupToAppListWithExclude&gt;
                               &lt;archGroupToAppListWithExclude _type_=&#34;27&#34;&gt;
                                    &lt;flags include=&#34;1&#34;/&gt;
                               &lt;/archGroupToAppListWithExclude&gt;
                           &lt;archGroupToAppListWithExclude _type_=&#34;7&#34; 
                           appName=&#34;{options[&#39;appName&#39;]}&#34; applicationId=&#34;{options[&#39;applicationId&#39;]}&#34;
                                backupsetId=&#34;{options[&#39;backupsetId&#39;]}&#34; backupsetName=&#34;{options[&#39;backupsetName&#39;]}&#34; 
                                clientId=&#34;{options[&#39;clientId&#39;]}&#34; clientName=&#34;{options[&#39;clientName&#39;]}&#34; instanceId=&#34;1&#34; 
                                instanceName=&#34;DefaultInstanceName&#34; 
                                subclientId=&#34;{options[&#39;subclientId&#39;]}&#34; subclientName=&#34;{options[&#39;subclientName&#39;]}&#34;&gt;
                                &lt;flags exclude=&#34;1&#34;/&gt;
                           &lt;/archGroupToAppListWithExclude&gt;&#34;&#34;&#34;

            request_xml = f&#34;&#34;&#34;
                        &lt;EVGui_SetSnapOpPropsReq deferredCatalogOperation=&#34;{defferred_catalog_value}&#34; snapshotToTapeOperation=&#34;{backup_copy_value}&#34;&gt;
                            &lt;header localeId=&#34;0&#34; userId=&#34;0&#34; /&gt;
                            &lt;snapshotToTapeProps archGroupId=&#34;{self.storage_policy_id}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                enable=&#34;{int(enable_backup_copy)}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                sourceCopyId=&#34;{source_copy_for_snap_to_tape_id}&#34; startTime=&#34;0&#34; type=&#34;{selective_type}&#34; &gt; &#34;&#34;&#34;.format(
                                    defferred_catalog_value,
                                    backup_copy_value,
                                    self.storage_policy_id,
                                    int(enable_backup_copy),
                                    source_copy_for_snap_to_tape_id, selective_type) + \
                          f&#34;&#34;&#34;{disass_sc_xml}
                            &lt;/snapshotToTapeProps&gt;                           
                        &lt;/EVGui_SetSnapOpPropsReq&gt;
                           &#34;&#34;&#34;

        elif options[&#39;disassociate_sc_from_backup_copy&#39;] == False:
            disass_sc_xml = f&#34;&#34;&#34;
                            &lt;archGroupToAppListWithExclude _type_=&#34;2&#34;&gt;
                                            &lt;flags include=&#34;1&#34;/&gt;
                                           &lt;/archGroupToAppListWithExclude&gt;
                                           &lt;archGroupToAppListWithExclude _type_=&#34;27&#34;&gt;
                                            &lt;flags include=&#34;1&#34;/&gt;
                                           &lt;/archGroupToAppListWithExclude&gt;&#34;&#34;&#34;

            request_xml = &#34;&#34;&#34;
                        &lt;EVGui_SetSnapOpPropsReq deferredCatalogOperation=&#34;{0}&#34; snapshotToTapeOperation=&#34;{1}&#34;&gt;
                                           &lt;header localeId=&#34;0&#34; userId=&#34;0&#34; /&gt;
                                           &lt;snapshotToTapeProps archGroupId=&#34;{2}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                               enable=&#34;{3}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                               sourceCopyId=&#34;{4}&#34; startTime=&#34;0&#34; type=&#34;{5}&#34; &gt; &#34;&#34;&#34;.format(
                        defferred_catalog_value,
                        backup_copy_value, self.storage_policy_id,
                        int(enable_backup_copy), source_copy_for_snap_to_tape_id, selective_type) + \
                        f&#34;&#34;&#34;{disass_sc_xml}
                                        &lt;/snapshotToTapeProps&gt;                                                                    
                                    &lt;/EVGui_SetSnapOpPropsReq&gt;
                           &#34;&#34;&#34;
        elif options[&#39;disassociate_sc_from_backup_copy&#39;] is None:
            request_xml = &#34;&#34;&#34;
                        &lt;EVGui_SetSnapOpPropsReq deferredCatalogOperation=&#34;{0}&#34; snapshotToTapeOperation=&#34;{1}&#34;&gt;
                                               &lt;header localeId=&#34;0&#34; userId=&#34;0&#34; /&gt;
                                               &lt;snapshotToTapeProps archGroupId=&#34;{2}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                                   enable=&#34;{3}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                                   sourceCopyId=&#34;{4}&#34; startTime=&#34;0&#34; type=&#34;{7}&#34; /&gt;
                                               &lt;deferredCatalogProps archGroupId=&#34;{2}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                                   enable=&#34;{5}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                                   sourceCopyId=&#34;{6}&#34; startTime=&#34;0&#34; type=&#34;0&#34; /&gt;
                                           &lt;/EVGui_SetSnapOpPropsReq&gt;
                               &#34;&#34;&#34;.format(defferred_catalog_value, backup_copy_value, self.storage_policy_id,
                                          int(enable_backup_copy), source_copy_for_snap_to_tape_id,
                                          int(enable_snapshot_catalog), source_copy_for_snapshot_catalog_id,
                                          selective_type)


        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, update_snapshot_tab_service, request_xml
        )

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 1:
                        error_message = &#34;Failed to Update {0} Storage Policy&#34;.format(
                            self.storage_policy_name
                        )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def run_backup_copy(self):
        &#34;&#34;&#34;
        Runs the backup copy from Commcell for the given storage policy

        Args:
                None

        Returns:
                object - instance of the Job class for this backup copy job
        Raises:
            SDKException:

                    if backup copy job failed

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        request_json = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ],
                &#34;task&#34;: {
                    &#34;initiatedFrom&#34;: 2,
                    &#34;taskType&#34;: 1,
                    &#34;policyType&#34;: 3,
                    &#34;taskFlags&#34;: {
                        &#34;disabled&#34;: False
                    }
                },
                &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1,
                        &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1,
                            &#34;operationType&#34;: 4028
                        },
                        &#34;options&#34;: {
                            &#34;adminOpts&#34;: {
                                &#34;snapToTapeOption&#34;: {
                                    &#34;allowMaximum&#34;: True,
                                    &#34;noofJobsToRun&#34;: 1
                                }
                            }
                        }
                    }
                ]
            }
        }

        backup_copy = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, backup_copy, request_json)

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;Backup copy job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;106&#39;, o_str)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;106&#39;, &#39;Failed to run the backup copy job&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;106&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def modify_dynamic_stream_allocation(self, enable=True):
        &#34;&#34;&#34;
        Modifies the DSA option for the Storage Policy
            Args:

                    enable      (bool)  --   False - Disable DSA
                                             True - Enable DSA
        &#34;&#34;&#34;
        request_xml = &#39;&#39;&#39;&lt;App_UpdateStoragePolicyReq&gt;
                       &lt;StoragePolicy&gt;
                           &lt;storagePolicyName&gt;{0}&lt;/storagePolicyName&gt;
                       &lt;/StoragePolicy&gt;
                       &lt;flag&gt;
                           &lt;distributeDataEvenlyAmongStreams&gt;{1}&lt;/distributeDataEvenlyAmongStreams&gt;
                       &lt;/flag&gt;
                       &lt;/App_UpdateStoragePolicyReq&gt;
                       &#39;&#39;&#39;.format(self.storage_policy_name, int(enable))
        self._commcell_object.qoperation_execute(request_xml)

    def run_snapshot_cataloging(self):
        &#34;&#34;&#34;
        Runs the deferred catalog job from Commcell for the given storage policy

        Args:
                None

        Returns:
                object - instance of the Job class for this snapshot cataloging job

        Raises:
            SDKException:

                    if snapshot cataloging job failed

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;

        request_json = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ],
                &#34;task&#34;: {
                    &#34;taskType&#34;: 1,
                    &#34;initiatedFrom&#34;: 2,
                    &#34;policyType&#34;: 0,
                    &#34;taskFlags&#34;: {
                        &#34;isEdgeDrive&#34;: False,
                        &#34;disabled&#34;: False
                    }
                },
                &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1,
                        &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1,
                            &#34;operationType&#34;: 4043
                        },
                        &#34;options&#34;: {
                            &#34;backupOpts&#34;: {
                                &#34;backupLevel&#34;: 2,
                                &#34;dataOpt&#34;: {
                                    &#34;useCatalogServer&#34;: True,
                                    &#34;enforceTransactionLogUsage&#34;: False
                                }
                            }
                        }
                    }
                ]
            }
        }

        snapshot_catalog = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, snapshot_catalog, request_json)

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;Deferred catalog job failed\nError: &#34;{0}&#34;&#39;.format(
                        error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;107&#39;, o_str)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;107&#39;, &#39;Failed to run the deferred catalog job&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;107&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def storage_policy_properties(self):
        &#34;&#34;&#34;Returns the storage policy properties

            dict - consists of storage policy properties
        &#34;&#34;&#34;
        return self._storage_policy_properties

    @property
    def storage_policy_advanced_properties(self):
        &#34;&#34;&#34;Returns the  storage policy advanced properties

            dict - consists of storage policy advanced properties
        &#34;&#34;&#34;
        if self._storage_policy_advanced_properties is None:
            self._storage_policy_advanced_properties = self._get_storage_policy_advanced_properties()
        return self._storage_policy_advanced_properties

    @property
    def library_name(self):
        &#34;&#34;&#34;Treats the library name as a read-only attribute.&#34;&#34;&#34;
        primary_copy = self._storage_policy_properties.get(&#39;copy&#39;)
        if &#39;library&#39; in primary_copy[0]:
            library = primary_copy[0].get(&#39;library&#39;, {})
            return library.get(&#39;libraryName&#39;)

    @property
    def library_id(self):
        &#34;&#34;&#34;Treats the library id as a read-only attribute.&#34;&#34;&#34;
        primary_copy = self._storage_policy_properties.get(&#39;copy&#39;)
        if &#39;library&#39; in primary_copy[0]:
            library = primary_copy[0].get(&#39;library&#39;, {})
            return library.get(&#39;libraryId&#39;)

    @property
    def aux_copies(self):
        &#34;&#34;&#34;
        Returns the list of all aux copies in the policy
        Returns:
            list - list of all aux copies in the storage policy
        &#34;&#34;&#34;
        aux_copies = []
        for _copy, value in self.copies.items():
            if not value[&#39;isSnapCopy&#39;] and _copy != &#39;primary&#39;:
                aux_copies.append(_copy)
        return aux_copies

    @property
    def snap_copy(self):
        &#34;&#34;&#34;
        Returns the name of the snap copy
        Returns:
            str - name of the snap copy
        &#34;&#34;&#34;
        snap_copy = None
        for _copy, value in self.copies.items():
            if value[&#39;isSnapCopy&#39;]:
                snap_copy = _copy
        return snap_copy

    def run_aux_copy(self, storage_policy_copy_name=None,
                     media_agent=None, use_scale=True, streams=0,
                     all_copies=True, total_jobs_to_process=1000, schedule_pattern=None, **kwargs):
        &#34;&#34;&#34;Runs the aux copy job from the commcell.
            Args:

                storage_policy_copy_name (str)  --  name of the storage policy copy

                media_agent              (str)  --  name of the media agent

                use_scale                (bool) --  use Scalable Resource Management (True/False)

                streams                  (int)  --  number of streams to use

                all_copies               (bool) -- run auxcopy job on all copies or select copy
                                                   (True/False)

                total_jobs_to_process    (int)  -- Total number jobs to process for the auxcopy job

                **kwargs    --  dict of keyword arguments as follows:
                ignore_dv_failed_jobs  (bool)  -- Ignore DV failed jobs
                job_description     (str)      -- Description for Job

            Returns:
                object - instance of the Job class for this aux copy job

            Raises:
                SDKException:
                    if type of the  argument is not string

                    if aux copy job failed

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(total_jobs_to_process, int) and
                isinstance(streams, int)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        use_max_streams = True
        if streams != 0:
            use_max_streams = False

        if storage_policy_copy_name is not None:
            all_copies = False
            if not media_agent:
                media_agent = &#34;&amp;lt;ANY MEDIAAGENT&amp;gt;&#34;
            if not (isinstance(storage_policy_copy_name, str) and
                    isinstance(media_agent, str)):
                raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        else:
            if all_copies is False:
                raise SDKException(&#39;Storage&#39;, &#39;110&#39;)
            storage_policy_copy_name = &#34;&#34;
            media_agent = &#34;&#34;

        ignore_dv_failed_jobs = False
        if kwargs.get(&#39;ignore_dv_failed_jobs&#39;) is True:
            ignore_dv_failed_jobs = True

        request_json = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;copyName&#34;: storage_policy_copy_name,
                        &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ],
                &#34;task&#34;: {
                    &#34;initiatedFrom&#34;: 2,
                    &#34;taskType&#34;: 1,
                    &#34;policyType&#34;: 0,
                    &#34;taskFlags&#34;: {
                        &#34;disabled&#34;: False
                    }
                },
                &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1,
                        &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1,
                            &#34;operationType&#34;: 4003
                        },
                        &#34;options&#34;: {
                            &#34;backupOpts&#34;: {
                                &#34;mediaOpt&#34;: {
                                    &#34;auxcopyJobOption&#34;: {
                                        &#34;maxNumberOfStreams&#34;: streams,
                                        &#34;useMaximumStreams&#34;: use_max_streams,
                                        &#34;useScallableResourceManagement&#34;: use_scale,
                                        &#34;totalJobsToProcess&#34;: total_jobs_to_process,
                                        &#34;ignoreDataVerificationFailedJobs&#34;: ignore_dv_failed_jobs,
                                        &#34;allCopies&#34;: all_copies,
                                        &#34;mediaAgent&#34;: {
                                            &#34;mediaAgentName&#34;: media_agent
                                        }
                                    }
                                }
                            },
                            &#34;commonOpts&#34;: {
                                &#34;jobDescription&#34;: kwargs.get(&#39;job_description&#39;, &#39;&#39;)
                            }
                        }
                    }
                ]
            }
        }

        if schedule_pattern:
            request_json = SchedulePattern().create_schedule(request_json, schedule_pattern)

        aux_copy = self._commcell_object._services[&#39;CREATE_TASK&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, aux_copy, request_json
        )

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;Restore job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)

                elif &#34;taskId&#34; in response.json():
                    return Schedules(self._commcell_object).get(task_id=response.json()[&#39;taskId&#39;])

                else:
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, &#39;Failed to run the aux copy job&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)

        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def refresh(self):
        &#34;&#34;&#34;Refresh the properties of the StoragePolicy.&#34;&#34;&#34;
        self._initialize_storage_policy_properties()
        self._storage_policy_advanced_properties = None

    def seal_ddb(self, copy_name):
        &#34;&#34;&#34;
        Seals the deduplication database

            Args:
                copy_name   (str)   --  name of the storage policy copy

            Raises:
                SDKException:
                    if type of input parameters is not string
        &#34;&#34;&#34;
        if not isinstance(copy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_xml = &#34;&#34;&#34;
        &lt;App_SealSIDBStoreReq&gt;
            &lt;archiveGroupCopy&gt;
                &lt;copyName&gt;{0}&lt;/copyName&gt;
                &lt;storagePolicyName&gt;{1}&lt;/storagePolicyName&gt;
            &lt;/archiveGroupCopy&gt;
        &lt;/App_SealSIDBStoreReq&gt;

        &#34;&#34;&#34;.format(copy_name, self.storage_policy_name)
        self._commcell_object._qoperation_execute(request_xml)

    def update_transactional_ddb(self, update_value, copy_name, media_agent_name):
        &#34;&#34;&#34;
        Updates TransactionalDDB option on the deduplication database

            Args:
                update_value    (bool)   --   enable(True)/disable(False)

                copy_name       (str)   --   name of the associated copy

                media_agent_name(str)   --   name of the media agent

            Raises:
                SDKException:
                    if type of input parameters is not string
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and isinstance(media_agent_name, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_xml = &#34;&#34;&#34;
        &lt;App_UpdateStoragePolicyCopyReq &gt;
            &lt;storagePolicyCopyInfo &gt;
                &lt;StoragePolicyCopy&gt;
                    &lt;copyName&gt;{0}&lt;/copyName&gt;
                    &lt;storagePolicyName&gt;{1}&lt;/storagePolicyName&gt;
                &lt;/StoragePolicyCopy&gt;
                &lt;DDBPartitionInfo&gt;
                    &lt;maInfoList&gt;
                        &lt;mediaAgent&gt;
                            &lt;mediaAgentName&gt;{2}&lt;/mediaAgentName&gt;
                        &lt;/mediaAgent&gt;
                            &lt;/maInfoList&gt;
                            &lt;sidbStoreInfo&gt;
                                &lt;sidbStoreFlags&gt;
                            &lt;enableTransactionalDDB&gt;{3}&lt;/enableTransactionalDDB&gt;
                        &lt;/sidbStoreFlags&gt;
                            &lt;/sidbStoreInfo&gt;
                    &lt;/DDBPartitionInfo&gt;
           &lt;/storagePolicyCopyInfo&gt;
        &lt;/App_UpdateStoragePolicyCopyReq&gt;
        &#34;&#34;&#34;.format(copy_name, self.storage_policy_name, media_agent_name, int(update_value))

        self._commcell_object._qoperation_execute(request_xml)

    def create_dedupe_secondary_copy(self, copy_name, library_name,
                                     media_agent_name, path, ddb_media_agent,
                                     dash_full=None,
                                     source_side_disk_cache=None,
                                     software_compression=None):
        &#34;&#34;&#34;Creates Synchronous copy for this storage policy

            Args:
                copy_name               (str)   --  copy name to create

                library_name            (str)   --  library name to be assigned

                media_agent_name        (str)   --  media_agent to be assigned

                path                    (str)   --  path where deduplication store is to be hosted

                ddb_media_agent         (str)   --  media agent name on which deduplication store
                                                    is to be hosted

                dash_full               (bool)  --  enable DASH full on deduplication store (True/False)
                Default None

                source_side_disk_cache  (bool)  -- enable source side disk cache (True/False)
                Default None

                software_compression    (bool)  -- enable software compression (True/False)
                Default None

            Raises:
                SDKException:
                    if type of inputs in not string

                    if copy with given name already exists

                    if failed to create copy

                    if response received is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and
                isinstance(library_name, str) and
                isinstance(path, str) and
                isinstance(ddb_media_agent, str) and
                isinstance(media_agent_name, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if dash_full is None:
            dash_full = &#34;2&#34;
        if source_side_disk_cache is None:
            source_side_disk_cache = &#34;2&#34;
        if software_compression is None:
            software_compression = &#34;2&#34;

        if self.has_copy(copy_name):
            err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        library_id = self._commcell_object.disk_libraries.get(library_name).library_id
        media_agent_id = self._commcell_object.media_agents._media_agents[media_agent_name][&#39;id&#39;]

        request_xml = &#34;&#34;&#34;
        &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
            &lt;storagePolicyCopyInfo copyType=&#34;0&#34; isDefault=&#34;0&#34;&gt;
                &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                &lt;copyFlags auxCopyReencryptData=&#34;0&#34; /&gt;
                &lt;dedupeFlags enableDeduplication=&#34;1&#34; enableDASHFull=&#34;{9}&#34; enableSourceSideDiskCache=&#34;{10}&#34;/&gt;
                &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;1&#34; retainBackupDataForDays=&#34;30&#34; /&gt;
                &lt;DDBPartitionInfo&gt;
                    &lt;maInfoList&gt;
                        &lt;mediaAgent mediaAgentName=&#34;{8}&#34;/&gt;
                        &lt;subStoreList&gt;
                            &lt;diskFreeThresholdMB&gt;5120&lt;/diskFreeThresholdMB&gt;
                            &lt;diskFreeWarningThreshholdMB&gt;10240&lt;/diskFreeWarningThreshholdMB&gt;
                            &lt;accessPath path=&#34;{7}&#34;/&gt;
                        &lt;/subStoreList&gt;
                    &lt;/maInfoList&gt;
                    &lt;sidbStoreInfo&gt;
                        &lt;operation&gt;1&lt;/operation&gt;
                        &lt;copyName&gt;{0}&lt;/copyName&gt;
                        &lt;sidbStoreFlags enableSoftwareCompression=&#34;{11}&#34;/&gt;
                    &lt;/sidbStoreInfo&gt;
                &lt;/DDBPartitionInfo&gt;

            &lt;/storagePolicyCopyInfo&gt;
        &lt;/App_CreateStoragePolicyCopyReq&gt;
        &#34;&#34;&#34;.format(copy_name, self._storage_policy_id, self.storage_policy_name,
                   library_id, library_name, media_agent_id, media_agent_name,
                   path, ddb_media_agent, int(dash_full),
                   int(source_side_disk_cache), int(software_compression))

        create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, create_copy_service, request_xml
        )

        self.refresh()

        if flag:
            if response.json():
                if &#39;error&#39; in response.json():
                    error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                            error_message = &#34;Failed to create {0} Storage Policy copy with error \
                            {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                        else:
                            error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                                copy_name
                            )

                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def run_ddb_verification(self,
                             copy_name,
                             ver_type,
                             ddb_ver_level,
                             use_scalable=True,
                             orphan_chunk_listing=False):
        &#34;&#34;&#34;
        Runs DDB verification job

            Args:
                copy_name       (str)   --  name of the copy which is associated with the DDB store

                ver_type        (str)   --  backup level (Full/Incremental)

                ddb_ver_level   (str)   --  DDB verification type
                                            (DDB_VERIFICATION/ DDB_AND_DATA_VERIFICATION /
                                            QUICK_DDB_VERIFICATION/ DDB_DEFRAGMENTATION)

                use_scalable    (bool)  --  True/False to use Scalable Resource Allocation
                                            Default: True

                orphan_chunk_listing (bool) --  True/False to run orphan chunk listing phase during DDB Defragmentation

            Returns:
                object - instance of the Job class for this DDB verification job

            Raises:
                SDKException:
                    if type of input parameters is not string

                    if job failed

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and
                isinstance(ver_type, str) and
                isinstance(ddb_ver_level, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        run_defrag = False
        if ddb_ver_level == &#39;DDB_DEFRAGMENTATION&#39;:
            run_defrag = True
        request = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;copyName&#34;: copy_name, &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ], &#34;task&#34;: {
                    &#34;taskType&#34;: 1,
                    &#34;initiatedFrom&#34;: 1,
                    &#34;policyType&#34;: 0,
                    &#34;taskId&#34;: 0,
                    &#34;taskFlags&#34;: {
                        &#34;disabled&#34;: False
                    }
                }, &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1, &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1, &#34;operationType&#34;: 4007
                        },
                        &#34;options&#34;: {
                            &#34;backupOpts&#34;: {
                                &#34;mediaOpt&#34;: {
                                    &#34;auxcopyJobOption&#34;: {
                                        &#34;maxNumberOfStreams&#34;: 0,
                                        &#34;allCopies&#34;: True,
                                        &#34;useMaximumStreams&#34;: True,
                                        &#34;useScallableResourceManagement&#34;: use_scalable,
                                        &#34;mediaAgent&#34;: {
                                            &#34;mediaAgentName&#34;: &#34;&#34;
                                        }
                                    }
                                }
                            }, &#34;adminOpts&#34;: {
                                &#34;archiveCheckOption&#34;: {
                                    &#34;ddbVerificationLevel&#34;: ddb_ver_level,
                                    &#34;jobsToVerify&#34;: 0,
                                    &#34;allCopies&#34;: True,
                                    &#34;backupLevel&#34;: ver_type,
                                    &#34;ocl&#34;: orphan_chunk_listing,
                                    &#34;runDefrag&#34;: run_defrag
                                }
                            }
                        }
                    }
                ]
            }
        }
        data_verf = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, data_verf, request
        )

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;DDB verification job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;109&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def run_data_verification(self, media_agent_name=&#39;&#39;, copy_name=&#39;&#39;, streams=0,
                              jobs_to_verify=&#39;NEW&#39;, use_scalable=True, schedule_pattern=None, **kwargs):
        &#34;&#34;&#34;Runs Data verification job

        Args:
            media_agent_name    (str)  : name of the mediaAgent to use for data reading

            copy_name           (str)  : name of Copy
                                         (default - verifies jobs on all copies)

            streams             (int)  : number of streams to use
                                         (default - use Maximum)

            jobs_to_verify      (str)  : jobs to be Verified
                                         (NEW/ VERF_EXPIRED/ ALL)

            use_scalable       (bool) : True/False to use Scalable Resource Allocation
                                         (default - True)

            kwargs              (dict) : optional arguments
                Available kwargs Options:
                    job_description     (str): Description for Job

        Returns:
            object - instance of the Job class for this Data Verification Job

            errorMessage - If Data Verification Job fails to Start
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and isinstance(jobs_to_verify, str)
                and isinstance(media_agent_name, str) and isinstance(streams, int)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if jobs_to_verify.upper() == &#39;NEW&#39;:
            jobs_to_verify = &#39;NEWLY_AVAILABLE&#39;
        elif jobs_to_verify.upper() == &#39;VERF_EXPIRED&#39;:
            jobs_to_verify = &#39;VERIFICATION_EXP&#39;
        elif jobs_to_verify.upper() == &#39;ALL&#39;:
            jobs_to_verify = &#39;BOTH_NEWLY_AVAILABLE_AND_VERIFICATION_EXP&#39;

        request = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;copyName&#34;: copy_name,
                        &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ],
                &#34;task&#34;: {},
                &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1,
                        &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1,
                            &#34;operationType&#34;: 4007
                        },
                        &#34;options&#34;: {
                            &#34;backupOpts&#34;: {
                                &#34;mediaOpt&#34;: {
                                    &#34;auxcopyJobOption&#34;: {
                                        &#34;maxNumberOfStreams&#34;: streams,
                                        &#34;useMaximumStreams&#34;: not bool(streams),
                                        &#34;useScallableResourceManagement&#34;: use_scalable,
                                        &#34;mediaAgent&#34;: {
                                            &#34;mediaAgentName&#34;: media_agent_name
                                        }
                                    }
                                }
                            },
                            &#34;adminOpts&#34;: {
                                &#34;archiveCheckOption&#34;: {
                                    &#34;jobsToVerify&#34;: jobs_to_verify,
                                }
                            },
                            &#34;commonOpts&#34;: {
                                &#34;jobDescription&#34;: kwargs.get(&#39;job_description&#39;,&#39;&#39;)
                            }
                        }
                    }
                ]
            }
        }

        if schedule_pattern:
            request[&#34;taskInfo&#34;][&#34;task&#34;] = {&#34;taskType&#34;: 2}
            request = SchedulePattern().create_schedule(request, schedule_pattern)

        data_verf = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, data_verf, request
        )
        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]
                    o_str = &#39;Data verification Request failed. Error: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
                elif &#34;taskId&#34; in response.json():
                    return Schedules(self._commcell_object).get(task_id=response.json()[&#39;taskId&#39;])
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;109&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def move_dedupe_store(self,
                          copy_name,
                          dest_path,
                          src_path,
                          dest_media_agent,
                          src_media_agent,
                          config_only=False):
        &#34;&#34;&#34;
        Moves a deduplication store

            Args:
                copy_name               (str)   -- name of the storage policy copy

                dest_path:              (str)   -- path where new partition is to be hosted

                src_path:               (str)   -- path where existing partition is hosted

                dest_media_agent:       (str)   -- media agent name where new partition is to be hosted

                src_media_agent:        (str)   -- media agent name where existing partition is hosted

                config_only             (bool)  -- to only chnage in DB (files need to be moved manually) (True/False)
                Default : False

            Returns:
                object - object - instance of the Job class for this DDB move job

            Raises:
                SDKException:
                    if type of input parameters is not string

                    if job failed

                    if response is empty

                    if response is not success
        &#34;&#34;&#34;
        if not (isinstance(copy_name, str) and
                isinstance(dest_path, str) and
                isinstance(src_path, str) and
                isinstance(dest_media_agent, str) and
                isinstance(src_media_agent, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request = {
            &#34;taskInfo&#34;: {
                &#34;associations&#34;: [
                    {
                        &#34;copyName&#34;: copy_name, &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                ], &#34;task&#34;: {
                    &#34;taskType&#34;: 1,
                    &#34;initiatedFrom&#34;: 1,
                    &#34;policyType&#34;: 0,
                    &#34;taskId&#34;: 0,
                    &#34;taskFlags&#34;: {
                        &#34;disabled&#34;: False
                    }
                }, &#34;subTasks&#34;: [
                    {
                        &#34;subTaskOperation&#34;: 1, &#34;subTask&#34;: {
                            &#34;subTaskType&#34;: 1, &#34;operationType&#34;: 5013
                        }, &#34;options&#34;: {
                            &#34;adminOpts&#34;: {
                                &#34;libraryOption&#34;: {
                                    &#34;operation&#34;: 20, &#34;ddbMoveOption&#34;: {
                                        &#34;flags&#34;: 2, &#34;subStoreList&#34;: [
                                            {
                                                    &#34;srcPath&#34;: src_path,
                                                    &#34;changeOnlyDB&#34;: config_only,
                                                    &#34;destPath&#34;: dest_path,
                                                    &#34;destMediaAgent&#34;: {
                                                        &#34;name&#34;: dest_media_agent
                                                    }, &#34;srcMediaAgent&#34;: {
                                                        &#34;name&#34;: src_media_agent
                                                    }
                                            }
                                        ]
                                    }
                                }
                            }
                        }
                    }
                ]
            }
        }
        ddb_move = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, ddb_move, request
        )

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;DDB move job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;108&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def add_ddb_partition(self,
                          copy_id,
                          sidb_store_id,
                          sidb_new_path,
                          media_agent):
        &#34;&#34;&#34;
        Adds a new DDB partition
            Args:
                copy_id         (str)   -- storage policy copy id

                sidb_store_id   (str)   -- deduplication store id

                sidb_new_path   (str)   -- path where new partition is to be hosted

                media_agent     (str)   -- media agent on which new partition is to be hosted

            Raises:
                SDKException:
                    if type of input parameters is not string
        &#34;&#34;&#34;
        if not (isinstance(copy_id, str) and
                isinstance(sidb_store_id, str) and
                isinstance(sidb_new_path, str) and
                isinstance(media_agent, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if isinstance(media_agent, MediaAgent):
            media_agent = media_agent
        elif isinstance(media_agent, str):
            media_agent = MediaAgent(self._commcell_object, media_agent)

        request_xml = &#34;&#34;&#34;
        &lt;EVGui_ParallelDedupConfigReq commCellId=&#34;2&#34; copyId=&#34;{0}&#34; operation=&#34;15&#34;&gt;
        &lt;SIDBStore SIDBStoreId=&#34;{1}&#34;/&gt;
        &lt;dedupconfigItem commCellId=&#34;0&#34;&gt;
        &lt;maInfoList&gt;&lt;clientInfo id=&#34;{2}&#34; name=&#34;{3}&#34;/&gt;
        &lt;subStoreList&gt;&lt;accessPath path=&#34;{4}&#34;/&gt;
        &lt;/subStoreList&gt;&lt;/maInfoList&gt;&lt;/dedupconfigItem&gt;
        &lt;/EVGui_ParallelDedupConfigReq&gt;

        &#34;&#34;&#34;.format(copy_id, sidb_store_id, media_agent.media_agent_id,
                   media_agent.media_agent_name, sidb_new_path)
        self._commcell_object._qoperation_execute(request_xml)

    def get_copy(self, copy_name):
        &#34;&#34;&#34;Returns a storage policy copy object if copy exists

            Args:
               copy_name (str)  --  name of the storage policy copy

            Returns:
               object - instance of the StoragePolicyCopy class for the given copy name

            Raises:
               SDKException:
                   if type of the copy name argument is not string

                   if no copy exists with the given name
        &#34;&#34;&#34;
        if not isinstance(copy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if self.has_copy(copy_name):
            return StoragePolicyCopy(self._commcell_object, self.storage_policy_name, copy_name)
        else:
            raise SDKException(
                &#39;Storage&#39;, &#39;102&#39;, &#39;No copy exists with name: {0}&#39;.format(copy_name)
            )

    def get_primary_copy(self):
        &#34;&#34;&#34;Returns the primary copy of the storage policy

            Returns:
                object  -   Instance of the StoragePolicyCopy class of the primary copy

            Raises:
               SDKException:
                   if unable to find a primary copy in the storage policy

        &#34;&#34;&#34;

        for copy_name, copy_info in self.copies.items():
            if copy_info[&#39;isDefault&#39;]:
                return self.get_copy(copy_name)

        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, &#39;Unable to find a primary copy in the storage policy&#39;)

    def get_secondary_copies(self):
        &#34;&#34;&#34;Returns all the secondary copies in the storage policy sorted by copy precedence

            Returns:
                list    -   A list of storage policy copy instances.

        &#34;&#34;&#34;

        sorted_copies = sorted(self.copies.items(), key=lambda x: x[1][&#39;copyPrecedence&#39;])  # Sort by copy precedence
        result = []

        for copy_name, copy_info in sorted_copies:
            if not copy_info[&#39;isDefault&#39;] and not copy_info[&#39;isSnapCopy&#39;]:  # Skip primary copy and snap primary copies
                copy_obj = self.get_copy(copy_name)
                result.append(copy_obj)

        return result

    def delete_job(self, job_id, commcell_id=2):
        &#34;&#34;&#34;Deletes a job on Storage Policy

            Args:
                job_id          (str)   --  ID for the job to be deleted

                commcell_id     (str)   --  The commcell ID of the job to be deleted

            Raises:
                SDKException:
                    if type of input parameters is not string

        &#34;&#34;&#34;

        if not isinstance(job_id, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        job_list_tag = &#39;&#39;
        for copy_name, copy_info in self.copies.items():
            job_list_tag += f&#34;&#34;&#34;&lt;jobList appType=&#34;&#34; commCellId=&#34;{commcell_id}&#34; jobId=&#34;{job_id}&#34;&gt;
            &lt;copyInfo copyName=&#34;{copy_name}&#34; storagePolicyName=&#34;{self.storage_policy_name}&#34;/&gt;&lt;/jobList&gt;&#34;&#34;&#34;

        request_xml = f&#34;&#34;&#34;&lt;App_JobOperationCopyReq operationType=&#34;2&#34;&gt;{job_list_tag}
        &lt;commCellInfo commCellId=&#34;{commcell_id}&#34;/&gt;
        &lt;/App_JobOperationCopyReq&gt;
        &#34;&#34;&#34;

        self._commcell_object._qoperation_execute(request_xml)

    def mark_for_recovery(self, store_id, sub_store_id, media_agent_name, dedupe_path):
        &#34;&#34;&#34; Marks Deduplication store for recovery

            Args:
               store_id         (str)  --  SIDB store id

               sub_store_id     (str)  --  SIDB substore id

               media_agent_name (str)  --  name of the media agent on which DDB is hosted

               dedupe_path      (str)  --  SIDB store path
        &#34;&#34;&#34;

        request_xml = &#34;&#34;&#34;
                &lt;EVGui_IdxSIDBSubStoreOpReq&gt;&lt;info SIDBStoreId=&#34;{0}&#34; SubStoreId=&#34;{1}&#34; opType=&#34;1&#34; path=&#34;{3}&#34;&gt;
                &lt;mediaAgent name=&#34;{2}&#34;/&gt;
                &lt;/info&gt;
                &lt;/EVGui_IdxSIDBSubStoreOpReq&gt;
                &#34;&#34;&#34;.format(store_id, sub_store_id, media_agent_name, dedupe_path)
        self._commcell_object._qoperation_execute(request_xml)

    def run_recon(self, copy_name, sp_name, store_id, full_reconstruction=0, use_scalable_resource=&#39;false&#39;):
        &#34;&#34;&#34; Runs non-mem DB Reconstruction job

            Args:
               copy_name    (str)  --  name of the storage policy copy

               sp_name      (str)  --  name of the storage policy

               store_id     (str)  --  SIDB store id associated with the copy

               full_reconstruction      (int)  --  flag to enable full reconstruction job
                                                   Valid values:
                                                   0: to start regular reconstruction job
                                                   1: to start full reconstruction job

               use_scalable_resource    (str)  --  to enable scalable resources
                                                   Valid values:
                                                   &#39;true&#39;: to start old way reconstruction job
                                                   &#39;false&#39;: to start reconstruction job with scalable resources
        &#34;&#34;&#34;
        request_xml = &#34;&#34;&#34;
        &lt;TMMsg_DedupSyncTaskReq flags=&#34;0&#34;&gt;
            &lt;taskInfo&gt;&lt;associations _type_=&#34;0&#34; appName=&#34;&#34; applicationId=&#34;0&#34; backupsetId=&#34;0&#34; backupsetName=&#34;&#34;
            clientId=&#34;0&#34; clientName=&#34;&#34; clientSidePackage=&#34;1&#34; commCellId=&#34;0&#34; consumeLicense=&#34;1&#34; copyName=&#34;{0}&#34;
            instanceId=&#34;1&#34; instanceName=&#34;&#34; srmReportSet=&#34;0&#34; srmReportType=&#34;0&#34; storagePolicyName=&#34;{1}&#34;
            subclientId=&#34;0&#34; subclientName=&#34;&#34; type=&#34;0&#34;/&gt;
            &lt;subTasks&gt;
                &lt;options&gt;
                    &lt;adminOpts&gt;
                        &lt;contentIndexingOption subClientBasedAnalytics=&#34;0&#34;/&gt;
                        &lt;dedupDBSyncOption SIDBStoreId=&#34;{2}&#34;/&gt;
                        &lt;reconstructDedupDBOption allowMaximum=&#34;0&#34; flags=&#34;{4}&#34; noOfStreams=&#34;0&#34; useScallableResourceManagement=&#34;{3}&#34;&gt;
                        &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;0&#34; mediaAgentName=&#34;&amp;lt;ANY MEDIAAGENT&gt;&#34;/&gt;
                        &lt;/reconstructDedupDBOption&gt;
                    &lt;/adminOpts&gt;
                    &lt;restoreOptions&gt;
                        &lt;virtualServerRstOption isBlockLevelReplication=&#34;0&#34;/&gt;
                    &lt;/restoreOptions&gt;
                &lt;/options&gt;
                &lt;subTask operationType=&#34;4036&#34; subTaskType=&#34;1&#34;/&gt;
            &lt;/subTasks&gt;
            &lt;task initiatedFrom=&#34;1&#34; ownerId=&#34;1&#34; ownerName=&#34;admin&#34; policyType=&#34;0&#34; sequenceNumber=&#34;0&#34;
            taskId=&#34;0&#34; taskType=&#34;1&#34;&gt;&lt;taskFlags disabled=&#34;0&#34;/&gt;
            &lt;/task&gt;
            &lt;/taskInfo&gt;
        &lt;/TMMsg_DedupSyncTaskReq&gt;
        &#34;&#34;&#34;.format(copy_name, sp_name, store_id, use_scalable_resource, full_reconstruction)
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
        )

        if flag:
            if response.json():
                return response.json()

    def reassociate_all_subclients(self, dest_storage_policy_name=&#39;CV_DEFAULT&#39;):
        &#34;&#34;&#34;
        Reassociates all subclients associated to Storage Policy
        Args:
            dest_storage_policy_name(str):  Name of a Storage Policy to which the Subclients are to
                                            be reassociated.
                                            Default Value:
                                            &#39;CV_DEFAULT&#39;: &#39;Not Assigned&#39; to any Policy.
        Raises:
            SDKException    :   If failed to reassociate
        &#34;&#34;&#34;
        request_json = {
            &#34;App_ReassociateStoragePolicyReq&#34;: {
                &#34;forceNextBkpToFull&#34;: True,
                &#34;newStoragePolicy&#34;: {
                    &#34;storagePolicyName&#34;: dest_storage_policy_name
                },
                &#34;currentStoragePolicy&#34;: {
                    &#34;storagePolicyName&#34;: self.storage_policy_name
                }
            }
        }
        reassociate_subclients = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, reassociate_subclients, request_json
        )
        if flag:
            if response.json():
                if &#39;errorCode&#39; in response.json():
                    error_code = int(response.json()[&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to Reassociate the Subclients&#34;
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        self.refresh()

    def start_over(self):
        &#34;&#34;&#34;
        performs a start over operation on the specified storage policy/gdsp

            Args:

            Raises:
                  SDKException -- if response is bad/ flag is false

        returns None
        &#34;&#34;&#34;
        dependent_flag = self.storage_policy_properties[&#34;copy&#34;][0][&#34;dedupeFlags&#34;].get(&#34;useGlobalDedupStore&#34;, 0)
        if dependent_flag == 1:
            raise Exception(&#34;Dependent policy cannot be started over ...&#34;)

        request = {
            &#34;MediaManager_MMStartOverReq&#34;: {
                    &#34;bSealDDB&#34;: True,
                    &#34;storagePolicy&#34;: {
                        &#34;storagePolicyName&#34;: self.storage_policy_name
                    }
                }
            }

        startover = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, startover, request
        )

        if flag:
            if response.json():
                if &#39;errorCode&#39; in response.json():
                    error_code = int(response.json()[&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to Start Over&#34;
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
        self.refresh()

    def run_data_forecast(self, **kwargs):
        &#34;&#34;&#34;runs data forecast and retention report generation operation

            Args:

                **kwargs    --  dict of keyword arguments as follows:

                    localeName      str     localeName for report [defaults to &#34;en-us&#34;]

            Raises:
                  SDKException -- if response is bad/ flag is false

            Returns None
                &#34;&#34;&#34;
        request = {
                    &#34;processinginstructioninfo&#34;: {},
                    &#34;taskInfo&#34;: {
                        &#34;task&#34;: {
                            &#34;taskType&#34;: 1,
                            &#34;initiatedFrom&#34;: 2,
                            &#34;taskFlags&#34;: {
                                &#34;disabled&#34;: False
                            }
                        },
                        &#34;appGroup&#34;: {},
                        &#34;subTasks&#34;: [
                            {
                                &#34;subTaskOperation&#34;: 1,
                                &#34;subTask&#34;: {
                                    &#34;subTaskName&#34;: &#34;&#34;,
                                    &#34;subTaskType&#34;: 1,
                                    &#34;operationType&#34;: 4004
                                },
                                &#34;options&#34;: {
                                    &#34;adminOpts&#34;: {
                                        &#34;reportOption&#34;: {
                                            &#34;showHiddenStoragePolicies&#34;: False,
                                            &#34;showGlobalStoragePolicies&#34;: False,
                                            &#34;storagePolicyCopyList&#34;: [
                                                {
                                                    &#34;storagePolicyName&#34;: self.storage_policy_name
                                                }
                                            ],
                                            &#34;mediaInfoReport&#34;: {
                                                &#34;mediaLocIn&#34;: True,
                                                &#34;mediaLocOut&#34;: True
                                            },
                                            &#34;commonOpt&#34;: {
                                                &#34;dateFormat&#34;: &#34;mm/dd/yyyy&#34;,
                                                &#34;overrideDateTimeFormat&#34;: 0,
                                                &#34;reportType&#34;: 7738,
                                                &#34;summaryOnly&#34;: False,
                                                &#34;reportCustomName&#34;: &#34;&#34;,
                                                &#34;timeFormat&#34;: &#34;hh:mm:ss am/pm&#34;,
                                                &#34;onCS&#34;: True,
                                                &#34;locale&#34;: {
                                                    &#34;country&#34;: &#34;English&#34;,
                                                    &#34;language&#34;: &#34;UnitedStates&#34;,
                                                    &#34;localeName&#34;: kwargs.get(&#34;localeName&#34;, &#34;en-us&#34;)
                                                },
                                                &#34;outputFormat&#34;: {
                                                    &#34;outputType&#34;: 1,
                                                    &#34;isNetworkDrive&#34;: False
                                                }
                                            },
                                            &#34;computerSelectionList&#34;: {
                                                &#34;includeAll&#34;: True
                                            },
                                            &#34;jobSummaryReport&#34;: {
                                                &#34;subclientFilter&#34;: False
                                            },
                                            &#34;dataRetentionForecastReport&#34;: {
                                                &#34;pruneData&#34;: True,
                                                &#34;retainedBeyondBasicRet&#34;: False,
                                                &#34;forecastDays&#34;: 0,
                                                &#34;unPrunableData&#34;: True,
                                                &#34;sortByOption&#34;: 2
                                            },
                                            &#34;agentList&#34;: [
                                                {
                                                    &#34;type&#34;: 0,
                                                    &#34;flags&#34;: {
                                                        &#34;include&#34;: True
                                                    }
                                                }
                                            ]
                                        }
                                    }
                                }
                            }
                        ]
                    }
                }

        forecast = self._commcell_object._services[&#39;CREATE_TASK&#39;]
        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, forecast, request)

        if flag:
            if response.json():
                if &#34;jobIds&#34; in response.json():
                    return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
                elif &#34;errorCode&#34; in response.json():
                    error_message = response.json()[&#39;errorMessage&#39;]

                    o_str = &#39;Failed to Run Data Forecast\nError: &#34;{0}&#34;&#39;.format(error_message)
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;108&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.aux_copies"><code class="name">var <span class="ident">aux_copies</span></code></dt>
<dd>
<div class="desc"><p>Returns the list of all aux copies in the policy</p>
<h2 id="returns">Returns</h2>
<p>list - list of all aux copies in the storage policy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2271-L2282" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def aux_copies(self):
    &#34;&#34;&#34;
    Returns the list of all aux copies in the policy
    Returns:
        list - list of all aux copies in the storage policy
    &#34;&#34;&#34;
    aux_copies = []
    for _copy, value in self.copies.items():
        if not value[&#39;isSnapCopy&#39;] and _copy != &#39;primary&#39;:
            aux_copies.append(_copy)
    return aux_copies</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.copies"><code class="name">var <span class="ident">copies</span></code></dt>
<dd>
<div class="desc"><p>Treats the storage policy copies as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1866-L1869" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def copies(self):
    &#34;&#34;&#34;Treats the storage policy copies as a read-only attribute&#34;&#34;&#34;
    return self._copies</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.description"><code class="name">var <span class="ident">description</span></code></dt>
<dd>
<div class="desc"><p>Returns the Storage Policy Description Field</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1886-L1891" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def description(self):
    &#34;&#34;&#34;Returns the Storage Policy Description Field&#34;&#34;&#34;
    if self._storage_policy_advanced_properties is None:
        self._storage_policy_advanced_properties = self._get_storage_policy_advanced_properties()
    return self._storage_policy_advanced_properties.get(&#39;policies&#39;,[{}])[0].get(&#39;description&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.library_id"><code class="name">var <span class="ident">library_id</span></code></dt>
<dd>
<div class="desc"><p>Treats the library id as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2263-L2269" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def library_id(self):
    &#34;&#34;&#34;Treats the library id as a read-only attribute.&#34;&#34;&#34;
    primary_copy = self._storage_policy_properties.get(&#39;copy&#39;)
    if &#39;library&#39; in primary_copy[0]:
        library = primary_copy[0].get(&#39;library&#39;, {})
        return library.get(&#39;libraryId&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.library_name"><code class="name">var <span class="ident">library_name</span></code></dt>
<dd>
<div class="desc"><p>Treats the library name as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2255-L2261" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def library_name(self):
    &#34;&#34;&#34;Treats the library name as a read-only attribute.&#34;&#34;&#34;
    primary_copy = self._storage_policy_properties.get(&#39;copy&#39;)
    if &#39;library&#39; in primary_copy[0]:
        library = primary_copy[0].get(&#39;library&#39;, {})
        return library.get(&#39;libraryName&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Returns the Storage Policy display name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1876-L1879" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;Returns the Storage Policy display name&#34;&#34;&#34;
    return self._storage_policy_properties[&#39;storagePolicy&#39;][&#39;storagePolicyName&#39;]</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.snap_copy"><code class="name">var <span class="ident">snap_copy</span></code></dt>
<dd>
<div class="desc"><p>Returns the name of the snap copy</p>
<h2 id="returns">Returns</h2>
<p>str - name of the snap copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2284-L2295" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def snap_copy(self):
    &#34;&#34;&#34;
    Returns the name of the snap copy
    Returns:
        str - name of the snap copy
    &#34;&#34;&#34;
    snap_copy = None
    for _copy, value in self.copies.items():
        if value[&#39;isSnapCopy&#39;]:
            snap_copy = _copy
    return snap_copy</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_advanced_properties"><code class="name">var <span class="ident">storage_policy_advanced_properties</span></code></dt>
<dd>
<div class="desc"><p>Returns the
storage policy advanced properties</p>
<p>dict - consists of storage policy advanced properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2245-L2253" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def storage_policy_advanced_properties(self):
    &#34;&#34;&#34;Returns the  storage policy advanced properties

        dict - consists of storage policy advanced properties
    &#34;&#34;&#34;
    if self._storage_policy_advanced_properties is None:
        self._storage_policy_advanced_properties = self._get_storage_policy_advanced_properties()
    return self._storage_policy_advanced_properties</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_id"><code class="name">var <span class="ident">storage_policy_id</span></code></dt>
<dd>
<div class="desc"><p>Treats the storage policy id as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1871-L1874" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def storage_policy_id(self):
    &#34;&#34;&#34;Treats the storage policy id as a read-only attribute.&#34;&#34;&#34;
    return self._storage_policy_id</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_name"><code class="name">var <span class="ident">storage_policy_name</span></code></dt>
<dd>
<div class="desc"><p>Treats the storage policy name as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1881-L1884" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def storage_policy_name(self):
    &#34;&#34;&#34;Treats the storage policy name as a read-only attribute.&#34;&#34;&#34;
    return self._storage_policy_name</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_properties"><code class="name">var <span class="ident">storage_policy_properties</span></code></dt>
<dd>
<div class="desc"><p>Returns the storage policy properties</p>
<p>dict - consists of storage policy properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2237-L2243" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def storage_policy_properties(self):
    &#34;&#34;&#34;Returns the storage policy properties

        dict - consists of storage policy properties
    &#34;&#34;&#34;
    return self._storage_policy_properties</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.add_ddb_partition"><code class="name flex">
<span>def <span class="ident">add_ddb_partition</span></span>(<span>self, copy_id, sidb_store_id, sidb_new_path, media_agent)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new DDB partition
Args:
copy_id
(str)
&ndash; storage policy copy id</p>
<pre><code>    sidb_store_id   (str)   -- deduplication store id

    sidb_new_path   (str)   -- path where new partition is to be hosted

    media_agent     (str)   -- media agent on which new partition is to be hosted

Raises:
    SDKException:
        if type of input parameters is not string
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2962-L3004" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_ddb_partition(self,
                      copy_id,
                      sidb_store_id,
                      sidb_new_path,
                      media_agent):
    &#34;&#34;&#34;
    Adds a new DDB partition
        Args:
            copy_id         (str)   -- storage policy copy id

            sidb_store_id   (str)   -- deduplication store id

            sidb_new_path   (str)   -- path where new partition is to be hosted

            media_agent     (str)   -- media agent on which new partition is to be hosted

        Raises:
            SDKException:
                if type of input parameters is not string
    &#34;&#34;&#34;
    if not (isinstance(copy_id, str) and
            isinstance(sidb_store_id, str) and
            isinstance(sidb_new_path, str) and
            isinstance(media_agent, str)):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    if isinstance(media_agent, MediaAgent):
        media_agent = media_agent
    elif isinstance(media_agent, str):
        media_agent = MediaAgent(self._commcell_object, media_agent)

    request_xml = &#34;&#34;&#34;
    &lt;EVGui_ParallelDedupConfigReq commCellId=&#34;2&#34; copyId=&#34;{0}&#34; operation=&#34;15&#34;&gt;
    &lt;SIDBStore SIDBStoreId=&#34;{1}&#34;/&gt;
    &lt;dedupconfigItem commCellId=&#34;0&#34;&gt;
    &lt;maInfoList&gt;&lt;clientInfo id=&#34;{2}&#34; name=&#34;{3}&#34;/&gt;
    &lt;subStoreList&gt;&lt;accessPath path=&#34;{4}&#34;/&gt;
    &lt;/subStoreList&gt;&lt;/maInfoList&gt;&lt;/dedupconfigItem&gt;
    &lt;/EVGui_ParallelDedupConfigReq&gt;

    &#34;&#34;&#34;.format(copy_id, sidb_store_id, media_agent.media_agent_id,
               media_agent.media_agent_name, sidb_new_path)
    self._commcell_object._qoperation_execute(request_xml)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.create_dedupe_secondary_copy"><code class="name flex">
<span>def <span class="ident">create_dedupe_secondary_copy</span></span>(<span>self, copy_name, library_name, media_agent_name, path, ddb_media_agent, dash_full=None, source_side_disk_cache=None, software_compression=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates Synchronous copy for this storage policy</p>
<h2 id="args">Args</h2>
<p>copy_name
(str)
&ndash;
copy name to create</p>
<p>library_name
(str)
&ndash;
library name to be assigned</p>
<p>media_agent_name
(str)
&ndash;
media_agent to be assigned</p>
<p>path
(str)
&ndash;
path where deduplication store is to be hosted</p>
<p>ddb_media_agent
(str)
&ndash;
media agent name on which deduplication store
is to be hosted</p>
<p>dash_full
(bool)
&ndash;
enable DASH full on deduplication store (True/False)
Default None</p>
<p>source_side_disk_cache
(bool)
&ndash; enable source side disk cache (True/False)
Default None</p>
<p>software_compression
(bool)
&ndash; enable software compression (True/False)
Default None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of inputs in not string</p>
<pre><code>if copy with given name already exists

if failed to create copy

if response received is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2510-L2632" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def create_dedupe_secondary_copy(self, copy_name, library_name,
                                 media_agent_name, path, ddb_media_agent,
                                 dash_full=None,
                                 source_side_disk_cache=None,
                                 software_compression=None):
    &#34;&#34;&#34;Creates Synchronous copy for this storage policy

        Args:
            copy_name               (str)   --  copy name to create

            library_name            (str)   --  library name to be assigned

            media_agent_name        (str)   --  media_agent to be assigned

            path                    (str)   --  path where deduplication store is to be hosted

            ddb_media_agent         (str)   --  media agent name on which deduplication store
                                                is to be hosted

            dash_full               (bool)  --  enable DASH full on deduplication store (True/False)
            Default None

            source_side_disk_cache  (bool)  -- enable source side disk cache (True/False)
            Default None

            software_compression    (bool)  -- enable software compression (True/False)
            Default None

        Raises:
            SDKException:
                if type of inputs in not string

                if copy with given name already exists

                if failed to create copy

                if response received is empty

                if response is not success
    &#34;&#34;&#34;
    if not (isinstance(copy_name, str) and
            isinstance(library_name, str) and
            isinstance(path, str) and
            isinstance(ddb_media_agent, str) and
            isinstance(media_agent_name, str)):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    if dash_full is None:
        dash_full = &#34;2&#34;
    if source_side_disk_cache is None:
        source_side_disk_cache = &#34;2&#34;
    if software_compression is None:
        software_compression = &#34;2&#34;

    if self.has_copy(copy_name):
        err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

    library_id = self._commcell_object.disk_libraries.get(library_name).library_id
    media_agent_id = self._commcell_object.media_agents._media_agents[media_agent_name][&#39;id&#39;]

    request_xml = &#34;&#34;&#34;
    &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
        &lt;storagePolicyCopyInfo copyType=&#34;0&#34; isDefault=&#34;0&#34;&gt;
            &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
            &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
            &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
            &lt;copyFlags auxCopyReencryptData=&#34;0&#34; /&gt;
            &lt;dedupeFlags enableDeduplication=&#34;1&#34; enableDASHFull=&#34;{9}&#34; enableSourceSideDiskCache=&#34;{10}&#34;/&gt;
            &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;1&#34; retainBackupDataForDays=&#34;30&#34; /&gt;
            &lt;DDBPartitionInfo&gt;
                &lt;maInfoList&gt;
                    &lt;mediaAgent mediaAgentName=&#34;{8}&#34;/&gt;
                    &lt;subStoreList&gt;
                        &lt;diskFreeThresholdMB&gt;5120&lt;/diskFreeThresholdMB&gt;
                        &lt;diskFreeWarningThreshholdMB&gt;10240&lt;/diskFreeWarningThreshholdMB&gt;
                        &lt;accessPath path=&#34;{7}&#34;/&gt;
                    &lt;/subStoreList&gt;
                &lt;/maInfoList&gt;
                &lt;sidbStoreInfo&gt;
                    &lt;operation&gt;1&lt;/operation&gt;
                    &lt;copyName&gt;{0}&lt;/copyName&gt;
                    &lt;sidbStoreFlags enableSoftwareCompression=&#34;{11}&#34;/&gt;
                &lt;/sidbStoreInfo&gt;
            &lt;/DDBPartitionInfo&gt;

        &lt;/storagePolicyCopyInfo&gt;
    &lt;/App_CreateStoragePolicyCopyReq&gt;
    &#34;&#34;&#34;.format(copy_name, self._storage_policy_id, self.storage_policy_name,
               library_id, library_name, media_agent_id, media_agent_name,
               path, ddb_media_agent, int(dash_full),
               int(source_side_disk_cache), int(software_compression))

    create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, create_copy_service, request_xml
    )

    self.refresh()

    if flag:
        if response.json():
            if &#39;error&#39; in response.json():
                error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                if error_code != 0:
                    if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                        error_message = &#34;Failed to create {0} Storage Policy copy with error \
                        {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                    else:
                        error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                            copy_name
                        )

                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.create_secondary_copy"><code class="name flex">
<span>def <span class="ident">create_secondary_copy</span></span>(<span>self, copy_name, library_name=None, media_agent_name=None, drive_pool=None, spare_pool=None, tape_library_id=None, drive_pool_id=None, spare_pool_id=None, snap_copy=False, global_policy=None, retention_days=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates Synchronous copy for this storage policy</p>
<h2 id="args">Args</h2>
<p>copy_name
(str)
&ndash;
copy name to create</p>
<p>library_name
(str)
&ndash;
library name to be assigned</p>
<p>media_agent_name
(str)
&ndash;
media_agent to be assigned</p>
<dl>
<dt>snap_copy
(bool)
&ndash;
boolean on whether copy should be a snap copy</dt>
<dt><strong><code>default</code></strong></dt>
<dd>False</dd>
</dl>
<p>global_policy
(str)
&ndash;
name of the global policy to be assigned</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of inputs in not string</p>
<pre><code>if copy with given name already exists

if failed to create copy

if response received is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1149-L1307" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def create_secondary_copy(self,
                          copy_name,
                          library_name=None,
                          media_agent_name=None,
                          drive_pool=None,
                          spare_pool=None,
                          tape_library_id=None,
                          drive_pool_id=None,
                          spare_pool_id=None,
                          snap_copy=False,
                          global_policy=None,
                          retention_days=30):
    &#34;&#34;&#34;Creates Synchronous copy for this storage policy

        Args:
            copy_name           (str)   --  copy name to create

            library_name        (str)   --  library name to be assigned

            media_agent_name    (str)   --  media_agent to be assigned

            snap_copy           (bool)  --  boolean on whether copy should be a snap copy
            default: False

            global_policy       (str)   --  name of the global policy to be assigned

        Raises:
            SDKException:
                if type of inputs in not string

                if copy with given name already exists

                if failed to create copy

                if response received is empty

                if response is not success
    &#34;&#34;&#34;
    if global_policy is not None:
        if not (isinstance(copy_name, str) and isinstance(global_policy, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if self.has_copy(copy_name):
            err_msg = f&#39;Storage Policy copy &#34;{copy_name}&#34; already exists.&#39;
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        if not self._commcell_object.storage_pools.has_storage_pool(global_policy):
            err_msg = f&#39;No Global Storage Policy &#34;{global_policy}&#34; exists.&#39;
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        global_policy = self._commcell_object.storage_pools.get(global_policy)

        global_policy_copy = StoragePolicyCopy (self._commcell_object, global_policy.storage_pool_name, global_policy.copy_name)

        is_global_dedupe_policy = global_policy_copy._dedupe_flags.get(&#39;enableDeduplication&#39;, 0)
        
        request = {
                   &#34;copyName&#34;: copy_name,
                   &#34;storagePolicyCopyInfo&#34;: {
                      &#34;copyType&#34;: 0,
                      &#34;isDefault&#34;: 0,
                      &#34;isMirrorCopy&#34;: 0,
                      &#34;isSnapCopy&#34;: 0,
                      &#34;numberOfStreamsToCombine&#34;: 1,
                      &#34;StoragePolicyCopy&#34;: {
                         &#34;_type_&#34;: 18,
                         &#34;storagePolicyName&#34;: self.storage_policy_name
                      },
                      &#34;retentionRules&#34;: {
                         &#34;retainArchiverDataForDays&#34;: -1,
                         &#34;retainBackupDataForCycles&#34;: 1,
                         &#34;retainBackupDataForDays&#34;: retention_days
                      },
                      &#34;dedupeFlags&#34;: {
                          &#34;enableDeduplication&#34;: is_global_dedupe_policy,
                          &#34;useGlobalDedupStore&#34;: is_global_dedupe_policy
                      },
                       &#34;useGlobalPolicy&#34;:{
                           &#34;storagePolicyName&#34;: global_policy.storage_pool_name
                       },
                       &#34;extendedFlags&#34;:{
                           &#34;useGlobalStoragePolicy&#34;: 1
                       }
                   }
                }

    else:
        if not (isinstance(copy_name, str) and
                isinstance(library_name, str) and
                isinstance(media_agent_name, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if self.has_copy(copy_name):
            err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

        media_agent_id = self._commcell_object.media_agents._media_agents[media_agent_name.lower()][&#39;id&#39;]

        snap_copy = int(snap_copy)

        if drive_pool is not None:
                request = &#34;&#34;&#34;
                        &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                            &lt;storagePolicyCopyInfo copyType=&#34;0&#34; isDefault=&#34;0&#34; isMirrorCopy=&#34;0&#34; isSnapCopy=&#34;{11}&#34; numberOfStreamsToCombine=&#34;1&#34;&gt;
                                &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                                &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                                &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                                &lt;drivePool drivePoolId = &#34;{7}&#34; drivePoolName = &#34;{8}&#34;  libraryName = &#34;{4}&#34; /&gt;
                                &lt;spareMediaGroup spareMediaGroupId = &#34;{9}&#34; spareMediaGroupName = &#34;{10}&#34; libraryName = &#34;{4}&#34; /&gt;
                                &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;1&#34; retainBackupDataForDays=&#34;30&#34; /&gt;
                            &lt;/storagePolicyCopyInfo&gt;
                        &lt;/App_CreateStoragePolicyCopyReq&gt;
                        &#34;&#34;&#34;.format(copy_name, self.storage_policy_id, self.storage_policy_name,
                                   tape_library_id, library_name, media_agent_id, media_agent_name,
                                   drive_pool_id, drive_pool, spare_pool_id, spare_pool, snap_copy)

        else:
            library_id = self._commcell_object.disk_libraries._libraries[library_name.lower()]
            request = &#34;&#34;&#34;
            &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                &lt;storagePolicyCopyInfo copyType=&#34;0&#34; isDefault=&#34;0&#34; isMirrorCopy=&#34;0&#34; isSnapCopy=&#34;{7}&#34; numberOfStreamsToCombine=&#34;1&#34;&gt;
                    &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                    &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                    &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                    &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;1&#34; retainBackupDataForDays=&#34;30&#34; /&gt;
                &lt;/storagePolicyCopyInfo&gt;
            &lt;/App_CreateStoragePolicyCopyReq&gt;
            &#34;&#34;&#34;.format(copy_name, self.storage_policy_id, self.storage_policy_name,
                       library_id, library_name, media_agent_id, media_agent_name, snap_copy)

    create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, create_copy_service, request
    )

    self.refresh()

    if flag:
        if response.json():
            if &#39;error&#39; in response.json():
                error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                if error_code != 0:
                    if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                        error_message = &#34;Failed to create {0} Storage Policy copy with error \
                        {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                    else:
                        error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                            copy_name
                        )
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.create_selective_copy"><code class="name flex">
<span>def <span class="ident">create_selective_copy</span></span>(<span>self, copy_name, library_name, media_agent_name, sel_freq, first_or_last_full, backups_from, daystartson=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates Selective copy for this storage policy</p>
<h2 id="args">Args</h2>
<p>copy_name
(str)
&ndash;
copy name to create
library_name
(str)
&ndash;
library name to be assigned
media_agent_name
(str)
&ndash;
media_agent to be assigned
drive_pool etc are for tape library</p>
<p>sel_freq
(str) &ndash; {all,hourly,daily,weekly,monthly,quaterly,half-year,year}
first_or_last_full
(str) &ndash; {FirstFull, LastFull, LastFullWait}
backups_from
(str) &ndash; {start date in yyyy-mm-dd format to pick jobs from this date}</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of inputs in not string</p>
<pre><code>if copy with given name already exists

if failed to create copy

if response received is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1741-L1864" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def create_selective_copy(self,
                          copy_name,
                          library_name,
                          media_agent_name,
                          sel_freq,
                          first_or_last_full,
                          backups_from,
                          daystartson=None):
    &#34;&#34;&#34;Creates Selective copy for this storage policy

        Args:
            copy_name           (str)   --  copy name to create
            library_name        (str)   --  library name to be assigned
            media_agent_name    (str)   --  media_agent to be assigned
            drive_pool etc are for tape library

            sel_freq            (str) -- {all,hourly,daily,weekly,monthly,quaterly,half-year,year}
            first_or_last_full  (str) -- {FirstFull, LastFull, LastFullWait}
            backups_from        (str) -- {start date in yyyy-mm-dd format to pick jobs from this date}

        Raises:
            SDKException:
                if type of inputs in not string

                if copy with given name already exists

                if failed to create copy

                if response received is empty

                if response is not success
    &#34;&#34;&#34;
    if not (isinstance(copy_name, str) and
            isinstance(library_name, str) and
            isinstance(media_agent_name, str)):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    if self.has_copy(copy_name):
        err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

    media_agent_id = self._commcell_object.media_agents._media_agents[media_agent_name.lower()][&#39;id&#39;]

    selective_copy_freq = {&#39;all&#39;: 2, &#39;hourly&#39;: 262144, &#39;daily&#39;: 524288, &#39;weekly&#39;: 4, &#39;monthly&#39;: 8,
                           &#39;quarterly&#39;: 16, &#39;halfyearly&#39;: 32, &#39;yearly&#39;: 64, &#39;advanced&#39;: 16777216
                           }
    week_starts_on = {&#39;Sunday&#39;: 0, &#39;Monday&#39;: 1, &#39;Tuesday&#39;: 2, &#39;Wednesday&#39;: 3, &#39;Thursday&#39;: 4,
                      &#39;Friday&#39;: 5, &#39;Saturday&#39;: 6
                      }

    selective_rule = selective_copy_freq[sel_freq]
    copyflags = &#34;&#34;
    if first_or_last_full == &#34;LastFull&#34;:
        copyflags = &#34;&#34;&#34;&lt;copyFlags lastFull = &#34;1&#34; /&gt;&#34;&#34;&#34;
    elif first_or_last_full == &#34;LastFullWait&#34;:
        copyflags = &#34;&#34;&#34;&lt;copyFlags lastFull = &#34;1&#34; lastFullWait=&#34;1&#34; /&gt;&#34;&#34;&#34;

    dsostr = &#34;&#34;
    if (sel_freq == &#39;daily&#39; or sel_freq == &#39;hourly&#39;) and daystartson is not None \
            and isinstance(daystartson, dict):
        dsostr = &#34;&#34;&#34;
                    &lt;dayStartsAt amOrPm = &#34;{3}&#34;&gt; 
                    &lt;dayStartsHoursMinutes hours=&#34;{0}&#34; minutes = &#34;{1}&#34;  seconds= &#34;{2}&#34; /&gt;
                    &lt;/dayStartsAt&gt; 
                 &#34;&#34;&#34;.format(daystartson[&#34;hours&#34;], daystartson[&#34;minutes&#34;], daystartson[&#34;seconds&#34;],
                            daystartson[&#34;ampm&#34;])

    day_starts = &#34;&#34;
    if sel_freq == &#39;weekly&#39;:
        if daystartson is not None:
            day_starts = &#34;&#34;&#34; weekDayStartsOn=&#34;{0}&#34; &#34;&#34;&#34;.format(week_starts_on[daystartson])
        else:
            day_starts = &#34;&#34;&#34; weekDayStartsOn=&#34;{0}&#34; &#34;&#34;&#34;.format(week_starts_on[&#39;Friday&#39;])

    # monthStartsOn
    if sel_freq == &#39;monthly&#39;:
        if daystartson is not None:
            day_starts = &#34;&#34;&#34; monthStartsOn=&#34;{0}&#34; &#34;&#34;&#34;.format(daystartson)
        else:
            day_starts = &#34;&#34;&#34; monthStartsOn=&#34;{}&#34; &#34;&#34;&#34;.format(1)

    library_id = self._commcell_object.disk_libraries._libraries[library_name.lower()]
    request_xml = str(&#34;&#34;&#34;&lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
            &lt;storagePolicyCopyInfo copyType=&#34;2&#34; isDefault=&#34;0&#34; isMirrorCopy=&#34;0&#34; isSnapCopy=&#34;0&#34; numberOfStreamsToCombine=&#34;1&#34;&gt;
                &lt;StoragePolicyCopy _type_=&#34;18&#34; storagePolicyId=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34; /&gt;
                &lt;library _type_=&#34;9&#34; libraryId=&#34;{3}&#34; libraryName=&#34;{4}&#34; /&gt;
                &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;{5}&#34; mediaAgentName=&#34;{6}&#34; /&gt;
                &lt;retentionRules retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;100&#34; retainBackupDataForDays=&#34;150&#34; /&gt;
                &lt;startTime  timeValue = &#34;{7}&#34; /&gt;
                &lt;selectiveCopyRules selectiveRule=&#34;{8}&#34; {10} &gt; {9} &lt;/selectiveCopyRules&gt; &#34;&#34;&#34; + copyflags +
                          &#34;&#34;&#34;&lt;/storagePolicyCopyInfo&gt;
                      &lt;/App_CreateStoragePolicyCopyReq&gt;&#34;&#34;&#34;).format(copy_name, self.storage_policy_id,
                                                                   self.storage_policy_name,
                                                                   library_id, library_name, media_agent_id,
                                                                   media_agent_name, backups_from,
                                                                   selective_rule, dsostr, day_starts)
    create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, create_copy_service, request_xml)

    self.refresh()

    if flag:
        if response.json():
            if &#39;error&#39; in response.json():
                error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                if error_code != 0:
                    if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                        error_message = &#34;Failed to create {0} Storage Policy copy with error \
                        {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                    else:
                        error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                            copy_name
                        )
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.create_snap_copy"><code class="name flex">
<span>def <span class="ident">create_snap_copy</span></span>(<span>self, copy_name, is_mirror_copy, is_snap_copy, library_name, media_agent_name, source_copy, provisioning_policy=None, resource_pool=None, is_replica_copy=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates Snap copy for this storage policy</p>
<h2 id="args">Args</h2>
<p>copy_name
(str)
&ndash;
copy name to create</p>
<p>is_mirror_copy
(bool)
&ndash;
if true then copyType will be Mirror</p>
<p>is_snap_copy
(bool)
&ndash;
if true then copyType will be Snap</p>
<p>library_name
(str)
&ndash;
library name to be assigned</p>
<p>media_agent_name
(str)
&ndash;
media_agent to be assigned</p>
<p>source_copy
(str)
&ndash;
Name of the Source Copy for this copy</p>
<p>provisioning_policy (str)
&ndash;
Name of the provisioning Policy to add
default : None</p>
<p>resource_pool
(str)
&ndash;
Name of the resource pool to add
default : None</p>
<p>is_replica_copy
(bool)
&ndash;
if true then Replica Copy will be created
default : None</p>
<p>is_c2c_target
(bool)
&ndash; if true then NetApp Cloud target copy will be created
default : False</p>
<p>job_retention
(bool)
&ndash; if true job based retention will be set
default : False</p>
<p>enable_selective_copy (int) &ndash; Enable selective copy with value selectiveRule</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of inputs in not string</p>
<pre><code>if copy with given name already exists

if failed to create copy

if response received is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1524-L1680" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def create_snap_copy(self,
                     copy_name,
                     is_mirror_copy,
                     is_snap_copy,
                     library_name,
                     media_agent_name,
                     source_copy,
                     provisioning_policy=None,
                     resource_pool=None,
                     is_replica_copy=None,
                     **kwargs):
    &#34;&#34;&#34;Creates Snap copy for this storage policy

        Args:
            copy_name           (str)   --  copy name to create

            is_mirror_copy      (bool)   --  if true then copyType will be Mirror

            is_snap_copy        (bool)   --  if true then copyType will be Snap

            library_name        (str)   --  library name to be assigned

            media_agent_name    (str)   --  media_agent to be assigned

            source_copy         (str)   --  Name of the Source Copy for this copy

            provisioning_policy (str)   --  Name of the provisioning Policy to add
            default : None

            resource_pool       (str)   --  Name of the resource pool to add
            default : None

            is_replica_copy     (bool)   --  if true then Replica Copy will be created
            default : None

            is_c2c_target       (bool)   -- if true then NetApp Cloud target copy will be created 
            default : False

            job_retention       (bool)  -- if true job based retention will be set
            default : False

            enable_selective_copy (int) -- Enable selective copy with value selectiveRule

        Raises:
            SDKException:
                if type of inputs in not string

                if copy with given name already exists

                if failed to create copy

                if response received is empty

                if response is not success
    &#34;&#34;&#34;
    if not (isinstance(copy_name, str) and
            isinstance(library_name, str) and
            isinstance(media_agent_name, str)):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    if self.has_copy(copy_name):
        err_msg = &#39;Storage Policy copy &#34;{0}&#34; already exists.&#39;.format(copy_name)
        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

    if is_replica_copy:
        arrayReplicaCopy = &#34;1&#34;
        useOfflineReplication = &#34;1&#34;
    else:
        arrayReplicaCopy = &#34;0&#34;
        useOfflineReplication = &#34;0&#34;
    if is_mirror_copy:
        is_mirror_copy = 1
    else:
        is_mirror_copy = 0
    if is_snap_copy:
        is_snap_copy = 1
    else:
        is_snap_copy = 0
    if provisioning_policy is None:
        provisioning_policy = &#34;&#34;
        resource_pool = &#34;&#34;

    is_c2c_target = kwargs.get(&#39;is_c2c_target&#39;, False)
    isNetAppSnapCloudTargetCopy = 1 if is_c2c_target else 0

    job_based_retention = kwargs.get(&#39;job_based_retention&#39;, False)
    job_retention = 1 if job_based_retention else 0

    selectiveRule = kwargs.get(&#39;enable_selective_copy&#39;, None)
    if selectiveRule is None:
        request_xml = &#34;&#34;&#34;
                &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                    &lt;storagePolicyCopyInfo active=&#34;1&#34; isMirrorCopy=&#34;{1}&#34; isSnapCopy=&#34;{2}&#34; provisioningPolicyName=&#34;{3}&#34;&gt;
                        &lt;StoragePolicyCopy _type_=&#34;18&#34; copyName=&#34;{0}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                        &lt;extendedFlags arrayReplicaCopy=&#34;{5}&#34; isNetAppSnapCloudTargetCopy=&#34;{12}&#34; useOfflineArrayReplication=&#34;{6}&#34; /&gt;
                        &lt;library _type_=&#34;9&#34; libraryName=&#34;{7}&#34; /&gt;
                        &lt;mediaAgent _type_=&#34;11&#34; mediaAgentName=&#34;{8}&#34; /&gt;
                        &lt;spareMediaGroup _type_=&#34;67&#34; libraryName=&#34;{7}&#34; /&gt;
                        &lt;retentionRules jobs=&#34;8&#34; retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;5&#34; retainBackupDataForDays=&#34;1&#34;&gt;
                        &lt;retentionFlags jobBasedRetention=&#34;{11}&#34; /&gt;
                        &lt;/retentionRules&gt;
                        &lt;sourceCopy _type_=&#34;18&#34; copyName=&#34;{9}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                        &lt;resourcePoolsList operation=&#34;1&#34; resourcePoolName=&#34;{10}&#34; /&gt;
                    &lt;/storagePolicyCopyInfo&gt;
                &lt;/App_CreateStoragePolicyCopyReq&gt;
                &#34;&#34;&#34;.format(copy_name, is_mirror_copy, is_snap_copy, provisioning_policy,
                           self.storage_policy_name, arrayReplicaCopy, useOfflineReplication,
                           library_name, media_agent_name, source_copy, resource_pool, job_retention, isNetAppSnapCloudTargetCopy)
    else:
        request_xml = &#34;&#34;&#34;
                                    &lt;App_CreateStoragePolicyCopyReq copyName=&#34;{0}&#34;&gt;
                                        &lt;storagePolicyCopyInfo copyType=&#34;2&#34; description=&#34;&#34; isMirrorCopy=&#34;{1}&#34; isSnapCopy=&#34;{2}&#34;&gt;
                                            &lt;StoragePolicyCopy copyName=&#34;{0}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                                            &lt;extendedFlags arrayReplicaCopy=&#34;{5}&#34; isNetAppSnapCloudTargetCopy=&#34;{12}&#34; useOfflineArrayReplication=&#34;{6}&#34; /&gt;
                                            &lt;library  libraryName=&#34;{7}&#34; /&gt;
                                            &lt;mediaAgent _type_=&#34;11&#34; mediaAgentName=&#34;{8}&#34; /&gt;
                                            &lt;retentionRules jobs=&#34;8&#34; retainArchiverDataForDays=&#34;-1&#34; retainBackupDataForCycles=&#34;5&#34; retainBackupDataForDays=&#34;1&#34;&gt;
                                            &lt;retentionFlags jobBasedRetention=&#34;{11}&#34; /&gt;
                                            &lt;/retentionRules&gt;
                                            &lt;sourceCopy _type_=&#34;18&#34; copyName=&#34;{9}&#34; storagePolicyName=&#34;{4}&#34; /&gt;
                                            &lt;selectiveCopyRules selectiveRule=&#34;{13}&#34;/&gt;
                                            &lt;/storagePolicyCopyInfo&gt;
                                    &lt;/App_CreateStoragePolicyCopyReq&gt;
                                    &#34;&#34;&#34;.format(copy_name, is_mirror_copy, is_snap_copy, provisioning_policy,
                                               self.storage_policy_name, arrayReplicaCopy, useOfflineReplication,
                                               library_name, media_agent_name, source_copy, resource_pool,
                                               job_retention, isNetAppSnapCloudTargetCopy, selectiveRule)

    create_copy_service = self._commcell_object._services[&#39;CREATE_STORAGE_POLICY_COPY&#39;]

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, create_copy_service, request_xml
    )

    self.refresh()

    if flag:
        if response.json():
            if &#39;error&#39; in response.json():
                error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                if error_code != 0:
                    if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                        error_message = &#34;Failed to create {0} Storage Policy copy with error \
                        {1}&#34;.format(copy_name, str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                    else:
                        error_message = &#34;Failed to create {0} Storage Policy copy&#34;.format(
                            copy_name
                        )
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)

            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.delete_job"><code class="name flex">
<span>def <span class="ident">delete_job</span></span>(<span>self, job_id, commcell_id=2)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a job on Storage Policy</p>
<h2 id="args">Args</h2>
<p>job_id
(str)
&ndash;
ID for the job to be deleted</p>
<p>commcell_id
(str)
&ndash;
The commcell ID of the job to be deleted</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of input parameters is not string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3067-L3094" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delete_job(self, job_id, commcell_id=2):
    &#34;&#34;&#34;Deletes a job on Storage Policy

        Args:
            job_id          (str)   --  ID for the job to be deleted

            commcell_id     (str)   --  The commcell ID of the job to be deleted

        Raises:
            SDKException:
                if type of input parameters is not string

    &#34;&#34;&#34;

    if not isinstance(job_id, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    job_list_tag = &#39;&#39;
    for copy_name, copy_info in self.copies.items():
        job_list_tag += f&#34;&#34;&#34;&lt;jobList appType=&#34;&#34; commCellId=&#34;{commcell_id}&#34; jobId=&#34;{job_id}&#34;&gt;
        &lt;copyInfo copyName=&#34;{copy_name}&#34; storagePolicyName=&#34;{self.storage_policy_name}&#34;/&gt;&lt;/jobList&gt;&#34;&#34;&#34;

    request_xml = f&#34;&#34;&#34;&lt;App_JobOperationCopyReq operationType=&#34;2&#34;&gt;{job_list_tag}
    &lt;commCellInfo commCellId=&#34;{commcell_id}&#34;/&gt;
    &lt;/App_JobOperationCopyReq&gt;
    &#34;&#34;&#34;

    self._commcell_object._qoperation_execute(request_xml)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.delete_secondary_copy"><code class="name flex">
<span>def <span class="ident">delete_secondary_copy</span></span>(<span>self, copy_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes the copy associated with this storage policy</p>
<h2 id="args">Args</h2>
<p>copy_name
(str)
&ndash;
copy name to be deleted</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of input parameters is not string</p>
<pre><code>if storage policy copy doesn't exist with given name

if failed to delete storage policy copy

if response received is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1682-L1739" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delete_secondary_copy(self, copy_name):
    &#34;&#34;&#34;Deletes the copy associated with this storage policy

        Args:
            copy_name   (str)   --  copy name to be deleted

        Raises:
            SDKException:
                if type of input parameters is not string

                if storage policy copy doesn&#39;t exist with given name

                if failed to delete storage policy copy

                if response received is empty

                if response is not success
    &#34;&#34;&#34;
    if not isinstance(copy_name, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
    else:
        copy_name = copy_name.lower()

    if not self.has_copy(copy_name):
        err_msg = &#39;Storage Policy copy &#34;{0}&#34; doesn\&#39;t exists.&#39;.format(copy_name)
        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)

    delete_copy_service = self._commcell_object._services[&#39;DELETE_STORAGE_POLICY_COPY&#39;]

    request_xml = &#34;&#34;&#34;
    &lt;App_DeleteStoragePolicyCopyReq&gt;
        &lt;archiveGroupCopy _type_=&#34;18&#34; copyId=&#34;{0}&#34; copyName=&#34;{1}&#34; storagePolicyId=&#34;{2}&#34; storagePolicyName=&#34;{3}&#34; /&gt;
    &lt;/App_DeleteStoragePolicyCopyReq&gt;
    &#34;&#34;&#34;.format(self._copies[copy_name][&#39;copyId&#39;], copy_name, self.storage_policy_id,
               self.storage_policy_name)

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, delete_copy_service, request_xml
    )

    self.refresh()

    if flag:
        if response.json():
            if &#39;error&#39; in response.json():
                error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                if error_code != 0:
                    error_message = &#34;Failed to delete {0} Storage Policy copy&#34;.format(
                        copy_name
                    )
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.edit_block_size_on_gdsp"><code class="name flex">
<span>def <span class="ident">edit_block_size_on_gdsp</span></span>(<span>self, size=512)</span>
</code></dt>
<dd>
<div class="desc"><p>edit the block size on the gdsp</p>
<h2 id="args">Args</h2>
<p>size (int) - SIDB block size to be changed to</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if error in response</p>
<pre><code>    if response received is empty

    if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1083-L1128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def edit_block_size_on_gdsp(self,
                            size=512):
    &#34;&#34;&#34;
    edit the block size on the gdsp

    Args:
            size (int) - SIDB block size to be changed to


    Raises:
        SDKException:
                if error in response

                if response received is empty

                if response is not success
    &#34;&#34;&#34;
    request_json = {
                    &#34;App_UpdateStoragePolicyReq&#34;: {
                        &#34;StoragePolicy&#34;: {
                            &#34;storagePolicyName&#34;: self._storage_policy_name
                        },
                        &#34;sidbBlockSizeKB&#34;: size
                      }
                    }

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_json
    )

    if flag:
        if response.json():
            if &#39;error&#39; in response.json():
                error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                if error_code != 0:
                    if &#39;errorMessage&#39; in response.json()[&#39;error&#39;]:
                        error_message = &#34;Failed to update block size factor on gdsp with error \
                                {0}&#34;.format(str(response.json()[&#39;error&#39;][&#39;errorMessage&#39;]))
                    else:
                        error_message = &#34;Failed to update block size factor on gdsp&#34;
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.enable_content_indexing"><code class="name flex">
<span>def <span class="ident">enable_content_indexing</span></span>(<span>self, cloud_id, include_doc_type=None, max_doc_size=None, min_doc_size=None, exclude_doc_type=None)</span>
</code></dt>
<dd>
<div class="desc"><p>configures offline CI for this storage policy</p>
<h2 id="args">Args</h2>
<p>cloud_id
(str)
&ndash;
cloud id of the search engine</p>
<p>include_doc_type
(str)
&ndash;
include document types for content indexing</p>
<pre><code>Example : "*.csv,*.ppt"
</code></pre>
<p>exclude_doc_type
(str)
&ndash;
exclude document types for content indexing</p>
<pre><code>Example : "*.py,*.txt"
</code></pre>
<p>max_doc_size
(str)
&ndash;
maximum document size for CI in KB</p>
<p>min_doc_size
(str)
&ndash;
minimum document size for CI in KB</p>
<h2 id="returns">Returns</h2>
<p>None</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of inputs is not valid</p>
<pre><code>    if failed to configure content indexing

    if response received is empty

    if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1361-L1440" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def enable_content_indexing(
        self,
        cloud_id,
        include_doc_type=None,
        max_doc_size=None,
        min_doc_size=None,
        exclude_doc_type=None):
    &#34;&#34;&#34;configures offline CI for this storage policy

            Args:

                cloud_id            (str)   --  cloud id of the search engine

                include_doc_type    (str)   --  include document types for content indexing

                    Example : &#34;*.csv,*.ppt&#34;

                exclude_doc_type    (str)   --  exclude document types for content indexing

                    Example : &#34;*.py,*.txt&#34;

                max_doc_size        (str)   --  maximum document size for CI in KB

                min_doc_size        (str)   --  minimum document size for CI in KB

            Returns:
                None

            Raises:

                SDKException:
                        if type of inputs is not valid

                        if failed to configure content indexing

                        if response received is empty

                        if response is not success
    &#34;&#34;&#34;
    if not isinstance(cloud_id, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    if include_doc_type is None:
        include_doc_type = &#34;*.bmp,*.csv,*.doc,*.docx,*.dot,*.eml,*.htm,*.html,*.jpeg,*.jpg,*.log,*.msg,*.odg,&#34; \
                           &#34;*.odp,*.ods,*.odt,*.pages,*.pdf,*.png,*.ppt,*.pptx,*.rtf,*.txt,*.xls,*.xlsx,*.xmind,*.xml&#34;
    if max_doc_size is None:
        max_doc_size = &#34;51200&#34;

    if min_doc_size is None:
        min_doc_size = &#34;0&#34;

    if exclude_doc_type is None:
        exclude_doc_type = &#34;&#34;

    request_xml = &#34;&#34;&#34;&lt;EVGui_ContentIndexingControlReq operation=&#34;16&#34;&gt;&lt;header localeId=&#34;0&#34; userId=&#34;0&#34;/&gt;
    &lt;ciProps archGroupId=&#34;{0}&#34; calendarId=&#34;1&#34; cloudId=&#34;{1}&#34; contentIndexDataOver=&#34;0&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
     enable=&#34;1&#34; entityIds=&#34;&#34; excludeDocTypes=&#34;{5}&#34; filterSelected=&#34;1&#34; flags=&#34;0&#34;
     includeDocTypes=&#34;{2}&#34; indexType=&#34;0&#34; jobsOlderThan=&#34;0&#34;
     maxDocSizeKB=&#34;{3}&#34; minDocSizeKB=&#34;{4}&#34; numPeriod=&#34;1&#34; retentionDays=&#34;-1&#34; sourceCopyId=&#34;0&#34; startTime=&#34;0&#34;
     synchronizeOn=&#34;0&#34; type=&#34;0&#34;/&gt;&lt;/EVGui_ContentIndexingControlReq&gt;&#34;&#34;&#34;\
        .format(self._storage_policy_id, cloud_id, include_doc_type, max_doc_size, min_doc_size, exclude_doc_type)

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
    )

    if flag:
        if response.json():
            if &#39;error&#39; in response.json():
                error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                if error_code != 1:
                    error_message = &#34;Failed to enable content indexing for this storage policy&#34;
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;, &#39;No success error code found in response&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.enable_entity_extraction"><code class="name flex">
<span>def <span class="ident">enable_entity_extraction</span></span>(<span>self, entity_details, entity_names, ca_client_name)</span>
</code></dt>
<dd>
<div class="desc"><p>configures offline CI entity extraction for given subclient id's on this storage policy</p>
<h2 id="args">Args</h2>
<p>entity_details
(list)
&ndash;
List of subclient to configure for Entity Extraction</p>
<p>Format : [[clientname,agent type,backup set name,subclient name]]</p>
<p>entity_names
(list)
&ndash;
list of entity names to be configured for Entity Extraction</p>
<p>Example : [Email,SSN]</p>
<p>ca_client_name
(str)
&ndash;
client name where Content Analyzer package is installed</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of inputs is not valid</p>
<pre><code>if failed to configure EE

if response received is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1442-L1522" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def enable_entity_extraction(self, entity_details, entity_names, ca_client_name):
    &#34;&#34;&#34;configures offline CI entity extraction for given subclient id&#39;s on this storage policy

            Args:
                entity_details     (list)     --  List of subclient to configure for Entity Extraction

                Format : [[clientname,agent type,backup set name,subclient name]]

                entity_names         (list)   --  list of entity names to be configured for Entity Extraction

                Example : [Email,SSN]

                ca_client_name       (str)    --  client name where Content Analyzer package is installed

            Raises:
                SDKException:
                    if type of inputs is not valid

                    if failed to configure EE

                    if response received is empty

                    if response is not success
    &#34;&#34;&#34;
    if not (isinstance(entity_details, list) and isinstance(entity_names, list)):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
    if not isinstance(ca_client_name, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
    request_xml = &#34;&#34;&#34;&lt;EVGui_SetEntityExtractionListReq archGroupId=&#34;{0}&#34;&gt;
    &lt;entityExtraction isConfigured=&#34;1&#34;&gt;&#34;&#34;&#34;.format(self._storage_policy_id)
    for subclient in entity_details:
        client_name = subclient[0]
        app_name = subclient[1]
        backup_set_name = subclient[2]
        subclient_name = subclient[3]
        client_obj = self._commcell_object.clients.get(client_name)
        agent_obj = client_obj.agents.get(app_name)
        backup_set_obj = agent_obj.backupsets.get(backup_set_name)
        subclient_obj = backup_set_obj.subclients.get(subclient_name)
        if subclient_obj.storage_policy.lower() != self._storage_policy_name.lower():
            err_msg = &#39;Subclient &#34;{0}&#34; is not a part of this storage policy&#39;.format(subclient_name)
            raise SDKException(&#39;Storage&#39;, &#39;102&#39;, err_msg)
        subclient_prop = subclient_obj.properties
        request_xml = request_xml + &#34;&#34;&#34;&lt;appList appOperation=&#34;0&#34; appTypeId=&#34;{0}&#34; archGroupId=&#34;0&#34;
            backupSetId=&#34;{1}&#34; clientId=&#34;{2}&#34; instanceId=&#34;{3}&#34; subClientId=&#34;{4}&#34;/&gt;&#34;&#34;&#34;.format(
            subclient_prop[&#39;subClientEntity&#39;][&#39;applicationId&#39;],
            subclient_prop[&#39;subClientEntity&#39;][&#39;backupsetId&#39;],
            subclient_prop[&#39;subClientEntity&#39;][&#39;clientId&#39;],
            subclient_prop[&#39;subClientEntity&#39;][&#39;instanceId&#39;],
            subclient_prop[&#39;subClientEntity&#39;][&#39;subclientId&#39;],
        )

    for entity in entity_names:
        entity_obj = self._commcell_object.activate.entity_manager().get(entity)
        request_xml = request_xml + &#34;&#34;&#34;&lt;entities enabled=&#34;1&#34; entityId=&#34;{0}&#34; entityName=&#34;{1}&#34;/&gt;&#34;&#34;&#34;\
            .format(entity_obj.entity_id, entity)

    client_obj = self._commcell_object.clients.get(ca_client_name)
    request_xml = request_xml + &#34;&#34;&#34;&lt;extractingClientList enabled=&#34;1&#34;&gt;
    &lt;eeClient clientId=&#34;{0}&#34; clientName=&#34;{1}&#34;/&gt;
    &lt;/extractingClientList&gt;&lt;/entityExtraction&gt;&lt;/EVGui_SetEntityExtractionListReq&gt;&#34;&#34;&#34;\
        .format(client_obj.client_id, ca_client_name)

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
    )

    if flag:
        if response.json():
            if &#39;errorCode&#39; in response.json():
                error_code = int(response.json()[&#39;errorCode&#39;])
                if error_code != 0:
                    error_message = &#34;Failed to enable entity extraction for this storage policy&#34;
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;, &#39;No success error code found in response&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.get_copy"><code class="name flex">
<span>def <span class="ident">get_copy</span></span>(<span>self, copy_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a storage policy copy object if copy exists</p>
<h2 id="args">Args</h2>
<p>copy_name (str)
&ndash;
name of the storage policy copy</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the StoragePolicyCopy class for the given copy name</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the copy name argument is not string</p>
<pre><code>if no copy exists with the given name
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3006-L3029" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_copy(self, copy_name):
    &#34;&#34;&#34;Returns a storage policy copy object if copy exists

        Args:
           copy_name (str)  --  name of the storage policy copy

        Returns:
           object - instance of the StoragePolicyCopy class for the given copy name

        Raises:
           SDKException:
               if type of the copy name argument is not string

               if no copy exists with the given name
    &#34;&#34;&#34;
    if not isinstance(copy_name, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    if self.has_copy(copy_name):
        return StoragePolicyCopy(self._commcell_object, self.storage_policy_name, copy_name)
    else:
        raise SDKException(
            &#39;Storage&#39;, &#39;102&#39;, &#39;No copy exists with name: {0}&#39;.format(copy_name)
        )</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.get_copy_precedence"><code class="name flex">
<span>def <span class="ident">get_copy_precedence</span></span>(<span>self, copy_name)</span>
</code></dt>
<dd>
<div class="desc"><p>returns the copy precedence value associated with the copy name</p>
<h2 id="args">Args</h2>
<p>copy_name
(str)
&ndash;
Storage copy name</p>
<h2 id="returns">Returns</h2>
<p>copy_precedence
(int)
&ndash;
Copy precedence number of
storage copy</p>
<h2 id="raises">Raises</h2>
<p>Exception:
if unable to find the given copy name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1893-L1915" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_copy_precedence(self, copy_name):
    &#34;&#34;&#34; returns the copy precedence value associated with the copy name

        Args:
            copy_name           (str)   --  Storage copy name

        Returns:
            copy_precedence     (int)   --  Copy precedence number of
            storage copy

        Raises:
            Exception:
                if unable to find the given copy name

    &#34;&#34;&#34;
    policy_copies = self.copies
    if policy_copies.get(copy_name):
        if policy_copies[copy_name].get(&#39;copyPrecedence&#39;):
            return policy_copies[copy_name][&#39;copyPrecedence&#39;]
    raise SDKException(
        &#39;Storage&#39;,
        &#39;102&#39;,
        &#39;Failed to get copy precedence from policy&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.get_primary_copy"><code class="name flex">
<span>def <span class="ident">get_primary_copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the primary copy of the storage policy</p>
<h2 id="returns">Returns</h2>
<p>object
-
Instance of the StoragePolicyCopy class of the primary copy</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if unable to find a primary copy in the storage policy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3031-L3047" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_primary_copy(self):
    &#34;&#34;&#34;Returns the primary copy of the storage policy

        Returns:
            object  -   Instance of the StoragePolicyCopy class of the primary copy

        Raises:
           SDKException:
               if unable to find a primary copy in the storage policy

    &#34;&#34;&#34;

    for copy_name, copy_info in self.copies.items():
        if copy_info[&#39;isDefault&#39;]:
            return self.get_copy(copy_name)

    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, &#39;Unable to find a primary copy in the storage policy&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.get_secondary_copies"><code class="name flex">
<span>def <span class="ident">get_secondary_copies</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all the secondary copies in the storage policy sorted by copy precedence</p>
<h2 id="returns">Returns</h2>
<p>list
-
A list of storage policy copy instances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3049-L3065" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_secondary_copies(self):
    &#34;&#34;&#34;Returns all the secondary copies in the storage policy sorted by copy precedence

        Returns:
            list    -   A list of storage policy copy instances.

    &#34;&#34;&#34;

    sorted_copies = sorted(self.copies.items(), key=lambda x: x[1][&#39;copyPrecedence&#39;])  # Sort by copy precedence
    result = []

    for copy_name, copy_info in sorted_copies:
        if not copy_info[&#39;isDefault&#39;] and not copy_info[&#39;isSnapCopy&#39;]:  # Skip primary copy and snap primary copies
            copy_obj = self.get_copy(copy_name)
            result.append(copy_obj)

    return result</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.has_copy"><code class="name flex">
<span>def <span class="ident">has_copy</span></span>(<span>self, copy_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a storage policy copy exists for this storage
policy with the input storage policy name.</p>
<h2 id="args">Args</h2>
<p>copy_name (str)
&ndash;
name of the storage policy copy</p>
<h2 id="returns">Returns</h2>
<p>bool - boolean output whether the storage policy copy exists or not</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the storage policy copy name argument is not string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1130-L1147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_copy(self, copy_name):
    &#34;&#34;&#34;Checks if a storage policy copy exists for this storage
        policy with the input storage policy name.

        Args:
            copy_name (str)  --  name of the storage policy copy

        Returns:
            bool - boolean output whether the storage policy copy exists or not

        Raises:
            SDKException:
                if type of the storage policy copy name argument is not string
    &#34;&#34;&#34;
    if not isinstance(copy_name, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    return self._copies and copy_name.lower() in self._copies</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.mark_for_recovery"><code class="name flex">
<span>def <span class="ident">mark_for_recovery</span></span>(<span>self, store_id, sub_store_id, media_agent_name, dedupe_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks Deduplication store for recovery</p>
<h2 id="args">Args</h2>
<p>store_id
(str)
&ndash;
SIDB store id</p>
<p>sub_store_id
(str)
&ndash;
SIDB substore id</p>
<p>media_agent_name (str)
&ndash;
name of the media agent on which DDB is hosted</p>
<p>dedupe_path
(str)
&ndash;
SIDB store path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3096-L3115" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mark_for_recovery(self, store_id, sub_store_id, media_agent_name, dedupe_path):
    &#34;&#34;&#34; Marks Deduplication store for recovery

        Args:
           store_id         (str)  --  SIDB store id

           sub_store_id     (str)  --  SIDB substore id

           media_agent_name (str)  --  name of the media agent on which DDB is hosted

           dedupe_path      (str)  --  SIDB store path
    &#34;&#34;&#34;

    request_xml = &#34;&#34;&#34;
            &lt;EVGui_IdxSIDBSubStoreOpReq&gt;&lt;info SIDBStoreId=&#34;{0}&#34; SubStoreId=&#34;{1}&#34; opType=&#34;1&#34; path=&#34;{3}&#34;&gt;
            &lt;mediaAgent name=&#34;{2}&#34;/&gt;
            &lt;/info&gt;
            &lt;/EVGui_IdxSIDBSubStoreOpReq&gt;
            &#34;&#34;&#34;.format(store_id, sub_store_id, media_agent_name, dedupe_path)
    self._commcell_object._qoperation_execute(request_xml)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.modify_dynamic_stream_allocation"><code class="name flex">
<span>def <span class="ident">modify_dynamic_stream_allocation</span></span>(<span>self, enable=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Modifies the DSA option for the Storage Policy
Args:</p>
<pre><code>        enable      (bool)  --   False - Disable DSA
                                 True - Enable DSA
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2139-L2156" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def modify_dynamic_stream_allocation(self, enable=True):
    &#34;&#34;&#34;
    Modifies the DSA option for the Storage Policy
        Args:

                enable      (bool)  --   False - Disable DSA
                                         True - Enable DSA
    &#34;&#34;&#34;
    request_xml = &#39;&#39;&#39;&lt;App_UpdateStoragePolicyReq&gt;
                   &lt;StoragePolicy&gt;
                       &lt;storagePolicyName&gt;{0}&lt;/storagePolicyName&gt;
                   &lt;/StoragePolicy&gt;
                   &lt;flag&gt;
                       &lt;distributeDataEvenlyAmongStreams&gt;{1}&lt;/distributeDataEvenlyAmongStreams&gt;
                   &lt;/flag&gt;
                   &lt;/App_UpdateStoragePolicyReq&gt;
                   &#39;&#39;&#39;.format(self.storage_policy_name, int(enable))
    self._commcell_object.qoperation_execute(request_xml)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.move_dedupe_store"><code class="name flex">
<span>def <span class="ident">move_dedupe_store</span></span>(<span>self, copy_name, dest_path, src_path, dest_media_agent, src_media_agent, config_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Moves a deduplication store</p>
<pre><code>Args:
    copy_name               (str)   -- name of the storage policy copy

    dest_path:              (str)   -- path where new partition is to be hosted

    src_path:               (str)   -- path where existing partition is hosted

    dest_media_agent:       (str)   -- media agent name where new partition is to be hosted

    src_media_agent:        (str)   -- media agent name where existing partition is hosted

    config_only             (bool)  -- to only chnage in DB (files need to be moved manually) (True/False)
    Default : False

Returns:
    object - object - instance of the Job class for this DDB move job

Raises:
    SDKException:
        if type of input parameters is not string

        if job failed

        if response is empty

        if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2854-L2960" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def move_dedupe_store(self,
                      copy_name,
                      dest_path,
                      src_path,
                      dest_media_agent,
                      src_media_agent,
                      config_only=False):
    &#34;&#34;&#34;
    Moves a deduplication store

        Args:
            copy_name               (str)   -- name of the storage policy copy

            dest_path:              (str)   -- path where new partition is to be hosted

            src_path:               (str)   -- path where existing partition is hosted

            dest_media_agent:       (str)   -- media agent name where new partition is to be hosted

            src_media_agent:        (str)   -- media agent name where existing partition is hosted

            config_only             (bool)  -- to only chnage in DB (files need to be moved manually) (True/False)
            Default : False

        Returns:
            object - object - instance of the Job class for this DDB move job

        Raises:
            SDKException:
                if type of input parameters is not string

                if job failed

                if response is empty

                if response is not success
    &#34;&#34;&#34;
    if not (isinstance(copy_name, str) and
            isinstance(dest_path, str) and
            isinstance(src_path, str) and
            isinstance(dest_media_agent, str) and
            isinstance(src_media_agent, str)):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    request = {
        &#34;taskInfo&#34;: {
            &#34;associations&#34;: [
                {
                    &#34;copyName&#34;: copy_name, &#34;storagePolicyName&#34;: self.storage_policy_name
                }
            ], &#34;task&#34;: {
                &#34;taskType&#34;: 1,
                &#34;initiatedFrom&#34;: 1,
                &#34;policyType&#34;: 0,
                &#34;taskId&#34;: 0,
                &#34;taskFlags&#34;: {
                    &#34;disabled&#34;: False
                }
            }, &#34;subTasks&#34;: [
                {
                    &#34;subTaskOperation&#34;: 1, &#34;subTask&#34;: {
                        &#34;subTaskType&#34;: 1, &#34;operationType&#34;: 5013
                    }, &#34;options&#34;: {
                        &#34;adminOpts&#34;: {
                            &#34;libraryOption&#34;: {
                                &#34;operation&#34;: 20, &#34;ddbMoveOption&#34;: {
                                    &#34;flags&#34;: 2, &#34;subStoreList&#34;: [
                                        {
                                                &#34;srcPath&#34;: src_path,
                                                &#34;changeOnlyDB&#34;: config_only,
                                                &#34;destPath&#34;: dest_path,
                                                &#34;destMediaAgent&#34;: {
                                                    &#34;name&#34;: dest_media_agent
                                                }, &#34;srcMediaAgent&#34;: {
                                                    &#34;name&#34;: src_media_agent
                                                }
                                        }
                                    ]
                                }
                            }
                        }
                    }
                }
            ]
        }
    }
    ddb_move = self._commcell_object._services[&#39;CREATE_TASK&#39;]
    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, ddb_move, request
    )

    if flag:
        if response.json():
            if &#34;jobIds&#34; in response.json():
                return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
            elif &#34;errorCode&#34; in response.json():
                error_message = response.json()[&#39;errorMessage&#39;]

                o_str = &#39;DDB move job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Storage&#39;, &#39;108&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.reassociate_all_subclients"><code class="name flex">
<span>def <span class="ident">reassociate_all_subclients</span></span>(<span>self, dest_storage_policy_name='CV_DEFAULT')</span>
</code></dt>
<dd>
<div class="desc"><p>Reassociates all subclients associated to Storage Policy</p>
<h2 id="args">Args</h2>
<p>dest_storage_policy_name(str):
Name of a Storage Policy to which the Subclients are to
be reassociated.
Default Value:
'CV_DEFAULT': 'Not Assigned' to any Policy.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SDKException
</code></dt>
<dd>If failed to reassociate</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3172-L3213" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reassociate_all_subclients(self, dest_storage_policy_name=&#39;CV_DEFAULT&#39;):
    &#34;&#34;&#34;
    Reassociates all subclients associated to Storage Policy
    Args:
        dest_storage_policy_name(str):  Name of a Storage Policy to which the Subclients are to
                                        be reassociated.
                                        Default Value:
                                        &#39;CV_DEFAULT&#39;: &#39;Not Assigned&#39; to any Policy.
    Raises:
        SDKException    :   If failed to reassociate
    &#34;&#34;&#34;
    request_json = {
        &#34;App_ReassociateStoragePolicyReq&#34;: {
            &#34;forceNextBkpToFull&#34;: True,
            &#34;newStoragePolicy&#34;: {
                &#34;storagePolicyName&#34;: dest_storage_policy_name
            },
            &#34;currentStoragePolicy&#34;: {
                &#34;storagePolicyName&#34;: self.storage_policy_name
            }
        }
    }
    reassociate_subclients = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, reassociate_subclients, request_json
    )
    if flag:
        if response.json():
            if &#39;errorCode&#39; in response.json():
                error_code = int(response.json()[&#39;errorCode&#39;])
                if error_code != 0:
                    error_message = &#34;Failed to Reassociate the Subclients&#34;
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
    self.refresh()</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the properties of the StoragePolicy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2437-L2440" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Refresh the properties of the StoragePolicy.&#34;&#34;&#34;
    self._initialize_storage_policy_properties()
    self._storage_policy_advanced_properties = None</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.run_aux_copy"><code class="name flex">
<span>def <span class="ident">run_aux_copy</span></span>(<span>self, storage_policy_copy_name=None, media_agent=None, use_scale=True, streams=0, all_copies=True, total_jobs_to_process=1000, schedule_pattern=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the aux copy job from the commcell.</p>
<h2 id="args">Args</h2>
<p>storage_policy_copy_name (str)
&ndash;
name of the storage policy copy</p>
<p>media_agent
(str)
&ndash;
name of the media agent</p>
<p>use_scale
(bool) &ndash;
use Scalable Resource Management (True/False)</p>
<p>streams
(int)
&ndash;
number of streams to use</p>
<p>all_copies
(bool) &ndash; run auxcopy job on all copies or select copy
(True/False)</p>
<p>total_jobs_to_process
(int)
&ndash; Total number jobs to process for the auxcopy job</p>
<p>**kwargs
&ndash;
dict of keyword arguments as follows:
ignore_dv_failed_jobs
(bool)
&ndash; Ignore DV failed jobs
job_description
(str)
&ndash; Description for Job</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Job class for this aux copy job</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of the
argument is not string</p>
<pre><code>if aux copy job failed

if response is empty

if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2297-L2435" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run_aux_copy(self, storage_policy_copy_name=None,
                 media_agent=None, use_scale=True, streams=0,
                 all_copies=True, total_jobs_to_process=1000, schedule_pattern=None, **kwargs):
    &#34;&#34;&#34;Runs the aux copy job from the commcell.
        Args:

            storage_policy_copy_name (str)  --  name of the storage policy copy

            media_agent              (str)  --  name of the media agent

            use_scale                (bool) --  use Scalable Resource Management (True/False)

            streams                  (int)  --  number of streams to use

            all_copies               (bool) -- run auxcopy job on all copies or select copy
                                               (True/False)

            total_jobs_to_process    (int)  -- Total number jobs to process for the auxcopy job

            **kwargs    --  dict of keyword arguments as follows:
            ignore_dv_failed_jobs  (bool)  -- Ignore DV failed jobs
            job_description     (str)      -- Description for Job

        Returns:
            object - instance of the Job class for this aux copy job

        Raises:
            SDKException:
                if type of the  argument is not string

                if aux copy job failed

                if response is empty

                if response is not success
    &#34;&#34;&#34;
    if not (isinstance(total_jobs_to_process, int) and
            isinstance(streams, int)):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    use_max_streams = True
    if streams != 0:
        use_max_streams = False

    if storage_policy_copy_name is not None:
        all_copies = False
        if not media_agent:
            media_agent = &#34;&amp;lt;ANY MEDIAAGENT&amp;gt;&#34;
        if not (isinstance(storage_policy_copy_name, str) and
                isinstance(media_agent, str)):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
    else:
        if all_copies is False:
            raise SDKException(&#39;Storage&#39;, &#39;110&#39;)
        storage_policy_copy_name = &#34;&#34;
        media_agent = &#34;&#34;

    ignore_dv_failed_jobs = False
    if kwargs.get(&#39;ignore_dv_failed_jobs&#39;) is True:
        ignore_dv_failed_jobs = True

    request_json = {
        &#34;taskInfo&#34;: {
            &#34;associations&#34;: [
                {
                    &#34;copyName&#34;: storage_policy_copy_name,
                    &#34;storagePolicyName&#34;: self.storage_policy_name
                }
            ],
            &#34;task&#34;: {
                &#34;initiatedFrom&#34;: 2,
                &#34;taskType&#34;: 1,
                &#34;policyType&#34;: 0,
                &#34;taskFlags&#34;: {
                    &#34;disabled&#34;: False
                }
            },
            &#34;subTasks&#34;: [
                {
                    &#34;subTaskOperation&#34;: 1,
                    &#34;subTask&#34;: {
                        &#34;subTaskType&#34;: 1,
                        &#34;operationType&#34;: 4003
                    },
                    &#34;options&#34;: {
                        &#34;backupOpts&#34;: {
                            &#34;mediaOpt&#34;: {
                                &#34;auxcopyJobOption&#34;: {
                                    &#34;maxNumberOfStreams&#34;: streams,
                                    &#34;useMaximumStreams&#34;: use_max_streams,
                                    &#34;useScallableResourceManagement&#34;: use_scale,
                                    &#34;totalJobsToProcess&#34;: total_jobs_to_process,
                                    &#34;ignoreDataVerificationFailedJobs&#34;: ignore_dv_failed_jobs,
                                    &#34;allCopies&#34;: all_copies,
                                    &#34;mediaAgent&#34;: {
                                        &#34;mediaAgentName&#34;: media_agent
                                    }
                                }
                            }
                        },
                        &#34;commonOpts&#34;: {
                            &#34;jobDescription&#34;: kwargs.get(&#39;job_description&#39;, &#39;&#39;)
                        }
                    }
                }
            ]
        }
    }

    if schedule_pattern:
        request_json = SchedulePattern().create_schedule(request_json, schedule_pattern)

    aux_copy = self._commcell_object._services[&#39;CREATE_TASK&#39;]

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, aux_copy, request_json
    )

    if flag:
        if response.json():
            if &#34;jobIds&#34; in response.json():
                return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
            elif &#34;errorCode&#34; in response.json():
                error_message = response.json()[&#39;errorMessage&#39;]

                o_str = &#39;Restore job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)

            elif &#34;taskId&#34; in response.json():
                return Schedules(self._commcell_object).get(task_id=response.json()[&#39;taskId&#39;])

            else:
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, &#39;Failed to run the aux copy job&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)

    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.run_backup_copy"><code class="name flex">
<span>def <span class="ident">run_backup_copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the backup copy from Commcell for the given storage policy</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Job class for this backup copy job</p>
<h2 id="raises">Raises</h2>
<p>SDKException:</p>
<pre><code>    if backup copy job failed

    if response is empty

    if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2065-L2137" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run_backup_copy(self):
    &#34;&#34;&#34;
    Runs the backup copy from Commcell for the given storage policy

    Args:
            None

    Returns:
            object - instance of the Job class for this backup copy job
    Raises:
        SDKException:

                if backup copy job failed

                if response is empty

                if response is not success
    &#34;&#34;&#34;
    request_json = {
        &#34;taskInfo&#34;: {
            &#34;associations&#34;: [
                {
                    &#34;storagePolicyName&#34;: self.storage_policy_name
                }
            ],
            &#34;task&#34;: {
                &#34;initiatedFrom&#34;: 2,
                &#34;taskType&#34;: 1,
                &#34;policyType&#34;: 3,
                &#34;taskFlags&#34;: {
                    &#34;disabled&#34;: False
                }
            },
            &#34;subTasks&#34;: [
                {
                    &#34;subTaskOperation&#34;: 1,
                    &#34;subTask&#34;: {
                        &#34;subTaskType&#34;: 1,
                        &#34;operationType&#34;: 4028
                    },
                    &#34;options&#34;: {
                        &#34;adminOpts&#34;: {
                            &#34;snapToTapeOption&#34;: {
                                &#34;allowMaximum&#34;: True,
                                &#34;noofJobsToRun&#34;: 1
                            }
                        }
                    }
                }
            ]
        }
    }

    backup_copy = self._commcell_object._services[&#39;CREATE_TASK&#39;]
    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, backup_copy, request_json)

    if flag:
        if response.json():
            if &#34;jobIds&#34; in response.json():
                return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
            elif &#34;errorCode&#34; in response.json():
                error_message = response.json()[&#39;errorMessage&#39;]

                o_str = &#39;Backup copy job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                raise SDKException(&#39;Storage&#39;, &#39;106&#39;, o_str)
            else:
                raise SDKException(&#39;Storage&#39;, &#39;106&#39;, &#39;Failed to run the backup copy job&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;106&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.run_content_indexing"><code class="name flex">
<span>def <span class="ident">run_content_indexing</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>starts the offline CI job for this storage policy</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Job class for this CI job</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of inputs is not valid</p>
<pre><code>    if failed to start content indexing job

    if response received is empty

    if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1309-L1359" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run_content_indexing(self):
    &#34;&#34;&#34;starts the offline CI job for this storage policy

        Args:
            None

        Returns:
            object - instance of the Job class for this CI job

        Raises:
            SDKException:
                    if type of inputs is not valid

                    if failed to start content indexing job

                    if response received is empty

                    if response is not success
    &#34;&#34;&#34;
    request_xml = &#34;&#34;&#34;&lt;TMMsg_CreateTaskReq&gt;
    &lt;taskInfo&gt;
    &lt;associations subclientId=&#34;0&#34; storagePolicyId=&#34;{0}&#34; applicationId=&#34;0&#34; clientName=&#34;&#34; backupsetId=&#34;0&#34;
    instanceId=&#34;0&#34; commCellId=&#34;0&#34; clientId=&#34;0&#34; subclientName=&#34;&#34; mediaAgentId=&#34;0&#34; mediaAgentName=&#34;&#34; backupsetName=&#34;&#34;
    instanceName=&#34;&#34; storagePolicyName=&#34;{1}&#34; _type_=&#34;0&#34; appName=&#34;&#34; /&gt;
    &lt;task ownerId=&#34;1&#34; taskType=&#34;1&#34; ownerName=&#34;admin&#34; sequenceNumber=&#34;0&#34; initiatedFrom=&#34;1&#34; policyType=&#34;0&#34; taskId=&#34;0&#34;&gt;
    &lt;taskFlags disabled=&#34;0&#34; /&gt;&lt;/task&gt;
    &lt;subTasks subTaskOperation=&#34;1&#34;&gt;&lt;subTask subTaskType=&#34;1&#34; operationType=&#34;4022&#34; /&gt;
    &lt;options&gt;&lt;backupOpts&gt;&lt;mediaOpt&gt;
    &lt;auxcopyJobOption maxNumberOfStreams=&#34;0&#34; allCopies=&#34;1&#34; useMaximumStreams=&#34;1&#34;&gt;&lt;mediaAgent mediaAgentId=&#34;0&#34;
    _type_=&#34;11&#34; mediaAgentName=&#34;&#34; /&gt;
    &lt;/auxcopyJobOption&gt;&lt;/mediaOpt&gt;&lt;/backupOpts&gt;&lt;adminOpts&gt;
    &lt;contentIndexingOption fileAnalytics=&#34;0&#34; subClientBasedAnalytics=&#34;0&#34; reanalyze=&#34;0&#34; /&gt;
    &lt;/adminOpts&gt;
    &lt;restoreOptions&gt;&lt;virtualServerRstOption isBlockLevelReplication=&#34;0&#34; /&gt;&lt;commonOptions syncRestore=&#34;0&#34; /&gt;
    &lt;/restoreOptions&gt;&lt;/options&gt;&lt;/subTasks&gt;
    &lt;/taskInfo&gt;&lt;/TMMsg_CreateTaskReq&gt;&#34;&#34;&#34;.format(self._storage_policy_id, self._storage_policy_name)

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
    )

    if flag:
        if response.json():
            if &#34;jobIds&#34; in response.json():
                return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
            else:
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, &#39;Unable to get job id for CI job&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;, &#39;Empty response&#39;)
    else:
        raise SDKException(&#39;Response&#39;, &#39;101&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.run_data_forecast"><code class="name flex">
<span>def <span class="ident">run_data_forecast</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>runs data forecast and retention report generation operation</p>
<h2 id="args">Args</h2>
<p>**kwargs
&ndash;
dict of keyword arguments as follows:</p>
<pre><code>localeName      str     localeName for report [defaults to "en-us"]
</code></pre>
<h2 id="raises">Raises</h2>
<p>SDKException &ndash; if response is bad/ flag is false
Returns None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3261-L3374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run_data_forecast(self, **kwargs):
    &#34;&#34;&#34;runs data forecast and retention report generation operation

        Args:

            **kwargs    --  dict of keyword arguments as follows:

                localeName      str     localeName for report [defaults to &#34;en-us&#34;]

        Raises:
              SDKException -- if response is bad/ flag is false

        Returns None
            &#34;&#34;&#34;
    request = {
                &#34;processinginstructioninfo&#34;: {},
                &#34;taskInfo&#34;: {
                    &#34;task&#34;: {
                        &#34;taskType&#34;: 1,
                        &#34;initiatedFrom&#34;: 2,
                        &#34;taskFlags&#34;: {
                            &#34;disabled&#34;: False
                        }
                    },
                    &#34;appGroup&#34;: {},
                    &#34;subTasks&#34;: [
                        {
                            &#34;subTaskOperation&#34;: 1,
                            &#34;subTask&#34;: {
                                &#34;subTaskName&#34;: &#34;&#34;,
                                &#34;subTaskType&#34;: 1,
                                &#34;operationType&#34;: 4004
                            },
                            &#34;options&#34;: {
                                &#34;adminOpts&#34;: {
                                    &#34;reportOption&#34;: {
                                        &#34;showHiddenStoragePolicies&#34;: False,
                                        &#34;showGlobalStoragePolicies&#34;: False,
                                        &#34;storagePolicyCopyList&#34;: [
                                            {
                                                &#34;storagePolicyName&#34;: self.storage_policy_name
                                            }
                                        ],
                                        &#34;mediaInfoReport&#34;: {
                                            &#34;mediaLocIn&#34;: True,
                                            &#34;mediaLocOut&#34;: True
                                        },
                                        &#34;commonOpt&#34;: {
                                            &#34;dateFormat&#34;: &#34;mm/dd/yyyy&#34;,
                                            &#34;overrideDateTimeFormat&#34;: 0,
                                            &#34;reportType&#34;: 7738,
                                            &#34;summaryOnly&#34;: False,
                                            &#34;reportCustomName&#34;: &#34;&#34;,
                                            &#34;timeFormat&#34;: &#34;hh:mm:ss am/pm&#34;,
                                            &#34;onCS&#34;: True,
                                            &#34;locale&#34;: {
                                                &#34;country&#34;: &#34;English&#34;,
                                                &#34;language&#34;: &#34;UnitedStates&#34;,
                                                &#34;localeName&#34;: kwargs.get(&#34;localeName&#34;, &#34;en-us&#34;)
                                            },
                                            &#34;outputFormat&#34;: {
                                                &#34;outputType&#34;: 1,
                                                &#34;isNetworkDrive&#34;: False
                                            }
                                        },
                                        &#34;computerSelectionList&#34;: {
                                            &#34;includeAll&#34;: True
                                        },
                                        &#34;jobSummaryReport&#34;: {
                                            &#34;subclientFilter&#34;: False
                                        },
                                        &#34;dataRetentionForecastReport&#34;: {
                                            &#34;pruneData&#34;: True,
                                            &#34;retainedBeyondBasicRet&#34;: False,
                                            &#34;forecastDays&#34;: 0,
                                            &#34;unPrunableData&#34;: True,
                                            &#34;sortByOption&#34;: 2
                                        },
                                        &#34;agentList&#34;: [
                                            {
                                                &#34;type&#34;: 0,
                                                &#34;flags&#34;: {
                                                    &#34;include&#34;: True
                                                }
                                            }
                                        ]
                                    }
                                }
                            }
                        }
                    ]
                }
            }

    forecast = self._commcell_object._services[&#39;CREATE_TASK&#39;]
    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, forecast, request)

    if flag:
        if response.json():
            if &#34;jobIds&#34; in response.json():
                return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
            elif &#34;errorCode&#34; in response.json():
                error_message = response.json()[&#39;errorMessage&#39;]

                o_str = &#39;Failed to Run Data Forecast\nError: &#34;{0}&#34;&#39;.format(error_message)
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Storage&#39;, &#39;108&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.run_data_verification"><code class="name flex">
<span>def <span class="ident">run_data_verification</span></span>(<span>self, media_agent_name='', copy_name='', streams=0, jobs_to_verify='NEW', use_scalable=True, schedule_pattern=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs Data verification job</p>
<h2 id="args">Args</h2>
<p>media_agent_name
(str)
: name of the mediaAgent to use for data reading</p>
<p>copy_name
(str)
: name of Copy
(default - verifies jobs on all copies)</p>
<p>streams
(int)
: number of streams to use
(default - use Maximum)</p>
<p>jobs_to_verify
(str)
: jobs to be Verified
(NEW/ VERF_EXPIRED/ ALL)</p>
<p>use_scalable
(bool) : True/False to use Scalable Resource Allocation
(default - True)</p>
<p>kwargs
(dict) : optional arguments
Available kwargs Options:
job_description
(str): Description for Job</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Job class for this Data Verification Job</p>
<p>errorMessage - If Data Verification Job fails to Start</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2746-L2852" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run_data_verification(self, media_agent_name=&#39;&#39;, copy_name=&#39;&#39;, streams=0,
                          jobs_to_verify=&#39;NEW&#39;, use_scalable=True, schedule_pattern=None, **kwargs):
    &#34;&#34;&#34;Runs Data verification job

    Args:
        media_agent_name    (str)  : name of the mediaAgent to use for data reading

        copy_name           (str)  : name of Copy
                                     (default - verifies jobs on all copies)

        streams             (int)  : number of streams to use
                                     (default - use Maximum)

        jobs_to_verify      (str)  : jobs to be Verified
                                     (NEW/ VERF_EXPIRED/ ALL)

        use_scalable       (bool) : True/False to use Scalable Resource Allocation
                                     (default - True)

        kwargs              (dict) : optional arguments
            Available kwargs Options:
                job_description     (str): Description for Job

    Returns:
        object - instance of the Job class for this Data Verification Job

        errorMessage - If Data Verification Job fails to Start
    &#34;&#34;&#34;
    if not (isinstance(copy_name, str) and isinstance(jobs_to_verify, str)
            and isinstance(media_agent_name, str) and isinstance(streams, int)):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    if jobs_to_verify.upper() == &#39;NEW&#39;:
        jobs_to_verify = &#39;NEWLY_AVAILABLE&#39;
    elif jobs_to_verify.upper() == &#39;VERF_EXPIRED&#39;:
        jobs_to_verify = &#39;VERIFICATION_EXP&#39;
    elif jobs_to_verify.upper() == &#39;ALL&#39;:
        jobs_to_verify = &#39;BOTH_NEWLY_AVAILABLE_AND_VERIFICATION_EXP&#39;

    request = {
        &#34;taskInfo&#34;: {
            &#34;associations&#34;: [
                {
                    &#34;copyName&#34;: copy_name,
                    &#34;storagePolicyName&#34;: self.storage_policy_name
                }
            ],
            &#34;task&#34;: {},
            &#34;subTasks&#34;: [
                {
                    &#34;subTaskOperation&#34;: 1,
                    &#34;subTask&#34;: {
                        &#34;subTaskType&#34;: 1,
                        &#34;operationType&#34;: 4007
                    },
                    &#34;options&#34;: {
                        &#34;backupOpts&#34;: {
                            &#34;mediaOpt&#34;: {
                                &#34;auxcopyJobOption&#34;: {
                                    &#34;maxNumberOfStreams&#34;: streams,
                                    &#34;useMaximumStreams&#34;: not bool(streams),
                                    &#34;useScallableResourceManagement&#34;: use_scalable,
                                    &#34;mediaAgent&#34;: {
                                        &#34;mediaAgentName&#34;: media_agent_name
                                    }
                                }
                            }
                        },
                        &#34;adminOpts&#34;: {
                            &#34;archiveCheckOption&#34;: {
                                &#34;jobsToVerify&#34;: jobs_to_verify,
                            }
                        },
                        &#34;commonOpts&#34;: {
                            &#34;jobDescription&#34;: kwargs.get(&#39;job_description&#39;,&#39;&#39;)
                        }
                    }
                }
            ]
        }
    }

    if schedule_pattern:
        request[&#34;taskInfo&#34;][&#34;task&#34;] = {&#34;taskType&#34;: 2}
        request = SchedulePattern().create_schedule(request, schedule_pattern)

    data_verf = self._commcell_object._services[&#39;CREATE_TASK&#39;]
    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, data_verf, request
    )
    if flag:
        if response.json():
            if &#34;jobIds&#34; in response.json():
                return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
            elif &#34;errorCode&#34; in response.json():
                error_message = response.json()[&#39;errorMessage&#39;]
                o_str = &#39;Data verification Request failed. Error: &#34;{0}&#34;&#39;.format(error_message)
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
            elif &#34;taskId&#34; in response.json():
                return Schedules(self._commcell_object).get(task_id=response.json()[&#39;taskId&#39;])
            else:
                raise SDKException(&#39;Storage&#39;, &#39;109&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.run_ddb_verification"><code class="name flex">
<span>def <span class="ident">run_ddb_verification</span></span>(<span>self, copy_name, ver_type, ddb_ver_level, use_scalable=True, orphan_chunk_listing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs DDB verification job</p>
<pre><code>Args:
    copy_name       (str)   --  name of the copy which is associated with the DDB store

    ver_type        (str)   --  backup level (Full/Incremental)

    ddb_ver_level   (str)   --  DDB verification type
                                (DDB_VERIFICATION/ DDB_AND_DATA_VERIFICATION /
                                QUICK_DDB_VERIFICATION/ DDB_DEFRAGMENTATION)

    use_scalable    (bool)  --  True/False to use Scalable Resource Allocation
                                Default: True

    orphan_chunk_listing (bool) --  True/False to run orphan chunk listing phase during DDB Defragmentation

Returns:
    object - instance of the Job class for this DDB verification job

Raises:
    SDKException:
        if type of input parameters is not string

        if job failed

        if response is empty

        if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2634-L2744" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run_ddb_verification(self,
                         copy_name,
                         ver_type,
                         ddb_ver_level,
                         use_scalable=True,
                         orphan_chunk_listing=False):
    &#34;&#34;&#34;
    Runs DDB verification job

        Args:
            copy_name       (str)   --  name of the copy which is associated with the DDB store

            ver_type        (str)   --  backup level (Full/Incremental)

            ddb_ver_level   (str)   --  DDB verification type
                                        (DDB_VERIFICATION/ DDB_AND_DATA_VERIFICATION /
                                        QUICK_DDB_VERIFICATION/ DDB_DEFRAGMENTATION)

            use_scalable    (bool)  --  True/False to use Scalable Resource Allocation
                                        Default: True

            orphan_chunk_listing (bool) --  True/False to run orphan chunk listing phase during DDB Defragmentation

        Returns:
            object - instance of the Job class for this DDB verification job

        Raises:
            SDKException:
                if type of input parameters is not string

                if job failed

                if response is empty

                if response is not success
    &#34;&#34;&#34;
    if not (isinstance(copy_name, str) and
            isinstance(ver_type, str) and
            isinstance(ddb_ver_level, str)):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
    run_defrag = False
    if ddb_ver_level == &#39;DDB_DEFRAGMENTATION&#39;:
        run_defrag = True
    request = {
        &#34;taskInfo&#34;: {
            &#34;associations&#34;: [
                {
                    &#34;copyName&#34;: copy_name, &#34;storagePolicyName&#34;: self.storage_policy_name
                }
            ], &#34;task&#34;: {
                &#34;taskType&#34;: 1,
                &#34;initiatedFrom&#34;: 1,
                &#34;policyType&#34;: 0,
                &#34;taskId&#34;: 0,
                &#34;taskFlags&#34;: {
                    &#34;disabled&#34;: False
                }
            }, &#34;subTasks&#34;: [
                {
                    &#34;subTaskOperation&#34;: 1, &#34;subTask&#34;: {
                        &#34;subTaskType&#34;: 1, &#34;operationType&#34;: 4007
                    },
                    &#34;options&#34;: {
                        &#34;backupOpts&#34;: {
                            &#34;mediaOpt&#34;: {
                                &#34;auxcopyJobOption&#34;: {
                                    &#34;maxNumberOfStreams&#34;: 0,
                                    &#34;allCopies&#34;: True,
                                    &#34;useMaximumStreams&#34;: True,
                                    &#34;useScallableResourceManagement&#34;: use_scalable,
                                    &#34;mediaAgent&#34;: {
                                        &#34;mediaAgentName&#34;: &#34;&#34;
                                    }
                                }
                            }
                        }, &#34;adminOpts&#34;: {
                            &#34;archiveCheckOption&#34;: {
                                &#34;ddbVerificationLevel&#34;: ddb_ver_level,
                                &#34;jobsToVerify&#34;: 0,
                                &#34;allCopies&#34;: True,
                                &#34;backupLevel&#34;: ver_type,
                                &#34;ocl&#34;: orphan_chunk_listing,
                                &#34;runDefrag&#34;: run_defrag
                            }
                        }
                    }
                }
            ]
        }
    }
    data_verf = self._commcell_object._services[&#39;CREATE_TASK&#39;]
    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, data_verf, request
    )

    if flag:
        if response.json():
            if &#34;jobIds&#34; in response.json():
                return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
            elif &#34;errorCode&#34; in response.json():
                error_message = response.json()[&#39;errorMessage&#39;]

                o_str = &#39;DDB verification job failed\nError: &#34;{0}&#34;&#39;.format(error_message)
                raise SDKException(&#39;Storage&#39;, &#39;102&#39;, o_str)
            else:
                raise SDKException(&#39;Storage&#39;, &#39;109&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.run_recon"><code class="name flex">
<span>def <span class="ident">run_recon</span></span>(<span>self, copy_name, sp_name, store_id, full_reconstruction=0, use_scalable_resource='false')</span>
</code></dt>
<dd>
<div class="desc"><p>Runs non-mem DB Reconstruction job</p>
<h2 id="args">Args</h2>
<p>copy_name
(str)
&ndash;
name of the storage policy copy</p>
<p>sp_name
(str)
&ndash;
name of the storage policy</p>
<p>store_id
(str)
&ndash;
SIDB store id associated with the copy</p>
<p>full_reconstruction
(int)
&ndash;
flag to enable full reconstruction job
Valid values:
0: to start regular reconstruction job
1: to start full reconstruction job</p>
<p>use_scalable_resource
(str)
&ndash;
to enable scalable resources
Valid values:
'true': to start old way reconstruction job
'false': to start reconstruction job with scalable resources</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3117-L3170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run_recon(self, copy_name, sp_name, store_id, full_reconstruction=0, use_scalable_resource=&#39;false&#39;):
    &#34;&#34;&#34; Runs non-mem DB Reconstruction job

        Args:
           copy_name    (str)  --  name of the storage policy copy

           sp_name      (str)  --  name of the storage policy

           store_id     (str)  --  SIDB store id associated with the copy

           full_reconstruction      (int)  --  flag to enable full reconstruction job
                                               Valid values:
                                               0: to start regular reconstruction job
                                               1: to start full reconstruction job

           use_scalable_resource    (str)  --  to enable scalable resources
                                               Valid values:
                                               &#39;true&#39;: to start old way reconstruction job
                                               &#39;false&#39;: to start reconstruction job with scalable resources
    &#34;&#34;&#34;
    request_xml = &#34;&#34;&#34;
    &lt;TMMsg_DedupSyncTaskReq flags=&#34;0&#34;&gt;
        &lt;taskInfo&gt;&lt;associations _type_=&#34;0&#34; appName=&#34;&#34; applicationId=&#34;0&#34; backupsetId=&#34;0&#34; backupsetName=&#34;&#34;
        clientId=&#34;0&#34; clientName=&#34;&#34; clientSidePackage=&#34;1&#34; commCellId=&#34;0&#34; consumeLicense=&#34;1&#34; copyName=&#34;{0}&#34;
        instanceId=&#34;1&#34; instanceName=&#34;&#34; srmReportSet=&#34;0&#34; srmReportType=&#34;0&#34; storagePolicyName=&#34;{1}&#34;
        subclientId=&#34;0&#34; subclientName=&#34;&#34; type=&#34;0&#34;/&gt;
        &lt;subTasks&gt;
            &lt;options&gt;
                &lt;adminOpts&gt;
                    &lt;contentIndexingOption subClientBasedAnalytics=&#34;0&#34;/&gt;
                    &lt;dedupDBSyncOption SIDBStoreId=&#34;{2}&#34;/&gt;
                    &lt;reconstructDedupDBOption allowMaximum=&#34;0&#34; flags=&#34;{4}&#34; noOfStreams=&#34;0&#34; useScallableResourceManagement=&#34;{3}&#34;&gt;
                    &lt;mediaAgent _type_=&#34;11&#34; mediaAgentId=&#34;0&#34; mediaAgentName=&#34;&amp;lt;ANY MEDIAAGENT&gt;&#34;/&gt;
                    &lt;/reconstructDedupDBOption&gt;
                &lt;/adminOpts&gt;
                &lt;restoreOptions&gt;
                    &lt;virtualServerRstOption isBlockLevelReplication=&#34;0&#34;/&gt;
                &lt;/restoreOptions&gt;
            &lt;/options&gt;
            &lt;subTask operationType=&#34;4036&#34; subTaskType=&#34;1&#34;/&gt;
        &lt;/subTasks&gt;
        &lt;task initiatedFrom=&#34;1&#34; ownerId=&#34;1&#34; ownerName=&#34;admin&#34; policyType=&#34;0&#34; sequenceNumber=&#34;0&#34;
        taskId=&#34;0&#34; taskType=&#34;1&#34;&gt;&lt;taskFlags disabled=&#34;0&#34;/&gt;
        &lt;/task&gt;
        &lt;/taskInfo&gt;
    &lt;/TMMsg_DedupSyncTaskReq&gt;
    &#34;&#34;&#34;.format(copy_name, sp_name, store_id, use_scalable_resource, full_reconstruction)
    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_xml
    )

    if flag:
        if response.json():
            return response.json()</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.run_snapshot_cataloging"><code class="name flex">
<span>def <span class="ident">run_snapshot_cataloging</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Runs the deferred catalog job from Commcell for the given storage policy</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the Job class for this snapshot cataloging job</p>
<h2 id="raises">Raises</h2>
<p>SDKException:</p>
<pre><code>    if snapshot cataloging job failed

    if response is empty

    if response is not success
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2158-L2235" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def run_snapshot_cataloging(self):
    &#34;&#34;&#34;
    Runs the deferred catalog job from Commcell for the given storage policy

    Args:
            None

    Returns:
            object - instance of the Job class for this snapshot cataloging job

    Raises:
        SDKException:

                if snapshot cataloging job failed

                if response is empty

                if response is not success
    &#34;&#34;&#34;

    request_json = {
        &#34;taskInfo&#34;: {
            &#34;associations&#34;: [
                {
                    &#34;storagePolicyName&#34;: self.storage_policy_name
                }
            ],
            &#34;task&#34;: {
                &#34;taskType&#34;: 1,
                &#34;initiatedFrom&#34;: 2,
                &#34;policyType&#34;: 0,
                &#34;taskFlags&#34;: {
                    &#34;isEdgeDrive&#34;: False,
                    &#34;disabled&#34;: False
                }
            },
            &#34;subTasks&#34;: [
                {
                    &#34;subTaskOperation&#34;: 1,
                    &#34;subTask&#34;: {
                        &#34;subTaskType&#34;: 1,
                        &#34;operationType&#34;: 4043
                    },
                    &#34;options&#34;: {
                        &#34;backupOpts&#34;: {
                            &#34;backupLevel&#34;: 2,
                            &#34;dataOpt&#34;: {
                                &#34;useCatalogServer&#34;: True,
                                &#34;enforceTransactionLogUsage&#34;: False
                            }
                        }
                    }
                }
            ]
        }
    }

    snapshot_catalog = self._commcell_object._services[&#39;CREATE_TASK&#39;]
    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, snapshot_catalog, request_json)

    if flag:
        if response.json():
            if &#34;jobIds&#34; in response.json():
                return Job(self._commcell_object, response.json()[&#39;jobIds&#39;][0])
            elif &#34;errorCode&#34; in response.json():
                error_message = response.json()[&#39;errorMessage&#39;]

                o_str = &#39;Deferred catalog job failed\nError: &#34;{0}&#34;&#39;.format(
                    error_message)
                raise SDKException(&#39;Storage&#39;, &#39;107&#39;, o_str)
            else:
                raise SDKException(&#39;Storage&#39;, &#39;107&#39;, &#39;Failed to run the deferred catalog job&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;107&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.seal_ddb"><code class="name flex">
<span>def <span class="ident">seal_ddb</span></span>(<span>self, copy_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Seals the deduplication database</p>
<pre><code>Args:
    copy_name   (str)   --  name of the storage policy copy

Raises:
    SDKException:
        if type of input parameters is not string
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2442-L2465" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seal_ddb(self, copy_name):
    &#34;&#34;&#34;
    Seals the deduplication database

        Args:
            copy_name   (str)   --  name of the storage policy copy

        Raises:
            SDKException:
                if type of input parameters is not string
    &#34;&#34;&#34;
    if not isinstance(copy_name, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    request_xml = &#34;&#34;&#34;
    &lt;App_SealSIDBStoreReq&gt;
        &lt;archiveGroupCopy&gt;
            &lt;copyName&gt;{0}&lt;/copyName&gt;
            &lt;storagePolicyName&gt;{1}&lt;/storagePolicyName&gt;
        &lt;/archiveGroupCopy&gt;
    &lt;/App_SealSIDBStoreReq&gt;

    &#34;&#34;&#34;.format(copy_name, self.storage_policy_name)
    self._commcell_object._qoperation_execute(request_xml)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.start_over"><code class="name flex">
<span>def <span class="ident">start_over</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>performs a start over operation on the specified storage policy/gdsp</p>
<pre><code>Args:

Raises:
      SDKException -- if response is bad/ flag is false
</code></pre>
<p>returns None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3215-L3259" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def start_over(self):
    &#34;&#34;&#34;
    performs a start over operation on the specified storage policy/gdsp

        Args:

        Raises:
              SDKException -- if response is bad/ flag is false

    returns None
    &#34;&#34;&#34;
    dependent_flag = self.storage_policy_properties[&#34;copy&#34;][0][&#34;dedupeFlags&#34;].get(&#34;useGlobalDedupStore&#34;, 0)
    if dependent_flag == 1:
        raise Exception(&#34;Dependent policy cannot be started over ...&#34;)

    request = {
        &#34;MediaManager_MMStartOverReq&#34;: {
                &#34;bSealDDB&#34;: True,
                &#34;storagePolicy&#34;: {
                    &#34;storagePolicyName&#34;: self.storage_policy_name
                }
            }
        }

    startover = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, startover, request
    )

    if flag:
        if response.json():
            if &#39;errorCode&#39; in response.json():
                error_code = int(response.json()[&#39;errorCode&#39;])
                if error_code != 0:
                    error_message = &#34;Failed to Start Over&#34;
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)
    self.refresh()</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.update_snapshot_options"><code class="name flex">
<span>def <span class="ident">update_snapshot_options</span></span>(<span>self, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Method for Updating Storage Policy Snapshot Options like Backup Copy and Snapshot Catalog</p>
<h2 id="args">Args</h2>
<p>Available Snapshot Options:</p>
<p>enable_backup_copy
(bool)
&ndash;
Enables backup copy if the value is True</p>
<p>source_copy_for_snap_to_tape
(str)
&ndash;
Source Copy name for backup copy</p>
<p>enable_snapshot_catalog
(bool)
&ndash;
Enables Snapshot Catalog if value is True</p>
<p>source_copy_for_snapshot_catalog (str)
&ndash;
Source Copy name for Snapshot Catalog</p>
<p>is_ocum
(bool)
&ndash;
True if Storage policy is enabled with
ocum server
enable_selective_copy
(int)
&ndash; Enable selective copy option based on input value</p>
<p>disassociate_sc_from_backup_copy
(bool)
&ndash; Associate/Disassociate subclient from backup copy
True: Disassociate subclient
False: Associate subclient</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L1917-L2063" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update_snapshot_options(self, **options):
    &#34;&#34;&#34;
    Method for Updating Storage Policy Snapshot Options like Backup Copy and Snapshot Catalog

    Args:
        Available Snapshot Options:

        enable_backup_copy               (bool)   --  Enables backup copy if the value is True

        source_copy_for_snap_to_tape     (str)    --  Source Copy name for backup copy

        enable_snapshot_catalog          (bool)   --  Enables Snapshot Catalog if value is True

        source_copy_for_snapshot_catalog (str)    --  Source Copy name for Snapshot Catalog

        is_ocum                          (bool)   --  True if Storage policy is enabled with
                                                      ocum server
        enable_selective_copy                 (int)   -- Enable selective copy option based on input value

        disassociate_sc_from_backup_copy    (bool)    -- Associate/Disassociate subclient from backup copy
                                                            True: Disassociate subclient
                                                            False: Associate subclient

    &#34;&#34;&#34;
    enable_backup_copy = options[&#39;enable_backup_copy&#39;]
    enable_snapshot_catalog = options[&#39;enable_snapshot_catalog&#39;]

    if options[&#39;is_ocum&#39;]:
        if enable_backup_copy and enable_snapshot_catalog:
            defferred_catalog_value = backup_copy_value = 16
        else:
            defferred_catalog_value = backup_copy_value = 3
    else:
        if enable_backup_copy:
            defferred_catalog_value = 16
            backup_copy_value = 3
        else:
            defferred_catalog_value = backup_copy_value = 3

    if options[&#39;source_copy_for_snap_to_tape&#39;] is not None:
        source_copy_for_snap_to_tape_id = self._copies[options[&#39;source_copy_for_snap_to_tape&#39;].lower()][&#39;copyId&#39;]
    else:
        source_copy_for_snap_to_tape_id = 0
    if options[&#39;source_copy_for_snapshot_catalog&#39;] is not None:
        source_copy_for_snapshot_catalog_id = self._copies[options[&#39;source_copy_for_snapshot_catalog&#39;].lower(
        )][&#39;copyId&#39;]
    else:
        source_copy_for_snapshot_catalog_id = 0

    selective_type = options.get(&#39;enable_selective_copy&#39;, 0)

    update_snapshot_tab_service = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

    if options[&#39;disassociate_sc_from_backup_copy&#39;] == True:
        disass_sc_xml = f&#34;&#34;&#34;
                           &lt;archGroupToAppListWithExclude _type_=&#34;2&#34;&gt;
                                &lt;flags include=&#34;1&#34;/&gt;
                           &lt;/archGroupToAppListWithExclude&gt;
                           &lt;archGroupToAppListWithExclude _type_=&#34;27&#34;&gt;
                                &lt;flags include=&#34;1&#34;/&gt;
                           &lt;/archGroupToAppListWithExclude&gt;
                       &lt;archGroupToAppListWithExclude _type_=&#34;7&#34; 
                       appName=&#34;{options[&#39;appName&#39;]}&#34; applicationId=&#34;{options[&#39;applicationId&#39;]}&#34;
                            backupsetId=&#34;{options[&#39;backupsetId&#39;]}&#34; backupsetName=&#34;{options[&#39;backupsetName&#39;]}&#34; 
                            clientId=&#34;{options[&#39;clientId&#39;]}&#34; clientName=&#34;{options[&#39;clientName&#39;]}&#34; instanceId=&#34;1&#34; 
                            instanceName=&#34;DefaultInstanceName&#34; 
                            subclientId=&#34;{options[&#39;subclientId&#39;]}&#34; subclientName=&#34;{options[&#39;subclientName&#39;]}&#34;&gt;
                            &lt;flags exclude=&#34;1&#34;/&gt;
                       &lt;/archGroupToAppListWithExclude&gt;&#34;&#34;&#34;

        request_xml = f&#34;&#34;&#34;
                    &lt;EVGui_SetSnapOpPropsReq deferredCatalogOperation=&#34;{defferred_catalog_value}&#34; snapshotToTapeOperation=&#34;{backup_copy_value}&#34;&gt;
                        &lt;header localeId=&#34;0&#34; userId=&#34;0&#34; /&gt;
                        &lt;snapshotToTapeProps archGroupId=&#34;{self.storage_policy_id}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                            enable=&#34;{int(enable_backup_copy)}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                            sourceCopyId=&#34;{source_copy_for_snap_to_tape_id}&#34; startTime=&#34;0&#34; type=&#34;{selective_type}&#34; &gt; &#34;&#34;&#34;.format(
                                defferred_catalog_value,
                                backup_copy_value,
                                self.storage_policy_id,
                                int(enable_backup_copy),
                                source_copy_for_snap_to_tape_id, selective_type) + \
                      f&#34;&#34;&#34;{disass_sc_xml}
                        &lt;/snapshotToTapeProps&gt;                           
                    &lt;/EVGui_SetSnapOpPropsReq&gt;
                       &#34;&#34;&#34;

    elif options[&#39;disassociate_sc_from_backup_copy&#39;] == False:
        disass_sc_xml = f&#34;&#34;&#34;
                        &lt;archGroupToAppListWithExclude _type_=&#34;2&#34;&gt;
                                        &lt;flags include=&#34;1&#34;/&gt;
                                       &lt;/archGroupToAppListWithExclude&gt;
                                       &lt;archGroupToAppListWithExclude _type_=&#34;27&#34;&gt;
                                        &lt;flags include=&#34;1&#34;/&gt;
                                       &lt;/archGroupToAppListWithExclude&gt;&#34;&#34;&#34;

        request_xml = &#34;&#34;&#34;
                    &lt;EVGui_SetSnapOpPropsReq deferredCatalogOperation=&#34;{0}&#34; snapshotToTapeOperation=&#34;{1}&#34;&gt;
                                       &lt;header localeId=&#34;0&#34; userId=&#34;0&#34; /&gt;
                                       &lt;snapshotToTapeProps archGroupId=&#34;{2}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                           enable=&#34;{3}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                           sourceCopyId=&#34;{4}&#34; startTime=&#34;0&#34; type=&#34;{5}&#34; &gt; &#34;&#34;&#34;.format(
                    defferred_catalog_value,
                    backup_copy_value, self.storage_policy_id,
                    int(enable_backup_copy), source_copy_for_snap_to_tape_id, selective_type) + \
                    f&#34;&#34;&#34;{disass_sc_xml}
                                    &lt;/snapshotToTapeProps&gt;                                                                    
                                &lt;/EVGui_SetSnapOpPropsReq&gt;
                       &#34;&#34;&#34;
    elif options[&#39;disassociate_sc_from_backup_copy&#39;] is None:
        request_xml = &#34;&#34;&#34;
                    &lt;EVGui_SetSnapOpPropsReq deferredCatalogOperation=&#34;{0}&#34; snapshotToTapeOperation=&#34;{1}&#34;&gt;
                                           &lt;header localeId=&#34;0&#34; userId=&#34;0&#34; /&gt;
                                           &lt;snapshotToTapeProps archGroupId=&#34;{2}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                               enable=&#34;{3}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                               sourceCopyId=&#34;{4}&#34; startTime=&#34;0&#34; type=&#34;{7}&#34; /&gt;
                                           &lt;deferredCatalogProps archGroupId=&#34;{2}&#34; calendarId=&#34;1&#34; dayNumber=&#34;0&#34; deferredDays=&#34;0&#34;
                                               enable=&#34;{5}&#34; flags=&#34;0&#34; infoFlags=&#34;0&#34; numOfReaders=&#34;0&#34; numPeriod=&#34;1&#34;
                                               sourceCopyId=&#34;{6}&#34; startTime=&#34;0&#34; type=&#34;0&#34; /&gt;
                                       &lt;/EVGui_SetSnapOpPropsReq&gt;
                           &#34;&#34;&#34;.format(defferred_catalog_value, backup_copy_value, self.storage_policy_id,
                                      int(enable_backup_copy), source_copy_for_snap_to_tape_id,
                                      int(enable_snapshot_catalog), source_copy_for_snapshot_catalog_id,
                                      selective_type)


    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, update_snapshot_tab_service, request_xml
    )

    self.refresh()

    if flag:
        if response.json():
            if &#39;error&#39; in response.json():
                error_code = int(response.json()[&#39;error&#39;][&#39;errorCode&#39;])
                if error_code != 1:
                    error_message = &#34;Failed to Update {0} Storage Policy&#34;.format(
                        self.storage_policy_name
                    )
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicy.update_transactional_ddb"><code class="name flex">
<span>def <span class="ident">update_transactional_ddb</span></span>(<span>self, update_value, copy_name, media_agent_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates TransactionalDDB option on the deduplication database</p>
<pre><code>Args:
    update_value    (bool)   --   enable(True)/disable(False)

    copy_name       (str)   --   name of the associated copy

    media_agent_name(str)   --   name of the media agent

Raises:
    SDKException:
        if type of input parameters is not string
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L2467-L2508" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update_transactional_ddb(self, update_value, copy_name, media_agent_name):
    &#34;&#34;&#34;
    Updates TransactionalDDB option on the deduplication database

        Args:
            update_value    (bool)   --   enable(True)/disable(False)

            copy_name       (str)   --   name of the associated copy

            media_agent_name(str)   --   name of the media agent

        Raises:
            SDKException:
                if type of input parameters is not string
    &#34;&#34;&#34;
    if not (isinstance(copy_name, str) and isinstance(media_agent_name, str)):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    request_xml = &#34;&#34;&#34;
    &lt;App_UpdateStoragePolicyCopyReq &gt;
        &lt;storagePolicyCopyInfo &gt;
            &lt;StoragePolicyCopy&gt;
                &lt;copyName&gt;{0}&lt;/copyName&gt;
                &lt;storagePolicyName&gt;{1}&lt;/storagePolicyName&gt;
            &lt;/StoragePolicyCopy&gt;
            &lt;DDBPartitionInfo&gt;
                &lt;maInfoList&gt;
                    &lt;mediaAgent&gt;
                        &lt;mediaAgentName&gt;{2}&lt;/mediaAgentName&gt;
                    &lt;/mediaAgent&gt;
                        &lt;/maInfoList&gt;
                        &lt;sidbStoreInfo&gt;
                            &lt;sidbStoreFlags&gt;
                        &lt;enableTransactionalDDB&gt;{3}&lt;/enableTransactionalDDB&gt;
                    &lt;/sidbStoreFlags&gt;
                        &lt;/sidbStoreInfo&gt;
                &lt;/DDBPartitionInfo&gt;
       &lt;/storagePolicyCopyInfo&gt;
    &lt;/App_UpdateStoragePolicyCopyReq&gt;
    &#34;&#34;&#34;.format(copy_name, self.storage_policy_name, media_agent_name, int(update_value))

    self._commcell_object._qoperation_execute(request_xml)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy"><code class="flex name class">
<span>class <span class="ident">StoragePolicyCopy</span></span>
<span>(</span><span>commcell_object, storage_policy, copy_name, copy_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for performing storage policy copy operations for a specific storage policy copy</p>
<p>Initialise the Storage Policy Copy class instance.</p>
<h2 id="args">Args</h2>
<p>commcell_object (object)
&ndash;
instance of the Commcell class
storage_policy
(str/object)
&ndash; storage policy to which copy is associated with
copy_name
(str)
&ndash; copy name
copy_id
(str)
&ndash; copy ID
Default : None</p>
<h2 id="returns">Returns</h2>
<p>object - instance of the StoragePolicyCopy class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3376-L4777" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class StoragePolicyCopy(object):
    &#34;&#34;&#34;Class for performing storage policy copy operations for a specific storage policy copy&#34;&#34;&#34;

    def __init__(self, commcell_object, storage_policy, copy_name, copy_id=None):
        &#34;&#34;&#34;Initialise the Storage Policy Copy class instance.

            Args:
                commcell_object (object)        --  instance of the Commcell class
                storage_policy  (str/object)    -- storage policy to which copy is associated with
                copy_name       (str)           -- copy name
                copy_id         (str)           -- copy ID
                Default : None

            Returns:
                object - instance of the StoragePolicyCopy class

        &#34;&#34;&#34;
        self._copy_name = copy_name.lower()
        self._commcell_object = commcell_object
        self._cvpysdk_object = self._commcell_object._cvpysdk_object
        self._services = self._commcell_object._services

        if isinstance(storage_policy, StoragePolicy):
            self.storage_policy = storage_policy
        else:
            self.storage_policy = StoragePolicy(self._commcell_object, storage_policy)

        self.storage_policy_id = self.storage_policy.storage_policy_id
        self._storage_policy_name = self.storage_policy.storage_policy_name
        self.storage_policy._initialize_storage_policy_properties()

        if copy_id is not None:
            self.copy_id = str(copy_id)
        else:
            self.copy_id = str(self.get_copy_id())

        self._copy_properties = None
        self._STORAGE_POLICY_COPY = self._services[&#39;STORAGE_POLICY_COPY&#39;] % (
            self.storage_policy_id, self.copy_id)
        self.refresh()

    def __repr__(self):
        &#34;&#34;&#34;String representation of the instance of this class.&#34;&#34;&#34;
        representation_string = &#39;Storage Policy Copy class instance for Storage Policy/ Copy: &#34;{0}/{1}&#34;&#39;
        return representation_string.format(self._storage_policy_name, self._copy_name)

    @property
    def all_copies(self):
        &#34;&#34;&#34;Returns dict of  the storage policy copy associated with this storage policy

            dict - consists of stoarge policy copy properties
                    &#34;copyType&#34;: copy_type,
                    &#34;active&#34;: active,
                    &#34;copyId&#34;: copy_id,
                    &#34;libraryName&#34;: library_name,
                    &#34;copyPrecedence&#34;: copy_precedence
        &#34;&#34;&#34;
        return self.storage_policy._copies[self._copy_name]

    def get_copy_id(self):
        &#34;&#34;&#34;Gets the storage policy id asscoiated with the storage policy&#34;&#34;&#34;
        return self.all_copies[&#34;copyId&#34;]

    def get_copy_Precedence(self):
        &#34;&#34;&#34;Gets the copyprecendence asscoiated with the storage policy copy&#34;&#34;&#34;
        return self.all_copies[&#34;copyPrecedence&#34;]

    @property
    def is_active(self):
        &#34;&#34;&#34;Gets whether the Storage Policy Copy is active or not&#34;&#34;&#34;
        return bool(self._copy_properties.get(&#39;active&#39;))

    @is_active.setter
    def is_active(self, active):
        &#34;&#34;&#34;Marks the Storage Policy Copy as active/inactive (True/False)
            Args:
                active    (bool):    mark the Storage Policy Copy as active/inactive (True/False)

            Raises:
                SDKException:
                    if failed to update the property

                    if the type of &#39;active&#39; input is not correct
        &#34;&#34;&#34;
        if not isinstance(active, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_properties[&#39;active&#39;] = int(active)
        self._set_copy_properties()

    def refresh(self):
        &#34;&#34;&#34;Refresh the properties of the StoragePolicy.&#34;&#34;&#34;
        self._get_copy_properties()

    def _get_request_json(self):
        &#34;&#34;&#34; Gets all the storage policy copy properties .

           Returns:
                dict - all storage policy copy properties put inside a dict

        &#34;&#34;&#34;
        self._copy_properties[&#34;StoragePolicyCopy&#34;][&#34;storagePolicyName&#34;] = self._storage_policy_name
        copy_json = {
            &#34;storagePolicyCopyInfo&#34;: self._copy_properties
        }
        return copy_json

    def _get_copy_properties(self):
        &#34;&#34;&#34;Gets the storage policy copy properties.

            Raises:
                SDKException:
                    if response is empty

                    if response is not success
        &#34;&#34;&#34;

        flag, response = self._cvpysdk_object.make_request(&#39;GET&#39;, self._STORAGE_POLICY_COPY)
        if flag:
            if response.json() and &#39;copy&#39; in response.json():
                self._copy_properties = response.json()[&#39;copy&#39;]

                self._storage_policy_flags = self._copy_properties.get(&#39;StoragePolicyFlags&#39;)

                self._copy_flags = self._copy_properties.get(&#39;copyFlags&#39;)

                self._extended_flags = self._copy_properties.get(&#39;extendedFlags&#39;)

                self._data_path_config = self._copy_properties.get(&#39;dataPathConfiguration&#39;)

                self._media_properties = self._copy_properties.get(&#39;mediaProperties&#39;)

                self._retention_rules = self._copy_properties.get(&#39;retentionRules&#39;)

                self._data_encryption = self._copy_properties.get(&#39;dataEncryption&#39;)

                self._dedupe_flags = self._copy_properties.get(&#39;dedupeFlags&#39;)

                self._media_agent = self._copy_properties.get(&#39;mediaAgent&#39;)

            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, self._commcell_object._update_response_(response.text))

    def _set_copy_properties(self):
        &#34;&#34;&#34;sets the properties of this storage policy copy.

            Raises:
                SDKException:
                    if failed to update number properties for subclient

        &#34;&#34;&#34;
        request_json = self._get_request_json()
        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._STORAGE_POLICY_COPY,
                                                           request_json)
        self.refresh()
        if flag:
            if response.json():
                if &#34;response&#34; in response.json():
                    error_code = str(
                        response.json()[&#34;response&#34;][0][&#34;errorCode&#34;])

                    if error_code == &#34;0&#34;:
                        return True, &#34;0&#34;, &#34;&#34;
                    else:
                        error_message = &#34;&#34;

                        if &#34;errorString&#34; in response.json()[&#34;response&#34;][0]:
                            error_message = response.json(
                            )[&#34;response&#34;][0][&#34;errorString&#34;]

                        if error_message:
                            return (False, error_code, error_message)
                        else:
                            return (False, error_code, &#34;&#34;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;111&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    @property
    def copy_name(self):
        &#34;&#34;&#34;Returns the name of the copy&#34;&#34;&#34;
        return self._copy_name

    @property
    def override_pool_retention(self):
        &#34;&#34;&#34;Returns if Override Pool Retention flag is set or not&#34;&#34;&#34;
        return bool(self._extended_flags.get(&#39;overRideGACPRetention&#39;, 0))

    @override_pool_retention.setter
    def override_pool_retention(self, override):
        &#34;&#34;&#34;Sets/Unsets the override Pool Retention Flag. Not Applicable for Storage Pool Copies

        Args:
            override(bool)  :   Override the pool Retention (True/False)
        &#34;&#34;&#34;
        self._extended_flags[&#39;overRideGACPRetention&#39;] = int(override)
        self._set_copy_properties()

    @property
    def copy_retention(self):
        &#34;&#34;&#34;Treats the copy retention as a read-only attribute.&#34;&#34;&#34;
        retention_values = {}
        retention_values[&#34;days&#34;] = self._retention_rules[&#39;retainBackupDataForDays&#39;]
        retention_values[&#34;cycles&#34;] = self._retention_rules[&#39;retainBackupDataForCycles&#39;]
        retention_values[&#34;archiveDays&#34;] = self._retention_rules[&#39;retainArchiverDataForDays&#39;]
        retention_values[&#34;jobs&#34;] = self._retention_rules[&#39;jobs&#39;]
        return retention_values

    @copy_retention.setter
    def copy_retention(self, retention_values):
        &#34;&#34;&#34;Sets the copy retention as the value provided as input.
            Args:
                retention_values    (tuple) --  retention values to be set on a copy

                    tuple:

                        **int** -   value to specify retainBackupDataForDays

                        **int** -   value to specify retainBackupDataForCycles

                        **int** -   value to specify retainArchiverDataForDays

                        **int** -   value to specify jobs

                    e.g. :
                         storage_policy_copy.copy_retention = (30, 15, 1, 8)

            Raises:
                SDKException:
                    if failed to update retention values on the copy

        &#34;&#34;&#34;
        if retention_values[0] &gt;= 0:
            self._retention_rules[&#39;retainBackupDataForDays&#39;] = retention_values[0]
        if retention_values[1] &gt;= 0:
            self._retention_rules[&#39;retainBackupDataForCycles&#39;] = retention_values[1]
        if retention_values[2] &gt;= 0:
            self._retention_rules[&#39;retainArchiverDataForDays&#39;] = retention_values[2]
        if len(retention_values) &gt; 3:
            self._retention_rules[&#39;jobs&#39;] = retention_values[3]
            if retention_values[3] &gt; 0:
                self._retention_rules[&#39;retentionFlags&#39;][&#39;jobBasedRetention&#39;] = 1
            else:
                self._retention_rules[&#39;retentionFlags&#39;][&#39;jobBasedRetention&#39;] = 0

        self._set_copy_properties()

    @property
    def copy_software_compression(self):
        &#34;&#34;&#34;Treats the copy software compression setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;compressionOnClients&#39; in self._extended_flags

    def set_copy_software_compression(self, value):
        &#34;&#34;&#34;Sets the copy software compression setting as the value provided as input.
            Args:
                value    (bool) --  software compression value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update compression values on copy

                    if the type of value input is not correct

        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if value is False:
            if &#39;compressionOnClients&#39; in self._extended_flags:
                self._extended_flags[&#39;compressionOnClients&#39;] = 0

        self._extended_flags[&#39;compressionOnClients&#39;] = int(value)
        self._set_copy_properties()

    @property
    def copy_dedupe_dash_full(self):
        &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;enableDASHFull&#39; in self._dedupe_flags

    @copy_dedupe_dash_full.setter
    def copy_dedupe_dash_full(self, value):
        &#34;&#34;&#34;Sets the copy deduplication setting as the value provided as input.
            Args:
                value    (bool) --  dash full value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update deduplication values on copy

                    if the type of value input is not correct

        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if value is False:
            if &#39;enableSourceSideDiskCache&#39; in self._dedupe_flags:
                self._dedupe_flags[&#39;enableSourceSideDiskCache&#39;] = 0

        self._dedupe_flags[&#39;enableDASHFull&#39;] = int(value)
        self._set_copy_properties()

    @property
    def copy_dedupe_disk_cache(self):
        &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;enableSourceSideDiskCache&#39; in self._dedupe_flags

    @copy_dedupe_disk_cache.setter
    def copy_dedupe_disk_cache(self, value):
        &#34;&#34;&#34;Sets the copy deduplication setting as the value provided as input.
            Args:
                value    (bool) --  disk cache value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update deduplication values on copy

                    if the type of value input is not correct
        &#34;&#34;&#34;

        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        self._dedupe_flags[&#39;enableSourceSideDiskCache&#39;] = int(value)

        self._set_copy_properties()

    @property
    def store_priming(self):
        &#34;&#34;&#34;Treats the copy store priming setting as a read-only attribute.&#34;&#34;&#34;
        return self._dedupe_flags.get(&#39;useDDBPrimingOption&#39;, 0) &gt; 0

    @store_priming.setter
    def store_priming(self, value):
        &#34;&#34;&#34;Sets the copy store priming setting as the value provided as input.
            Args:
                value    (bool) --  store priming flag to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update deduplication values on copy

                    if the type of value input is not correct

        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._dedupe_flags[&#39;useDDBPrimingOption&#39;] = int(value)

        self._set_copy_properties()

    @property
    def copy_client_side_dedup(self):
        &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;enableClientSideDedup&#39; in self._dedupe_flags

    @copy_client_side_dedup.setter
    def copy_client_side_dedup(self, value):
        &#34;&#34;&#34;Sets the copy deduplication setting as the value provided as input.
            Args:
                value    (bool) --  client side dedupe value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update deduplication values on copy

                    if the type of value input is not correct

        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._dedupe_flags[&#39;enableClientSideDedup&#39;] = int(value)

        self._set_copy_properties()

    def is_dedupe_enabled(self):
        &#34;&#34;&#34;
        checks whether deduplication is enabled on the give storage policy copy
        returns Boolean
        &#34;&#34;&#34;
        return bool(self._dedupe_flags.get(&#39;enableDeduplication&#39;, 0))

    @property
    def source_copy(self):
        &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
        return self._copy_properties.get(&#39;sourceCopy&#39;, {}).get(&#39;copyName&#39;)

    @source_copy.setter
    def source_copy(self, copy_name):
        &#34;&#34;&#34;Sets the source copy as provided in the input.

                    Args:
                    copy_name            (str)       name of the source copy

                    Raises:
                        SDKException:
                            if failed to update source on copy

                            if the type of input is not correct

        **************************************************************************************
        eg :-
                tertiary_copy.source_copy = &#34;secondary_copy&#34;

        &#34;&#34;&#34;
        policy = self._commcell_object.storage_policies.get(self._storage_policy_name)
        copy = policy.get_copy(copy_name)

        if not isinstance(copy_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if not self._copy_properties.get(&#39;sourceCopy&#39;, False):
            self._copy_properties[&#39;sourceCopy&#39;] = {}

        self._copy_properties[&#39;sourceCopy&#39;][&#39;copyId&#39;] = copy.get_copy_id()
        self._copy_properties[&#39;sourceCopy&#39;][&#39;copyName&#39;] = copy.copy_name

        self._set_copy_properties()

    def set_encryption_properties(self, **props):
        &#34;&#34;&#34;sets copy encryption properties based on given inputs

            Args:

                **props         dict of keyword arguments as follows:

                    preserve            (Bool)      whether to set preserve source encryption or not    default:False

                    plain_text          (Bool)      whether to store as plaintext or not                default:False

                    network_encryption       (Bool)      whether to set network encryption or not       default:False

                    re_encryption          (Bool)      whether to set re-encryption or not              default:False

                    encryption_type            (str)       encryption type specification             default:&#34;BlowFish&#34;

                    encryption_length          (int)       encryption key length specification          default:128

            Returns:
                  SDKException:
                            if failed to set copy encryption
                            if the type of inputs are not correct

            ***********************************************************************************************************

            to preserve encryption --&gt; set_encryption_properties(preserve=True)

            to store as plaintext --&gt; set_encryption_properties(plaintext=True)

            to set network encryption --&gt; set_encryption_properties(plaintext=True, network_encryption=True,
                                                                    encryption_type=&#34;BlowFish&#34;, encryption_length=128)

            to set re-encryption --&gt; set_encryption_properties(re_encryption=True,
                                                               encryption_type=&#34;BlowFish&#34;, encryption_length=128)

            ***********************************************************************************************************

            &lt;Encryption_type&gt;   &lt;Encryption_length&gt;

            &#34;Blowfish&#34;                  128
            &#34;Blowfish&#34;                  256
            &#34;TwoFish&#34;                   128
            &#34;TwoFish&#34;                   256
            &#34;Serpent&#34;                   128
            &#34;Serpent&#34;                   256
            &#34;GOST&#34;                      256
            &#34;AES&#34;                       128
            &#34;AES&#34;                       256
            &#34;DES3&#34;                      192
        &#34;&#34;&#34;
        preserve = props.get(&#39;preserve&#39;, False)
        plain_text = props.get(&#39;plain_text&#39;, False)
        network_encryption = props.get(&#39;network_encryption&#39;, False)
        re_encryption = props.get(&#39;re_encryption&#39;, False)
        encryption_type = props.get(&#39;encryption_type&#39;, &#39;BlowFish&#39;)
        encryption_length = props.get(&#39;encryption_length&#39;, 128)

        if not isinstance(preserve, bool) or \
                not isinstance(plain_text, bool) or \
                not isinstance(network_encryption, bool) or \
                not isinstance(re_encryption, bool) or \
                not isinstance(encryption_type, str) or \
                not isinstance(encryption_length, int):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_flags[&#39;preserveEncryptionModeAsInSource&#39;] = int(preserve)
        self._copy_flags[&#39;auxCopyReencryptData&#39;] = int(re_encryption)
        self._copy_flags[&#39;storePlainText&#39;] = int(plain_text)
        self._copy_flags[&#39;encryptOnNetworkUsingSelectedCipher&#39;] = int(network_encryption)

        self._copy_properties[&#39;extendedFlags&#39;][&#39;encryptOnDependentPrimary&#39;] = 0

        if plain_text and not network_encryption:

            self._copy_properties[&#39;dataEncryption&#39;] = {}

        else:

            if &#34;dataEncryption&#34; not in self._copy_properties:
                self._copy_properties[&#34;dataEncryption&#34;] = {
                    &#34;encryptData&#34;: 0
                }
                self._data_encryption = self._copy_properties[&#34;dataEncryption&#34;]

        if re_encryption or network_encryption:

            self._data_encryption[&#39;encryptData&#39;] = 1
            self._data_encryption[&#39;encryptionType&#39;] = encryption_type
            self._data_encryption[&#39;encryptionKeyLength&#39;] = encryption_length

            if re_encryption:
                self._copy_properties[&#39;extendedFlags&#39;][&#39;encryptOnDependentPrimary&#39;] = 1

        self._set_copy_properties()

    @property
    def copy_reencryption(self):
        &#34;&#34;&#34;Treats the secondary copy encryption as a read-only attribute.&#34;&#34;&#34;
        if &#39;auxCopyReencryptData&#39; in self._copy_flags:
            if self._copy_flags[&#39;auxCopyReencryptData&#39;] == 1:
                encryption_setting = &#34;True&#34;

        if &#39;preserveEncryptionModeAsInSource&#39; in self._copy_flags:
            if self._copy_flags[&#39;preserveEncryptionModeAsInSource&#39;] == 1:
                encryption_setting = &#34;False&#34;

        return encryption_setting

    @copy_reencryption.setter
    def copy_reencryption(self, encryption_values):
        &#34;&#34;&#34;Sets the secondary copy encryption as the value provided as input.
            Args:
                encryption_values    (tuple) --  encryption values to be set on a copy

                    tuple:

                        **bool** -   value to specify encrypt data [True/False]

                        **str** -   value to specify cipher type

                        **int** -   value to specify key length [128/256]

                        **int** -   value to specify GDSP dependent copy [True/False]

                    e.g. :
                        to enable encryption:
                            storage_policy_copy.copy_reencryption = (True, &#34;TWOFISH&#34;, &#34;128&#34;, False)

                        to disable encryption:
                            storage_policy_copy.copy_reencryption = (False, &#34;&#34;,0, False)

            Raises:
                SDKException:
                    if failed to update encryption settings for copy

                    if the type of value input is not correct
        &#34;&#34;&#34;
        if &#34;dataEncryption&#34; not in self._copy_properties:
            self._copy_properties[&#34;dataEncryption&#34;] = {
                &#34;encryptData&#34;: &#34;&#34;,
                &#34;encryptionType&#34;: &#34;&#34;,
                &#34;encryptionKeyLength&#34;: &#34;&#34;}
            self._data_encryption = self._copy_properties[&#34;dataEncryption&#34;]

        if not isinstance(encryption_values[0], bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if int(encryption_values[0]) == 0:
            if int(encryption_values[3]) == 1:
                self._copy_properties[&#39;extendedFlags&#39;][&#39;encryptOnDependentPrimary&#39;] = 0
            self._copy_properties[&#34;dataEncryption&#34;] = {
                &#34;encryptData&#34;: 0
            }
            self._copy_flags[&#39;auxCopyReencryptData&#39;] = 0
            self._copy_flags[&#39;preserveEncryptionModeAsInSource&#39;] = 1

        if int(encryption_values[0]) == 1:
            if (isinstance(encryption_values[1], str)
                    and isinstance(encryption_values[2], int)):
                self._copy_properties[&#39;extendedFlags&#39;][&#39;encryptOnDependentPrimary&#39;] = 1
                self._copy_flags[&#39;auxCopyReencryptData&#39;] = 1
                self._copy_flags[&#39;preserveEncryptionModeAsInSource&#39;] = 0
                self._data_encryption[&#39;encryptData&#39;] = 1
                self._data_encryption[&#39;encryptionType&#39;] = encryption_values[1]
                self._data_encryption[&#39;encryptionKeyLength&#39;] = encryption_values[2]
            else:
                raise SDKException(&#39;Response&#39;, &#39;110&#39;)

        self._set_copy_properties()

    @property
    def copy_precedence(self):
        &#34;&#34;&#34;Gets the copy precedence of the copy&#34;&#34;&#34;
        return self.all_copies[&#34;copyPrecedence&#34;]

    @property
    def media_agent(self):
        &#34;&#34;&#34;Gets the media agent name of the copy&#34;&#34;&#34;
        return self._media_agent.get(&#39;mediaAgentName&#39;)

    def get_jobs_on_copy(self, from_date=None, to_date=None, backup_type=None, retained_by=0,
                         include_to_be_copied_jobs=False, list_partial_jobs_only=False):
        &#34;&#34;&#34;Fetches the Details of jobs on Storage Policy Copy

        Args:
            from_date      (str): Start Date Range for the Jobs
                                    [format-&#39;yyyy/mm/dd&#39;] [default: from start]

            to_date        (str): End Date Range for the Jobs
                                    [format-&#39;yyyy/mm/dd&#39;] [default: till date]

            backup_type    (str): Filter by backup type [default: None(all backup types)]
                                    Valid values: &#39;full&#39;/&#39;incr&#39;

            retained_by    (int): Filter by retention type of jobs [default: 0]
                                    Valid values:
                                    1: basic retention
                                    2: extended retention
                                    4: manual retention

            include_to_be_copied_jobs   (bool): Include details on jobs that are in to be copied state [default: False]

            list_partial_jobs_only      (bool): Get details of jobs that are in partially copied state only
                                                  [default: False]

        Returns:
            (list)  :   List of dict&#39;s with each dict containing details of a job
        Raises:
            SDKException:   if the response/fetch operation failed
        &#34;&#34;&#34;
        command = f&#34;qoperation execscript -sn QS_JobsinSPCopy -si @i_policyName=&#39;{self._storage_policy_name}&#39;&#34; \
                  f&#34; -si @i_copyName=&#39;{self.copy_name}&#39;&#34;
        if from_date:
            command = f&#34;{command} -si @i_fromTime=&#39;{from_date}&#39;&#34;
        if to_date:
            command = f&#34;{command} -si @i_toTime=&#39;{to_date}&#39;&#34;
        if backup_type:
            command = f&#34;{command} -si @i_backupType=&#39;{backup_type.lower()}&#39;&#34;
        if retained_by:
            command = f&#34;{command} -si @i_retention=&#39;{retained_by}&#39;&#34;
        if include_to_be_copied_jobs:
            command = f&#34;{command} -si @i_includeToBeCopiedJobs=&#39;1&#39;&#34;
        if list_partial_jobs_only:
            command = f&#34;{command} -si @i_includePartialJobsOnly=&#39;1&#39;&#34;

        response = self._commcell_object.execute_qcommand(command)
        if response.json():
            json_response = response.json()
            if json_response.get(&#34;ExecScriptOutput&#34;):
                if isinstance(json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;), list):
                    return json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;)
                if isinstance(json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;), dict):
                    if json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;).get(&#34;@JobID&#34;):
                        return [json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;)]
                return []
            else:
                response_string = self._commcell_object._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;102&#39;, response_string)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def delete_job(self, job_id):
        &#34;&#34;&#34;
        Deletes a job on Storage Policy
            Args:
                job_id      (str)   --  ID for the job to be deleted

        Raises:
            SDKException:
                if type of input parameters is not string
        &#34;&#34;&#34;
        if not isinstance(job_id, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_xml = &#34;&#34;&#34;
        &lt;App_JobOperationCopyReq operationType=&#34;2&#34;&gt;
        &lt;jobList appType=&#34;&#34; commCellId=&#34;2&#34; jobId=&#34;{0}&#34;&gt;&lt;copyInfo copyName=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34;/&gt;&lt;/jobList&gt;
        &lt;commCellInfo commCellId=&#34;2&#34;/&gt;&lt;/App_JobOperationCopyReq&gt;
        &#34;&#34;&#34;.format(job_id, self._copy_name, self._storage_policy_name)

        self._commcell_object._qoperation_execute(request_xml)

    def _mark_jobs_on_copy(self, job_id, operation):
        &#34;&#34;&#34;Marks job(s) for given operation on a secondary copy

        Args:
            job_id      (int or str or list): Job Id(s) that needs to be marked
            operation   (str):  Operation that the job(s) needs to be marked for.
                                Operations Supported: (allowcopy/recopy/donotcopy/
                                markJobsBad/pickForVerification/donotPickForVerification)
        Raises:
            SDKException:
                if type of input parameters is not string or List of strings
        &#34;&#34;&#34;
        if not isinstance(job_id, str) and not isinstance(job_id, int):
            if not isinstance(job_id, list) or\
                    (not all(isinstance(id, int) for id in job_id) and not all(isinstance(id, str) for id in job_id)):
                raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        # send multiple requests to counter limit of URL length in IIS
        job_strings = []
        if isinstance(job_id, list):
            string = &#39;&#39;
            for id in job_id:
                string += f&#39;,{id}&#39;
                if len(string) &gt; 200:
                    job_strings.append(string.strip(&#39;,&#39;))
                    string = &#39;&#39;
            if string:
                job_strings.append(string.strip(&#39;,&#39;))
        else:
            job_strings.append(job_id)

        for string in job_strings:
            qcommand = f&#39; -sn MarkJobsOnCopy -si {self._storage_policy_name} -si {self._copy_name} -si {operation} -si {string}&#39;
            url = self._services[&#39;EXECUTE_QSCRIPT&#39;] % (qcommand)
            flag, response = self._commcell_object._cvpysdk_object.make_request(&#34;POST&#34;, url)
            if flag:
                if response.text:
                    if &#39;jobs do not belong&#39; in response.text.lower():
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, response.text.strip())
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                response_string = self._commcell_object._update_response_(response.text)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def pick_for_copy(self, job_id):
        &#34;&#34;&#34;Marks job(s) to be Picked for Copy to a secondary copy

        Args:
            job_id      (int or str or list): Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;allowcopy&#39;)

    def recopy_jobs(self, job_id):
        &#34;&#34;&#34;Marks job(s) to be picked for ReCopying to a secondary copy

        Args:
            job_id      (int or str or list): Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;recopy&#39;)

    def do_not_copy_jobs(self, job_id):
        &#34;&#34;&#34;Marks job(s) as Do Not Copy to a secondary copy

        Args:
            job_id      (int or str or list):   Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;donotcopy&#39;)

    def pick_jobs_for_data_verification(self, job_id):
        &#34;&#34;&#34;Marks job(s) on a copy to be Picked for Data Verification

        Args:
            job_id      (int or str or list):   Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;pickForVerification&#39;)

    def do_not_verify_data(self, job_id):
        &#34;&#34;&#34;Marks job(s) on a copy to not be Picked for Data Verification

        Args:
            job_id      (int or str or list):   Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;donotPickForVerification&#39;)

    def mark_jobs_bad(self, job_id):
        &#34;&#34;&#34;Marks job(s) on a copy as Bad

        Args:
            job_id      (int or str or list):   Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;markJobsBad&#39;)

    def pick_jobs_for_backupcopy(self, job_id):
        &#34;&#34;&#34;This method is used to re-pick the job from backup which are unpick manually

        Args:
            job_id      (int or str or list):   Job Id(s) that needs to be marked
        &#34;&#34;&#34;
        self._mark_jobs_on_copy(job_id, &#39;pickforbackupcopy&#39;)

    @property
    def extended_retention_rules(self):
        &#34;&#34;&#34;Treats the extended retention rules setting as a read-only attribute.&#34;&#34;&#34;

        mapping = {
            2: &#34;EXTENDED_ALLFULL&#34;,
            4: &#34;EXTENDED_WEEK&#34;,
            8: &#34;EXTENDED_MONTH&#34;,
            16: &#34;EXTENDED_QUARTER&#34;,
            32: &#34;EXTENDED_HALFYEAR&#34;,
            64: &#34;EXTENDED_YEAR&#34;,
            128: &#34;MANUALLY_PIN&#34;,
            256: &#34;EXTENDED_GRACE_WEEK&#34;,
            512: &#34;EXTENDED_GRACE_MONTH&#34;,
            1024: &#34;EXTENDED_GRACE_QUARTER&#34;,
            2048: &#34;EXTENDED_GRACE_HALFYEAR&#34;,
            4096: &#34;EXTENDED_GRACE_YEAR&#34;,
            8192: &#34;EXTENDED_CANDIDATE_WEEK&#34;,
            16384: &#34;EXTENDED_CANDIDATE_MONTH&#34;,
            32768: &#34;EXTENDED_CANDIDATE_QUARTER&#34;,
            65536: &#34;EXTENDED_CANDIDATE_HALFYEAR&#34;,
            131072: &#34;EXTENDED_CANDIDATE_YEAR&#34;,
            262144: &#34;EXTENDED_HOUR&#34;,
            524288: &#34;EXTENDED_DAY&#34;,
            1048576: &#34;EXTENDED_CANDIDATE_HOUR&#34;,
            2097152: &#34;EXTENDED_CANDIDATE_DAY&#34;,
            4194304: &#34;EXTENDED_GRACE_HOUR&#34;,
            8388608: &#34;EXTENDED_GRACE_DAY&#34;,
            16777216: &#34;EXTENDED_LAST_JOB&#34;,
            33554432: &#34;EXTENDED_FIRST&#34;,
        }
        rule_one = dict()
        rule_two = dict()
        rule_three = dict()
        if &#39;extendedRetentionRuleOne&#39; in self._retention_rules:
            rule_one[&#39;isEnabled&#39;] = self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;isEnabled&#39;]
            rule_one[&#39;rule&#39;] = mapping[self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;rule&#39;]]
            rule_one[&#39;endDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;endDays&#39;]
            rule_one[&#39;graceDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;graceDays&#39;]
        else:
            rule_one = False

        if &#39;extendedRetentionRuleTwo&#39; in self._retention_rules:
            rule_two[&#39;isEnabled&#39;] = self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;isEnabled&#39;]
            rule_two[&#39;rule&#39;] = mapping[self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;rule&#39;]]
            rule_two[&#39;endDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;endDays&#39;]
            rule_two[&#39;graceDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;graceDays&#39;]
        else:
            rule_two = False

        if &#39;extendedRetentionRuleThree&#39; in self._retention_rules:
            rule_three[&#39;isEnabled&#39;] = self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;isEnabled&#39;]
            rule_three[&#39;rule&#39;] = mapping[self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;rule&#39;]]
            rule_three[&#39;endDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;endDays&#39;]
            rule_three[&#39;graceDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;graceDays&#39;]
        else:
            rule_three = False
        return rule_one, rule_two, rule_three

    @extended_retention_rules.setter
    def extended_retention_rules(self, extended_retention):
        &#34;&#34;&#34;Sets the copy extended retention rules as the value provided as input

            Args:
                extended_retention   (tuple)     --  to set extended_retention rules

                    tuple:
                        **int**    -   which rule to set (1/2/3)

                        **bool**    -   value for isEnabled

                        **str**     -   value for rule

                        Example valid values:
                            EXTENDED_ALLFULL
                            EXTENDED_WEEK
                            EXTENDED_MONTH
                            EXTENDED_QUARTER
                            EXTENDED_HALFYEAR
                            EXTENDED_YEAR

                        **int**     -   value for endDays

                        **int**     -   value for graceDays

                    e.g.:

                        &gt;&gt;&gt; copy_obj.extended_retention_rules = [1, True, &#34;EXTENDED_ALLFULL&#34;, 0, 0]

            Raises:
                SDKException:
                    if failed to update extended Retention Rule on copy

        &#34;&#34;&#34;
        mapping = {
            1: &#39;extendedRetentionRuleOne&#39;,
            2: &#39;extendedRetentionRuleTwo&#39;,
            3: &#39;extendedRetentionRuleThree&#39;
        }

        rule = mapping[extended_retention[0]]
        if rule not in self._copy_properties:
            self._retention_rules[rule] = {
                &#34;isEnabled&#34;: &#34;&#34;,
                &#34;rule&#34;: &#34;&#34;,
                &#34;endDays&#34;: &#34;&#34;,
                &#34;graceDays&#34;: &#34;&#34;}

        if extended_retention[0] is not None:
            self._retention_rules[rule][&#39;isEnabled&#39;] = int(extended_retention[1])
            self._retention_rules[rule][&#39;rule&#39;] = extended_retention[2]
            self._retention_rules[rule][&#39;endDays&#39;] = extended_retention[3]
            self._retention_rules[rule][&#39;graceDays&#39;] = extended_retention[4]
        else:
            raise SDKException(&#39;Storage&#39;, &#39;110&#39;)

        self._set_copy_properties()

    @property
    def copy_retention_managed_disk_space(self):
        &#34;&#34;&#34;Treats managed disk space setting as a read-only attribute&#34;&#34;&#34;
        return &#39;enableManagedDiskSpace&#39; in self._retention_rules

    @copy_retention_managed_disk_space.setter
    def copy_retention_managed_disk_space(self, managed_disk_space_value):
        &#34;&#34;&#34;Sets managed disk space attribute value with provided input value

            Args:
             managed_disk_space_value (Bool) -- managed disk space value to be enabled/disabled

            Raises:
                SDKException:

                    if the type of value input is not correct

        &#34;&#34;&#34;
        if not isinstance(managed_disk_space_value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        if not managed_disk_space_value:
            self._retention_rules[&#39;retentionFlags&#39;][&#39;enableManagedDiskSpace&#39;] = 0
        if managed_disk_space_value:
            self._retention_rules[&#39;retentionFlags&#39;][&#39;enableManagedDiskSpace&#39;] = 1
        self._set_copy_properties()

    @property
    def is_parallel_copy(self):
        &#34;&#34;&#34;Treats the parallel copy setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;enableParallelCopy&#39; in self._copy_flags

    def set_parallel_copy(self, value):
        &#34;&#34;&#34; Sets the parallel copy on storage policy copy as the value provided as input.
            Args:
                value    (bool) --  parallel copy on storage policy copy value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update parallel copy on storage policy copy

                    if the type of value input is not correct
        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_flags[&#39;enableParallelCopy&#39;] = int(value)

        self._set_copy_properties()

    @property
    def space_optimized_auxillary_copy(self):
        &#34;&#34;&#34;Treats the space optimized auxillary copy setting as a read-only attribute.&#34;&#34;&#34;
        if self._copy_properties.get(&#39;extendedFlags&#39;, {}).get(&#39;spaceOptimizedAuxCopy&#39;):
            return True
        return False

    @space_optimized_auxillary_copy.setter
    def space_optimized_auxillary_copy(self, value):
        &#34;&#34;&#34;Sets the space optimized auxillary copy setting as the value provided as input.
            Args:
                value    (bool) --  Enable/Disable Space Optimized Auxillary Copy
            Raises:
                SDKException:
                    if failed to update property

                    if the type of value input is not correct
        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)
        self._copy_properties[&#39;extendedFlags&#39;][&#39;spaceOptimizedAuxCopy&#39;] = int(value)

        self._set_copy_properties()

    @property
    def is_inline_copy(self):
        &#34;&#34;&#34;Treats the inline copy setting as a read-only attribute.&#34;&#34;&#34;
        return &#39;inlineAuxCopy&#39; in self._copy_flags

    def set_inline_copy(self, value):
        &#34;&#34;&#34; Sets the inline copy on storage policy copy as the value provided as input.
            Args:
                value    (bool) --  inline copy on storage policy copy value to be set on a copy (True/False)

            Raises:
                SDKException:
                    if failed to update inline copy on storage policy copy

                    if the type of value input is not correct
        &#34;&#34;&#34;
        if not isinstance(value, bool):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_flags[&#39;inlineAuxCopy&#39;] = int(value)

        self._set_copy_properties()

    @property
    def network_throttle_bandwidth(self):
        &#34;&#34;&#34;Treats the Network Throttle Bandwidth as a read-only attribute.

            Returns:
                (int) : Value of Network Throttle Bandwidth set in MBPH
        &#34;&#34;&#34;
        return int(self._copy_properties.get(&#39;throttleNetworkBandWidthMBHR&#39;))

    @network_throttle_bandwidth.setter
    def network_throttle_bandwidth(self, value):
        &#34;&#34;&#34; Sets the Network Throttle Bandwidth on storage policy copy as the value provided as input.
            Args:
                value    (int):  value of Network Throttle Bandwidth in MBPH

            Raises:
                SDKException:
                    if failed to update Network Throttle Bandwidth on storage policy copy

                    if the type of value input is not correct
        &#34;&#34;&#34;
        if not isinstance(value, int):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_properties[&#39;throttleNetworkBandWidthMBHR&#39;] = value
        self._set_copy_properties()

    def add_svm_association(self, src_array_id, source_array, tgt_array_id,
                            target_array, **kwargs):
        &#34;&#34;&#34; Method to add SVM association on Replica/vault and Mirror Copy

            Agrs:
                src_array_id    (int)   --  Controlhost id of source SVM

                source_array    (str)   --  Name of the source Array

                tgt_array_id    (int)   --  Controlhost id of target SVM

                target_array    (str)   --  Name of the Target Array

                target_vendor   (str)   --  Target Vendor Name
                
                tgt_vendor_id   (int)   --  Target Vendor id

        &#34;&#34;&#34;
        target_vendor = kwargs.get(&#39;target_vendor&#39;, &#34;&#34;)
        tgt_vendor_id = kwargs.get(&#39;tgt_vendor_id&#39;, 0)

        request_json = {
            &#34;EVGui_MMSMArrayReplicaPairReq&#34;: {
                &#34;processinginstructioninfo&#34;: {
                    &#34;locale&#34;: {
                        &#34;_type_&#34;: 66,
                        &#34;localeId&#34;: 0
                    },
                    &#34;formatFlags&#34;: {
                        &#34;ignoreUnknownTags&#34;: True,
                        &#34;elementBased&#34;: False,
                        &#34;skipIdToNameConversion&#34;: True,
                        &#34;formatted&#34;: False,
                        &#34;filterUnInitializedFields&#34;: False,
                        &#34;skipNameToIdConversion&#34;: False,
                        &#34;continueOnError&#34;: False
                    },
                    &#34;user&#34;: {
                        &#34;_type_&#34;: 13,
                        &#34;userName&#34;: &#34;admin&#34;,
                        &#34;userId&#34;: 1
                    }
                },
                &#34;copyId&#34;: self.copy_id,
                &#34;flags&#34;: 0,
                &#34;operation&#34;: 2,
                &#34;userId&#34;: 1,
                &#34;replPairList&#34;: [
                    {
                        &#34;copyId&#34;: 0,
                        &#34;flags&#34;: 0,
                        &#34;replicaPairId&#34;: 0,
                        &#34;srcArray&#34;: {
                            &#34;name&#34;: source_array,
                            &#34;id&#34;: src_array_id
                        },
                        &#34;vendor&#34;: {
                            &#34;name&#34;: &#34;&#34;,
                            &#34;id&#34;: 0
                        },
                        &#34;tgtVendor&#34;: {
                            &#34;name&#34;: target_vendor,
                            &#34;id&#34;: tgt_vendor_id
                        },
                        &#34;tgtArray&#34;: {
                            &#34;name&#34;: target_array,
                            &#34;id&#34;: tgt_array_id
                        }
                    }
                ]
            }
        }

        add_svm_association_service = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, add_svm_association_service, request_json
        )
        self.refresh()

        if flag:
            if response.json():
                if &#39;errorCode&#39; in response.json():
                    error_code = int(response.json()[&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to Update SVM Association on Copy: {0}&#34;.format(
                            self._copy_name
                        )
                        raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
                else:
                    raise SDKException(&#39;Response&#39;, &#39;102&#39;)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def set_key_management_server(self, kms_name):
        &#34;&#34;&#34;Sets the Key Management Server to this copy

            Args:
                kms_name  (str) -- The Key Management Server&#39;s name

            Raises SDKException:
                If input is not valid

                If API response is not successful

        &#34;&#34;&#34;
        if not isinstance(kms_name, str):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_properties[&#34;dataEncryption&#34;] = {
            &#34;keyProviderName&#34;: kms_name,
            &#34;rotateMasterKey&#34;: True
        }
        self._set_copy_properties()
    
    def set_multiplexing_factor(self, mux_factor):
        &#34;&#34;&#34;Sets/Unset the multiplexing factor for the storage policy copy

            Args:
                mux_factor  (int) -- The value for multiplexing factor

            Raises SDKException:
                If input is not valid

                If API response is not successful
        &#34;&#34;&#34;
        if not isinstance(mux_factor, int):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        self._copy_properties[&#39;mediaProperties&#39;] = {
            &#34;multiplexingFactor&#34; : mux_factor
        }
        self._set_copy_properties()    

    @property
    def ddb_resiliency(self):
        &#34;&#34;&#34;Treats the Resiliency Flag as a read-only attribute.
            Returns:
                (bool) : Value of Resiliency Flag
        &#34;&#34;&#34;
        return bool(self._dedupe_flags.get(&#39;allowJobsToRunWithoutAllPartitions&#39;))

    def set_ddb_resiliency(self, is_enabled, min_num_partitions):
        &#34;&#34;&#34;Sets Resiliency On or Off, and set partition threshold for Resiliency
            Args:
                is_enabled  (Boolean) -- True or False to enable and disable resiliency respectively.
                min_num_partitions (int) -- Number of partitions required to be online for Resiliency to take affect.
            Raises SDKException:
                If input is not valid
                If min_num_partitions &lt; 1
                If API response is not successful
        &#34;&#34;&#34;
        if isinstance(is_enabled, bool) or isinstance(min_num_partitions, int):
            SDKException(&#39;Storage&#39;, &#39;101&#39;)
        if is_enabled:
            if min_num_partitions &lt; 1:
                SDKException(&#39;Storage&#39;, &#39;102&#39;, &#34;error min_num_partitions should be greater than or equal to 1&#34;)
            self._copy_properties[&#39;minimumNumberOfPartitionsForJobsToRun&#39;] = min_num_partitions
            self._dedupe_flags[&#39;allowJobsToRunWithoutAllPartitions&#39;] = 1
            self._set_copy_properties()
        else:
            self._dedupe_flags[&#39;allowJobsToRunWithoutAllPartitions&#39;] = 0
            self._set_copy_properties()

    def delete_datapath(self, library_name, media_agent_name):
        &#34;&#34;&#34;
        Delete DataPath from the storage policy copy

            Args:
                library_name    (str)   --   name of the library

                media_agent_name(str)   --   name of the media agent

            Raises:
                SDKException:
                    - If type of required input parameters is not string
                    - If API response is not successful
        &#34;&#34;&#34;
        if not (isinstance(media_agent_name, str)) and isinstance(library_name):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_json = {
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;dataPathProperties&#34;: [
                    {
                        &#34;operationFlags&#34;: {
                            &#34;removeDataPath&#34;: True
                        },
                        &#34;mediaAgent&#34;: {
                            &#34;mediaAgentName&#34;: media_agent_name
                        },
                        &#34;library&#34;: {
                            &#34;libraryName&#34;: library_name
                        }
                    }
                ]
            }
        }

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._STORAGE_POLICY_COPY,
                                                           request_json)
        self.refresh()
        if flag:
            if response.json():
                response = response.json()
                if &#34;error&#34; in response and response.get(&#34;error&#34;, {}).get(&#34;errorCode&#34;) != 0:
                    error_message = response.get(&#34;error&#34;, {}).get(&#34;errorMessage&#34;)
                    raise SDKException(&#39;Response&#39;, &#39;101&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            error_message = response.json().get(&#34;errorMessage&#34;)
            raise SDKException(&#39;Response&#39;, &#39;111&#39;, error_message)

    def rotate_encryption_master_key(self):
        &#34;&#34;&#34;
        Rotates the encryption key for this copy
        &#34;&#34;&#34;
        self._copy_properties[&#34;dataEncryption&#34;] = {
            &#34;rotateMasterKey&#34;: True
        }
        self._set_copy_properties()
        
    def set_default_datapath(self, library_name, media_agent_name):
        &#34;&#34;&#34;
        Set default data path for that storage policy copy.

            Args:
                library_name    (str)   --   name of the library

                media_agent_name(str)   --   name of the media agent

            Raises:
                SDKException:
                    - If type of required input parameters is not string
                    - If API response is not successful
        &#34;&#34;&#34;
        if not (isinstance(media_agent_name, str)) and isinstance(library_name):
            raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

        request_json = {
            &#34;storagePolicyCopyInfo&#34;: {
                &#34;dataPathProperties&#34;: [
                    {
                        &#34;operationFlags&#34;: {
                            &#34;setDefault&#34;: True
                        },
                        &#34;mediaAgent&#34;: {
                            &#34;mediaAgentName&#34;: media_agent_name
                        },
                        &#34;library&#34;: {
                            &#34;libraryName&#34;: library_name
                        }
                    }
                ]
            }
        }

        flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._STORAGE_POLICY_COPY,
                                                           request_json)
        self.refresh()
        if flag:
            if response.json():
                response = response.json()
                if &#34;error&#34; in response and response.get(&#34;error&#34;, {}).get(&#34;errorCode&#34;) != 0:
                    error_message = response.get(&#34;error&#34;, {}).get(&#34;errorMessage&#34;)
                    raise SDKException(&#39;Response&#39;, &#39;101&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            error_message = response.json().get(&#34;errorMessage&#34;)
            raise SDKException(&#39;Response&#39;, &#39;111&#39;, error_message)

    @property
    def is_compliance_lock_enabled(self):
        &#34;&#34;&#34;Checks whether compliance lock on copy is enabled or not&#34;&#34;&#34;
        return &#39;wormCopy&#39; in self._copy_flags

    def get_store_seal_frequency(self):
        &#34;&#34;&#34;Gets the store seal frequency for the copy

        Returns:
            dict -- store seal frequency for the copy
                    Eg: {&#39;size&#39;: 0, &#39;days&#39;: 2, &#39;months&#39;: 0}
        &#34;&#34;&#34;
        request_json = {
            &#34;EVGui_StoragePolicySummaryReq&#34;: {
                &#34;spId&#34;: self.storage_policy_id,
                &#34;spCopyId&#34;: self.copy_id,
                &#34;reportType&#34;: 5 # storage policy copy&#39;s dedup information summary
            }
        }

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_json
        )
        if flag:
            if response and response.json():
                dedup_summary = response.json()
                dedup_options = dedup_summary[&#39;options&#39;][&#39;dedupOptions&#39;]
                seal_frequency_dict = {
                    &#39;size&#39;: dedup_options[&#39;storeCreationSize&#39;],
                    &#39;days&#39;: dedup_options[&#39;storeCreationDays&#39;],
                    &#39;months&#39;: dedup_options[&#39;storeCreationMonths&#39;]
                }
                return seal_frequency_dict
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    def enable_compliance_lock(self):
        &#34;&#34;&#34;Sets compliance lock (wormCopy flag)

        Raises:
            SDKException:
                if response is not success.
                if response is empty.
        &#34;&#34;&#34;
        self._copy_properties[&#39;copyFlags&#39;][&#39;wormCopy&#39;] = 1
        self._set_copy_properties()

        if not self.is_compliance_lock_enabled:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, &#39;Failed to set compliance lock&#39;)

    def disable_compliance_lock(self):
        &#34;&#34;&#34;Unsets compliance lock (wormCopy flag)

        Raises:
            SDKException:
                if response is not success.
                if response is empty.
        &#34;&#34;&#34;

        disable_compliance_lock_url = self._services[&#39;DISABLE_STORAGE_POLICY_COMPLIANCE_LOCK&#39;] % (
            self.storage_policy_id, self.copy_id)

        flag, response = self._commcell_object._cvpysdk_object.make_request(
            &#39;POST&#39;, disable_compliance_lock_url
        )

        # Adding a refresh to ensure we have the latest properties to verify if the compliance lock is disabled.
        self.refresh()

        if flag:
            if response.json():
                if (&#39;genericError&#39; in response.json()) and (&#39;errorCode&#39; in response.json()[&#39;genericError&#39;]):
                    error_code = int(response.json()[&#39;genericError&#39;][&#39;errorCode&#39;])
                    if error_code != 0:
                        error_message = &#34;Failed to disable compliance lock&#34;
                        if &#34;errorMessage&#34; in response.json()[&#34;copies&#34;][0][&#39;genericError&#39;]:
                            error_message = response.json()[&#34;copies&#34;][0][&#39;genericError&#39;][&#34;errorMessage&#34;]
                        raise SDKException(&#39;Storage&#39;, &#39;111&#39;, error_message)
                else:
                    if &#34;error&#34; in response.json():
                        warning_message = &#34;&#34;
                        if &#34;warningMessage&#34; in response.json()[&#34;error&#34;]:
                            warning_message = response.json()[&#34;error&#34;][&#34;warningMessage&#34;]
                        raise SDKException(&#39;Storage&#39;, &#39;111&#39;, warning_message)
                    else:
                        raise SDKException(&#39;Storage&#39;, &#39;111&#39;)
            else:
                raise SDKException(&#39;Storage&#39;, &#39;111&#39;)
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

        if self.is_compliance_lock_enabled:
            raise SDKException(&#39;Response&#39;, &#39;101&#39;, &#39;Failed to unset compliance lock&#39;)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.all_copies"><code class="name">var <span class="ident">all_copies</span></code></dt>
<dd>
<div class="desc"><p>Returns dict of
the storage policy copy associated with this storage policy</p>
<p>dict - consists of stoarge policy copy properties
"copyType": copy_type,
"active": active,
"copyId": copy_id,
"libraryName": library_name,
"copyPrecedence": copy_precedence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3422-L3433" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def all_copies(self):
    &#34;&#34;&#34;Returns dict of  the storage policy copy associated with this storage policy

        dict - consists of stoarge policy copy properties
                &#34;copyType&#34;: copy_type,
                &#34;active&#34;: active,
                &#34;copyId&#34;: copy_id,
                &#34;libraryName&#34;: library_name,
                &#34;copyPrecedence&#34;: copy_precedence
    &#34;&#34;&#34;
    return self.storage_policy._copies[self._copy_name]</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_client_side_dedup"><code class="name">var <span class="ident">copy_client_side_dedup</span></code></dt>
<dd>
<div class="desc"><p>Treats the copy deduplication setting as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3731-L3734" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def copy_client_side_dedup(self):
    &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
    return &#39;enableClientSideDedup&#39; in self._dedupe_flags</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_dedupe_dash_full"><code class="name">var <span class="ident">copy_dedupe_dash_full</span></code></dt>
<dd>
<div class="desc"><p>Treats the copy deduplication setting as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3654-L3657" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def copy_dedupe_dash_full(self):
    &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
    return &#39;enableDASHFull&#39; in self._dedupe_flags</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_dedupe_disk_cache"><code class="name">var <span class="ident">copy_dedupe_disk_cache</span></code></dt>
<dd>
<div class="desc"><p>Treats the copy deduplication setting as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3682-L3685" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def copy_dedupe_disk_cache(self):
    &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
    return &#39;enableSourceSideDiskCache&#39; in self._dedupe_flags</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_name"><code class="name">var <span class="ident">copy_name</span></code></dt>
<dd>
<div class="desc"><p>Returns the name of the copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3558-L3561" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def copy_name(self):
    &#34;&#34;&#34;Returns the name of the copy&#34;&#34;&#34;
    return self._copy_name</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_precedence"><code class="name">var <span class="ident">copy_precedence</span></code></dt>
<dd>
<div class="desc"><p>Gets the copy precedence of the copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3971-L3974" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def copy_precedence(self):
    &#34;&#34;&#34;Gets the copy precedence of the copy&#34;&#34;&#34;
    return self.all_copies[&#34;copyPrecedence&#34;]</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_reencryption"><code class="name">var <span class="ident">copy_reencryption</span></code></dt>
<dd>
<div class="desc"><p>Treats the secondary copy encryption as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3896-L3907" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def copy_reencryption(self):
    &#34;&#34;&#34;Treats the secondary copy encryption as a read-only attribute.&#34;&#34;&#34;
    if &#39;auxCopyReencryptData&#39; in self._copy_flags:
        if self._copy_flags[&#39;auxCopyReencryptData&#39;] == 1:
            encryption_setting = &#34;True&#34;

    if &#39;preserveEncryptionModeAsInSource&#39; in self._copy_flags:
        if self._copy_flags[&#39;preserveEncryptionModeAsInSource&#39;] == 1:
            encryption_setting = &#34;False&#34;

    return encryption_setting</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_retention"><code class="name">var <span class="ident">copy_retention</span></code></dt>
<dd>
<div class="desc"><p>Treats the copy retention as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3578-L3586" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def copy_retention(self):
    &#34;&#34;&#34;Treats the copy retention as a read-only attribute.&#34;&#34;&#34;
    retention_values = {}
    retention_values[&#34;days&#34;] = self._retention_rules[&#39;retainBackupDataForDays&#39;]
    retention_values[&#34;cycles&#34;] = self._retention_rules[&#39;retainBackupDataForCycles&#39;]
    retention_values[&#34;archiveDays&#34;] = self._retention_rules[&#39;retainArchiverDataForDays&#39;]
    retention_values[&#34;jobs&#34;] = self._retention_rules[&#39;jobs&#39;]
    return retention_values</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_retention_managed_disk_space"><code class="name">var <span class="ident">copy_retention_managed_disk_space</span></code></dt>
<dd>
<div class="desc"><p>Treats managed disk space setting as a read-only attribute</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4283-L4286" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def copy_retention_managed_disk_space(self):
    &#34;&#34;&#34;Treats managed disk space setting as a read-only attribute&#34;&#34;&#34;
    return &#39;enableManagedDiskSpace&#39; in self._retention_rules</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_software_compression"><code class="name">var <span class="ident">copy_software_compression</span></code></dt>
<dd>
<div class="desc"><p>Treats the copy software compression setting as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3627-L3630" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def copy_software_compression(self):
    &#34;&#34;&#34;Treats the copy software compression setting as a read-only attribute.&#34;&#34;&#34;
    return &#39;compressionOnClients&#39; in self._extended_flags</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.ddb_resiliency"><code class="name">var <span class="ident">ddb_resiliency</span></code></dt>
<dd>
<div class="desc"><p>Treats the Resiliency Flag as a read-only attribute.</p>
<h2 id="returns">Returns</h2>
<p>(bool) : Value of Resiliency Flag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4544-L4550" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def ddb_resiliency(self):
    &#34;&#34;&#34;Treats the Resiliency Flag as a read-only attribute.
        Returns:
            (bool) : Value of Resiliency Flag
    &#34;&#34;&#34;
    return bool(self._dedupe_flags.get(&#39;allowJobsToRunWithoutAllPartitions&#39;))</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.extended_retention_rules"><code class="name">var <span class="ident">extended_retention_rules</span></code></dt>
<dd>
<div class="desc"><p>Treats the extended retention rules setting as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4165-L4222" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def extended_retention_rules(self):
    &#34;&#34;&#34;Treats the extended retention rules setting as a read-only attribute.&#34;&#34;&#34;

    mapping = {
        2: &#34;EXTENDED_ALLFULL&#34;,
        4: &#34;EXTENDED_WEEK&#34;,
        8: &#34;EXTENDED_MONTH&#34;,
        16: &#34;EXTENDED_QUARTER&#34;,
        32: &#34;EXTENDED_HALFYEAR&#34;,
        64: &#34;EXTENDED_YEAR&#34;,
        128: &#34;MANUALLY_PIN&#34;,
        256: &#34;EXTENDED_GRACE_WEEK&#34;,
        512: &#34;EXTENDED_GRACE_MONTH&#34;,
        1024: &#34;EXTENDED_GRACE_QUARTER&#34;,
        2048: &#34;EXTENDED_GRACE_HALFYEAR&#34;,
        4096: &#34;EXTENDED_GRACE_YEAR&#34;,
        8192: &#34;EXTENDED_CANDIDATE_WEEK&#34;,
        16384: &#34;EXTENDED_CANDIDATE_MONTH&#34;,
        32768: &#34;EXTENDED_CANDIDATE_QUARTER&#34;,
        65536: &#34;EXTENDED_CANDIDATE_HALFYEAR&#34;,
        131072: &#34;EXTENDED_CANDIDATE_YEAR&#34;,
        262144: &#34;EXTENDED_HOUR&#34;,
        524288: &#34;EXTENDED_DAY&#34;,
        1048576: &#34;EXTENDED_CANDIDATE_HOUR&#34;,
        2097152: &#34;EXTENDED_CANDIDATE_DAY&#34;,
        4194304: &#34;EXTENDED_GRACE_HOUR&#34;,
        8388608: &#34;EXTENDED_GRACE_DAY&#34;,
        16777216: &#34;EXTENDED_LAST_JOB&#34;,
        33554432: &#34;EXTENDED_FIRST&#34;,
    }
    rule_one = dict()
    rule_two = dict()
    rule_three = dict()
    if &#39;extendedRetentionRuleOne&#39; in self._retention_rules:
        rule_one[&#39;isEnabled&#39;] = self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;isEnabled&#39;]
        rule_one[&#39;rule&#39;] = mapping[self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;rule&#39;]]
        rule_one[&#39;endDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;endDays&#39;]
        rule_one[&#39;graceDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleOne&#39;][&#39;graceDays&#39;]
    else:
        rule_one = False

    if &#39;extendedRetentionRuleTwo&#39; in self._retention_rules:
        rule_two[&#39;isEnabled&#39;] = self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;isEnabled&#39;]
        rule_two[&#39;rule&#39;] = mapping[self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;rule&#39;]]
        rule_two[&#39;endDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;endDays&#39;]
        rule_two[&#39;graceDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleTwo&#39;][&#39;graceDays&#39;]
    else:
        rule_two = False

    if &#39;extendedRetentionRuleThree&#39; in self._retention_rules:
        rule_three[&#39;isEnabled&#39;] = self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;isEnabled&#39;]
        rule_three[&#39;rule&#39;] = mapping[self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;rule&#39;]]
        rule_three[&#39;endDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;endDays&#39;]
        rule_three[&#39;graceDays&#39;] = self._retention_rules[&#39;extendedRetentionRuleThree&#39;][&#39;graceDays&#39;]
    else:
        rule_three = False
    return rule_one, rule_two, rule_three</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.is_active"><code class="name">var <span class="ident">is_active</span></code></dt>
<dd>
<div class="desc"><p>Gets whether the Storage Policy Copy is active or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3443-L3446" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_active(self):
    &#34;&#34;&#34;Gets whether the Storage Policy Copy is active or not&#34;&#34;&#34;
    return bool(self._copy_properties.get(&#39;active&#39;))</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.is_compliance_lock_enabled"><code class="name">var <span class="ident">is_compliance_lock_enabled</span></code></dt>
<dd>
<div class="desc"><p>Checks whether compliance lock on copy is enabled or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4683-L4686" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_compliance_lock_enabled(self):
    &#34;&#34;&#34;Checks whether compliance lock on copy is enabled or not&#34;&#34;&#34;
    return &#39;wormCopy&#39; in self._copy_flags</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.is_inline_copy"><code class="name">var <span class="ident">is_inline_copy</span></code></dt>
<dd>
<div class="desc"><p>Treats the inline copy setting as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4357-L4360" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_inline_copy(self):
    &#34;&#34;&#34;Treats the inline copy setting as a read-only attribute.&#34;&#34;&#34;
    return &#39;inlineAuxCopy&#39; in self._copy_flags</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.is_parallel_copy"><code class="name">var <span class="ident">is_parallel_copy</span></code></dt>
<dd>
<div class="desc"><p>Treats the parallel copy setting as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4310-L4313" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def is_parallel_copy(self):
    &#34;&#34;&#34;Treats the parallel copy setting as a read-only attribute.&#34;&#34;&#34;
    return &#39;enableParallelCopy&#39; in self._copy_flags</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.media_agent"><code class="name">var <span class="ident">media_agent</span></code></dt>
<dd>
<div class="desc"><p>Gets the media agent name of the copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3976-L3979" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def media_agent(self):
    &#34;&#34;&#34;Gets the media agent name of the copy&#34;&#34;&#34;
    return self._media_agent.get(&#39;mediaAgentName&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.network_throttle_bandwidth"><code class="name">var <span class="ident">network_throttle_bandwidth</span></code></dt>
<dd>
<div class="desc"><p>Treats the Network Throttle Bandwidth as a read-only attribute.</p>
<h2 id="returns">Returns</h2>
<p>(int) : Value of Network Throttle Bandwidth set in MBPH</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4380-L4387" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def network_throttle_bandwidth(self):
    &#34;&#34;&#34;Treats the Network Throttle Bandwidth as a read-only attribute.

        Returns:
            (int) : Value of Network Throttle Bandwidth set in MBPH
    &#34;&#34;&#34;
    return int(self._copy_properties.get(&#39;throttleNetworkBandWidthMBHR&#39;))</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.override_pool_retention"><code class="name">var <span class="ident">override_pool_retention</span></code></dt>
<dd>
<div class="desc"><p>Returns if Override Pool Retention flag is set or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3563-L3566" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def override_pool_retention(self):
    &#34;&#34;&#34;Returns if Override Pool Retention flag is set or not&#34;&#34;&#34;
    return bool(self._extended_flags.get(&#39;overRideGACPRetention&#39;, 0))</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.source_copy"><code class="name">var <span class="ident">source_copy</span></code></dt>
<dd>
<div class="desc"><p>Treats the copy deduplication setting as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3763-L3766" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def source_copy(self):
    &#34;&#34;&#34;Treats the copy deduplication setting as a read-only attribute.&#34;&#34;&#34;
    return self._copy_properties.get(&#39;sourceCopy&#39;, {}).get(&#39;copyName&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.space_optimized_auxillary_copy"><code class="name">var <span class="ident">space_optimized_auxillary_copy</span></code></dt>
<dd>
<div class="desc"><p>Treats the space optimized auxillary copy setting as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4333-L4338" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def space_optimized_auxillary_copy(self):
    &#34;&#34;&#34;Treats the space optimized auxillary copy setting as a read-only attribute.&#34;&#34;&#34;
    if self._copy_properties.get(&#39;extendedFlags&#39;, {}).get(&#39;spaceOptimizedAuxCopy&#39;):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.store_priming"><code class="name">var <span class="ident">store_priming</span></code></dt>
<dd>
<div class="desc"><p>Treats the copy store priming setting as a read-only attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3706-L3709" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def store_priming(self):
    &#34;&#34;&#34;Treats the copy store priming setting as a read-only attribute.&#34;&#34;&#34;
    return self._dedupe_flags.get(&#39;useDDBPrimingOption&#39;, 0) &gt; 0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.add_svm_association"><code class="name flex">
<span>def <span class="ident">add_svm_association</span></span>(<span>self, src_array_id, source_array, tgt_array_id, target_array, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Method to add SVM association on Replica/vault and Mirror Copy</p>
<h2 id="agrs">Agrs</h2>
<p>src_array_id
(int)
&ndash;
Controlhost id of source SVM</p>
<p>source_array
(str)
&ndash;
Name of the source Array</p>
<p>tgt_array_id
(int)
&ndash;
Controlhost id of target SVM</p>
<p>target_array
(str)
&ndash;
Name of the Target Array</p>
<p>target_vendor
(str)
&ndash;
Target Vendor Name</p>
<p>tgt_vendor_id
(int)
&ndash;
Target Vendor id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4407-L4502" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_svm_association(self, src_array_id, source_array, tgt_array_id,
                        target_array, **kwargs):
    &#34;&#34;&#34; Method to add SVM association on Replica/vault and Mirror Copy

        Agrs:
            src_array_id    (int)   --  Controlhost id of source SVM

            source_array    (str)   --  Name of the source Array

            tgt_array_id    (int)   --  Controlhost id of target SVM

            target_array    (str)   --  Name of the Target Array

            target_vendor   (str)   --  Target Vendor Name
            
            tgt_vendor_id   (int)   --  Target Vendor id

    &#34;&#34;&#34;
    target_vendor = kwargs.get(&#39;target_vendor&#39;, &#34;&#34;)
    tgt_vendor_id = kwargs.get(&#39;tgt_vendor_id&#39;, 0)

    request_json = {
        &#34;EVGui_MMSMArrayReplicaPairReq&#34;: {
            &#34;processinginstructioninfo&#34;: {
                &#34;locale&#34;: {
                    &#34;_type_&#34;: 66,
                    &#34;localeId&#34;: 0
                },
                &#34;formatFlags&#34;: {
                    &#34;ignoreUnknownTags&#34;: True,
                    &#34;elementBased&#34;: False,
                    &#34;skipIdToNameConversion&#34;: True,
                    &#34;formatted&#34;: False,
                    &#34;filterUnInitializedFields&#34;: False,
                    &#34;skipNameToIdConversion&#34;: False,
                    &#34;continueOnError&#34;: False
                },
                &#34;user&#34;: {
                    &#34;_type_&#34;: 13,
                    &#34;userName&#34;: &#34;admin&#34;,
                    &#34;userId&#34;: 1
                }
            },
            &#34;copyId&#34;: self.copy_id,
            &#34;flags&#34;: 0,
            &#34;operation&#34;: 2,
            &#34;userId&#34;: 1,
            &#34;replPairList&#34;: [
                {
                    &#34;copyId&#34;: 0,
                    &#34;flags&#34;: 0,
                    &#34;replicaPairId&#34;: 0,
                    &#34;srcArray&#34;: {
                        &#34;name&#34;: source_array,
                        &#34;id&#34;: src_array_id
                    },
                    &#34;vendor&#34;: {
                        &#34;name&#34;: &#34;&#34;,
                        &#34;id&#34;: 0
                    },
                    &#34;tgtVendor&#34;: {
                        &#34;name&#34;: target_vendor,
                        &#34;id&#34;: tgt_vendor_id
                    },
                    &#34;tgtArray&#34;: {
                        &#34;name&#34;: target_array,
                        &#34;id&#34;: tgt_array_id
                    }
                }
            ]
        }
    }

    add_svm_association_service = self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;]

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, add_svm_association_service, request_json
    )
    self.refresh()

    if flag:
        if response.json():
            if &#39;errorCode&#39; in response.json():
                error_code = int(response.json()[&#39;errorCode&#39;])
                if error_code != 0:
                    error_message = &#34;Failed to Update SVM Association on Copy: {0}&#34;.format(
                        self._copy_name
                    )
                    raise SDKException(&#39;Storage&#39;, &#39;102&#39;, error_message)
            else:
                raise SDKException(&#39;Response&#39;, &#39;102&#39;)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.delete_datapath"><code class="name flex">
<span>def <span class="ident">delete_datapath</span></span>(<span>self, library_name, media_agent_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete DataPath from the storage policy copy</p>
<pre><code>Args:
    library_name    (str)   --   name of the library

    media_agent_name(str)   --   name of the media agent

Raises:
    SDKException:
        - If type of required input parameters is not string
        - If API response is not successful
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4574-L4622" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delete_datapath(self, library_name, media_agent_name):
    &#34;&#34;&#34;
    Delete DataPath from the storage policy copy

        Args:
            library_name    (str)   --   name of the library

            media_agent_name(str)   --   name of the media agent

        Raises:
            SDKException:
                - If type of required input parameters is not string
                - If API response is not successful
    &#34;&#34;&#34;
    if not (isinstance(media_agent_name, str)) and isinstance(library_name):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    request_json = {
        &#34;storagePolicyCopyInfo&#34;: {
            &#34;dataPathProperties&#34;: [
                {
                    &#34;operationFlags&#34;: {
                        &#34;removeDataPath&#34;: True
                    },
                    &#34;mediaAgent&#34;: {
                        &#34;mediaAgentName&#34;: media_agent_name
                    },
                    &#34;library&#34;: {
                        &#34;libraryName&#34;: library_name
                    }
                }
            ]
        }
    }

    flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._STORAGE_POLICY_COPY,
                                                       request_json)
    self.refresh()
    if flag:
        if response.json():
            response = response.json()
            if &#34;error&#34; in response and response.get(&#34;error&#34;, {}).get(&#34;errorCode&#34;) != 0:
                error_message = response.get(&#34;error&#34;, {}).get(&#34;errorMessage&#34;)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, error_message)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        error_message = response.json().get(&#34;errorMessage&#34;)
        raise SDKException(&#39;Response&#39;, &#39;111&#39;, error_message)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.delete_job"><code class="name flex">
<span>def <span class="ident">delete_job</span></span>(<span>self, job_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a job on Storage Policy
Args:
job_id
(str)
&ndash;
ID for the job to be deleted</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if type of input parameters is not string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4043-L4062" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delete_job(self, job_id):
    &#34;&#34;&#34;
    Deletes a job on Storage Policy
        Args:
            job_id      (str)   --  ID for the job to be deleted

    Raises:
        SDKException:
            if type of input parameters is not string
    &#34;&#34;&#34;
    if not isinstance(job_id, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    request_xml = &#34;&#34;&#34;
    &lt;App_JobOperationCopyReq operationType=&#34;2&#34;&gt;
    &lt;jobList appType=&#34;&#34; commCellId=&#34;2&#34; jobId=&#34;{0}&#34;&gt;&lt;copyInfo copyName=&#34;{1}&#34; storagePolicyName=&#34;{2}&#34;/&gt;&lt;/jobList&gt;
    &lt;commCellInfo commCellId=&#34;2&#34;/&gt;&lt;/App_JobOperationCopyReq&gt;
    &#34;&#34;&#34;.format(job_id, self._copy_name, self._storage_policy_name)

    self._commcell_object._qoperation_execute(request_xml)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.disable_compliance_lock"><code class="name flex">
<span>def <span class="ident">disable_compliance_lock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Unsets compliance lock (wormCopy flag)</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if response is not success.
if response is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4734-L4777" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def disable_compliance_lock(self):
    &#34;&#34;&#34;Unsets compliance lock (wormCopy flag)

    Raises:
        SDKException:
            if response is not success.
            if response is empty.
    &#34;&#34;&#34;

    disable_compliance_lock_url = self._services[&#39;DISABLE_STORAGE_POLICY_COMPLIANCE_LOCK&#39;] % (
        self.storage_policy_id, self.copy_id)

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, disable_compliance_lock_url
    )

    # Adding a refresh to ensure we have the latest properties to verify if the compliance lock is disabled.
    self.refresh()

    if flag:
        if response.json():
            if (&#39;genericError&#39; in response.json()) and (&#39;errorCode&#39; in response.json()[&#39;genericError&#39;]):
                error_code = int(response.json()[&#39;genericError&#39;][&#39;errorCode&#39;])
                if error_code != 0:
                    error_message = &#34;Failed to disable compliance lock&#34;
                    if &#34;errorMessage&#34; in response.json()[&#34;copies&#34;][0][&#39;genericError&#39;]:
                        error_message = response.json()[&#34;copies&#34;][0][&#39;genericError&#39;][&#34;errorMessage&#34;]
                    raise SDKException(&#39;Storage&#39;, &#39;111&#39;, error_message)
            else:
                if &#34;error&#34; in response.json():
                    warning_message = &#34;&#34;
                    if &#34;warningMessage&#34; in response.json()[&#34;error&#34;]:
                        warning_message = response.json()[&#34;error&#34;][&#34;warningMessage&#34;]
                    raise SDKException(&#39;Storage&#39;, &#39;111&#39;, warning_message)
                else:
                    raise SDKException(&#39;Storage&#39;, &#39;111&#39;)
        else:
            raise SDKException(&#39;Storage&#39;, &#39;111&#39;)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)

    if self.is_compliance_lock_enabled:
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, &#39;Failed to unset compliance lock&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.do_not_copy_jobs"><code class="name flex">
<span>def <span class="ident">do_not_copy_jobs</span></span>(<span>self, job_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks job(s) as Do Not Copy to a secondary copy</p>
<h2 id="args">Args</h2>
<p>job_id
(int or str or list):
Job Id(s) that needs to be marked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4125-L4131" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def do_not_copy_jobs(self, job_id):
    &#34;&#34;&#34;Marks job(s) as Do Not Copy to a secondary copy

    Args:
        job_id      (int or str or list):   Job Id(s) that needs to be marked
    &#34;&#34;&#34;
    self._mark_jobs_on_copy(job_id, &#39;donotcopy&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.do_not_verify_data"><code class="name flex">
<span>def <span class="ident">do_not_verify_data</span></span>(<span>self, job_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks job(s) on a copy to not be Picked for Data Verification</p>
<h2 id="args">Args</h2>
<p>job_id
(int or str or list):
Job Id(s) that needs to be marked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4141-L4147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def do_not_verify_data(self, job_id):
    &#34;&#34;&#34;Marks job(s) on a copy to not be Picked for Data Verification

    Args:
        job_id      (int or str or list):   Job Id(s) that needs to be marked
    &#34;&#34;&#34;
    self._mark_jobs_on_copy(job_id, &#39;donotPickForVerification&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.enable_compliance_lock"><code class="name flex">
<span>def <span class="ident">enable_compliance_lock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets compliance lock (wormCopy flag)</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if response is not success.
if response is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4720-L4732" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def enable_compliance_lock(self):
    &#34;&#34;&#34;Sets compliance lock (wormCopy flag)

    Raises:
        SDKException:
            if response is not success.
            if response is empty.
    &#34;&#34;&#34;
    self._copy_properties[&#39;copyFlags&#39;][&#39;wormCopy&#39;] = 1
    self._set_copy_properties()

    if not self.is_compliance_lock_enabled:
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, &#39;Failed to set compliance lock&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.get_copy_Precedence"><code class="name flex">
<span>def <span class="ident">get_copy_Precedence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the copyprecendence asscoiated with the storage policy copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3439-L3441" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_copy_Precedence(self):
    &#34;&#34;&#34;Gets the copyprecendence asscoiated with the storage policy copy&#34;&#34;&#34;
    return self.all_copies[&#34;copyPrecedence&#34;]</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.get_copy_id"><code class="name flex">
<span>def <span class="ident">get_copy_id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the storage policy id asscoiated with the storage policy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3435-L3437" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_copy_id(self):
    &#34;&#34;&#34;Gets the storage policy id asscoiated with the storage policy&#34;&#34;&#34;
    return self.all_copies[&#34;copyId&#34;]</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.get_jobs_on_copy"><code class="name flex">
<span>def <span class="ident">get_jobs_on_copy</span></span>(<span>self, from_date=None, to_date=None, backup_type=None, retained_by=0, include_to_be_copied_jobs=False, list_partial_jobs_only=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetches the Details of jobs on Storage Policy Copy</p>
<h2 id="args">Args</h2>
<p>from_date
(str): Start Date Range for the Jobs
[format-'yyyy/mm/dd'] [default: from start]</p>
<p>to_date
(str): End Date Range for the Jobs
[format-'yyyy/mm/dd'] [default: till date]</p>
<p>backup_type
(str): Filter by backup type [default: None(all backup types)]
Valid values: 'full'/'incr'</p>
<p>retained_by
(int): Filter by retention type of jobs [default: 0]
Valid values:
1: basic retention
2: extended retention
4: manual retention</p>
<p>include_to_be_copied_jobs
(bool): Include details on jobs that are in to be copied state [default: False]</p>
<p>list_partial_jobs_only
(bool): Get details of jobs that are in partially copied state only
[default: False]</p>
<h2 id="returns">Returns</h2>
<p>(list)
:
List of dict's with each dict containing details of a job</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>SDKException</code></dt>
<dd>if the response/fetch operation failed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3981-L4041" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_jobs_on_copy(self, from_date=None, to_date=None, backup_type=None, retained_by=0,
                     include_to_be_copied_jobs=False, list_partial_jobs_only=False):
    &#34;&#34;&#34;Fetches the Details of jobs on Storage Policy Copy

    Args:
        from_date      (str): Start Date Range for the Jobs
                                [format-&#39;yyyy/mm/dd&#39;] [default: from start]

        to_date        (str): End Date Range for the Jobs
                                [format-&#39;yyyy/mm/dd&#39;] [default: till date]

        backup_type    (str): Filter by backup type [default: None(all backup types)]
                                Valid values: &#39;full&#39;/&#39;incr&#39;

        retained_by    (int): Filter by retention type of jobs [default: 0]
                                Valid values:
                                1: basic retention
                                2: extended retention
                                4: manual retention

        include_to_be_copied_jobs   (bool): Include details on jobs that are in to be copied state [default: False]

        list_partial_jobs_only      (bool): Get details of jobs that are in partially copied state only
                                              [default: False]

    Returns:
        (list)  :   List of dict&#39;s with each dict containing details of a job
    Raises:
        SDKException:   if the response/fetch operation failed
    &#34;&#34;&#34;
    command = f&#34;qoperation execscript -sn QS_JobsinSPCopy -si @i_policyName=&#39;{self._storage_policy_name}&#39;&#34; \
              f&#34; -si @i_copyName=&#39;{self.copy_name}&#39;&#34;
    if from_date:
        command = f&#34;{command} -si @i_fromTime=&#39;{from_date}&#39;&#34;
    if to_date:
        command = f&#34;{command} -si @i_toTime=&#39;{to_date}&#39;&#34;
    if backup_type:
        command = f&#34;{command} -si @i_backupType=&#39;{backup_type.lower()}&#39;&#34;
    if retained_by:
        command = f&#34;{command} -si @i_retention=&#39;{retained_by}&#39;&#34;
    if include_to_be_copied_jobs:
        command = f&#34;{command} -si @i_includeToBeCopiedJobs=&#39;1&#39;&#34;
    if list_partial_jobs_only:
        command = f&#34;{command} -si @i_includePartialJobsOnly=&#39;1&#39;&#34;

    response = self._commcell_object.execute_qcommand(command)
    if response.json():
        json_response = response.json()
        if json_response.get(&#34;ExecScriptOutput&#34;):
            if isinstance(json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;), list):
                return json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;)
            if isinstance(json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;), dict):
                if json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;).get(&#34;@JobID&#34;):
                    return [json_response.get(&#34;ExecScriptOutput&#34;).get(&#34;FieldValue&#34;)]
            return []
        else:
            response_string = self._commcell_object._update_response_(response.text)
            raise SDKException(&#39;Response&#39;, &#39;102&#39;, response_string)
    else:
        response_string = self._commcell_object._update_response_(response.text)
        raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.get_store_seal_frequency"><code class="name flex">
<span>def <span class="ident">get_store_seal_frequency</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the store seal frequency for the copy</p>
<h2 id="returns">Returns</h2>
<dl>
<dt>dict &ndash; store seal frequency for the copy</dt>
<dt><code>
Eg</code></dt>
<dd>{'size': 0, 'days': 2, 'months': 0}</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4688-L4718" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_store_seal_frequency(self):
    &#34;&#34;&#34;Gets the store seal frequency for the copy

    Returns:
        dict -- store seal frequency for the copy
                Eg: {&#39;size&#39;: 0, &#39;days&#39;: 2, &#39;months&#39;: 0}
    &#34;&#34;&#34;
    request_json = {
        &#34;EVGui_StoragePolicySummaryReq&#34;: {
            &#34;spId&#34;: self.storage_policy_id,
            &#34;spCopyId&#34;: self.copy_id,
            &#34;reportType&#34;: 5 # storage policy copy&#39;s dedup information summary
        }
    }

    flag, response = self._commcell_object._cvpysdk_object.make_request(
        &#39;POST&#39;, self._commcell_object._services[&#39;EXECUTE_QCOMMAND&#39;], request_json
    )
    if flag:
        if response and response.json():
            dedup_summary = response.json()
            dedup_options = dedup_summary[&#39;options&#39;][&#39;dedupOptions&#39;]
            seal_frequency_dict = {
                &#39;size&#39;: dedup_options[&#39;storeCreationSize&#39;],
                &#39;days&#39;: dedup_options[&#39;storeCreationDays&#39;],
                &#39;months&#39;: dedup_options[&#39;storeCreationMonths&#39;]
            }
            return seal_frequency_dict
        raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    response_string = self._commcell_object._update_response_(response.text)
    raise SDKException(&#39;Response&#39;, &#39;101&#39;, response_string)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.is_dedupe_enabled"><code class="name flex">
<span>def <span class="ident">is_dedupe_enabled</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>checks whether deduplication is enabled on the give storage policy copy
returns Boolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3756-L3761" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_dedupe_enabled(self):
    &#34;&#34;&#34;
    checks whether deduplication is enabled on the give storage policy copy
    returns Boolean
    &#34;&#34;&#34;
    return bool(self._dedupe_flags.get(&#39;enableDeduplication&#39;, 0))</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.mark_jobs_bad"><code class="name flex">
<span>def <span class="ident">mark_jobs_bad</span></span>(<span>self, job_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks job(s) on a copy as Bad</p>
<h2 id="args">Args</h2>
<p>job_id
(int or str or list):
Job Id(s) that needs to be marked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4149-L4155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mark_jobs_bad(self, job_id):
    &#34;&#34;&#34;Marks job(s) on a copy as Bad

    Args:
        job_id      (int or str or list):   Job Id(s) that needs to be marked
    &#34;&#34;&#34;
    self._mark_jobs_on_copy(job_id, &#39;markJobsBad&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.pick_for_copy"><code class="name flex">
<span>def <span class="ident">pick_for_copy</span></span>(<span>self, job_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks job(s) to be Picked for Copy to a secondary copy</p>
<h2 id="args">Args</h2>
<p>job_id
(int or str or list): Job Id(s) that needs to be marked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4109-L4115" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pick_for_copy(self, job_id):
    &#34;&#34;&#34;Marks job(s) to be Picked for Copy to a secondary copy

    Args:
        job_id      (int or str or list): Job Id(s) that needs to be marked
    &#34;&#34;&#34;
    self._mark_jobs_on_copy(job_id, &#39;allowcopy&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.pick_jobs_for_backupcopy"><code class="name flex">
<span>def <span class="ident">pick_jobs_for_backupcopy</span></span>(<span>self, job_id)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used to re-pick the job from backup which are unpick manually</p>
<h2 id="args">Args</h2>
<p>job_id
(int or str or list):
Job Id(s) that needs to be marked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4157-L4163" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pick_jobs_for_backupcopy(self, job_id):
    &#34;&#34;&#34;This method is used to re-pick the job from backup which are unpick manually

    Args:
        job_id      (int or str or list):   Job Id(s) that needs to be marked
    &#34;&#34;&#34;
    self._mark_jobs_on_copy(job_id, &#39;pickforbackupcopy&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.pick_jobs_for_data_verification"><code class="name flex">
<span>def <span class="ident">pick_jobs_for_data_verification</span></span>(<span>self, job_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks job(s) on a copy to be Picked for Data Verification</p>
<h2 id="args">Args</h2>
<p>job_id
(int or str or list):
Job Id(s) that needs to be marked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4133-L4139" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pick_jobs_for_data_verification(self, job_id):
    &#34;&#34;&#34;Marks job(s) on a copy to be Picked for Data Verification

    Args:
        job_id      (int or str or list):   Job Id(s) that needs to be marked
    &#34;&#34;&#34;
    self._mark_jobs_on_copy(job_id, &#39;pickForVerification&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.recopy_jobs"><code class="name flex">
<span>def <span class="ident">recopy_jobs</span></span>(<span>self, job_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks job(s) to be picked for ReCopying to a secondary copy</p>
<h2 id="args">Args</h2>
<p>job_id
(int or str or list): Job Id(s) that needs to be marked</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4117-L4123" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def recopy_jobs(self, job_id):
    &#34;&#34;&#34;Marks job(s) to be picked for ReCopying to a secondary copy

    Args:
        job_id      (int or str or list): Job Id(s) that needs to be marked
    &#34;&#34;&#34;
    self._mark_jobs_on_copy(job_id, &#39;recopy&#39;)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh the properties of the StoragePolicy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3466-L3468" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;Refresh the properties of the StoragePolicy.&#34;&#34;&#34;
    self._get_copy_properties()</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.rotate_encryption_master_key"><code class="name flex">
<span>def <span class="ident">rotate_encryption_master_key</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates the encryption key for this copy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4624-L4631" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rotate_encryption_master_key(self):
    &#34;&#34;&#34;
    Rotates the encryption key for this copy
    &#34;&#34;&#34;
    self._copy_properties[&#34;dataEncryption&#34;] = {
        &#34;rotateMasterKey&#34;: True
    }
    self._set_copy_properties()</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_copy_software_compression"><code class="name flex">
<span>def <span class="ident">set_copy_software_compression</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the copy software compression setting as the value provided as input.</p>
<h2 id="args">Args</h2>
<p>value
(bool) &ndash;
software compression value to be set on a copy (True/False)</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if failed to update compression values on copy</p>
<pre><code>if the type of value input is not correct
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3632-L3652" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_copy_software_compression(self, value):
    &#34;&#34;&#34;Sets the copy software compression setting as the value provided as input.
        Args:
            value    (bool) --  software compression value to be set on a copy (True/False)

        Raises:
            SDKException:
                if failed to update compression values on copy

                if the type of value input is not correct

    &#34;&#34;&#34;
    if not isinstance(value, bool):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    if value is False:
        if &#39;compressionOnClients&#39; in self._extended_flags:
            self._extended_flags[&#39;compressionOnClients&#39;] = 0

    self._extended_flags[&#39;compressionOnClients&#39;] = int(value)
    self._set_copy_properties()</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_ddb_resiliency"><code class="name flex">
<span>def <span class="ident">set_ddb_resiliency</span></span>(<span>self, is_enabled, min_num_partitions)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets Resiliency On or Off, and set partition threshold for Resiliency</p>
<h2 id="args">Args</h2>
<p>is_enabled
(Boolean) &ndash; True or False to enable and disable resiliency respectively.
min_num_partitions (int) &ndash; Number of partitions required to be online for Resiliency to take affect.
Raises SDKException:
If input is not valid
If min_num_partitions &lt; 1
If API response is not successful</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4552-L4572" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_ddb_resiliency(self, is_enabled, min_num_partitions):
    &#34;&#34;&#34;Sets Resiliency On or Off, and set partition threshold for Resiliency
        Args:
            is_enabled  (Boolean) -- True or False to enable and disable resiliency respectively.
            min_num_partitions (int) -- Number of partitions required to be online for Resiliency to take affect.
        Raises SDKException:
            If input is not valid
            If min_num_partitions &lt; 1
            If API response is not successful
    &#34;&#34;&#34;
    if isinstance(is_enabled, bool) or isinstance(min_num_partitions, int):
        SDKException(&#39;Storage&#39;, &#39;101&#39;)
    if is_enabled:
        if min_num_partitions &lt; 1:
            SDKException(&#39;Storage&#39;, &#39;102&#39;, &#34;error min_num_partitions should be greater than or equal to 1&#34;)
        self._copy_properties[&#39;minimumNumberOfPartitionsForJobsToRun&#39;] = min_num_partitions
        self._dedupe_flags[&#39;allowJobsToRunWithoutAllPartitions&#39;] = 1
        self._set_copy_properties()
    else:
        self._dedupe_flags[&#39;allowJobsToRunWithoutAllPartitions&#39;] = 0
        self._set_copy_properties()</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_default_datapath"><code class="name flex">
<span>def <span class="ident">set_default_datapath</span></span>(<span>self, library_name, media_agent_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set default data path for that storage policy copy.</p>
<pre><code>Args:
    library_name    (str)   --   name of the library

    media_agent_name(str)   --   name of the media agent

Raises:
    SDKException:
        - If type of required input parameters is not string
        - If API response is not successful
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4633-L4681" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_default_datapath(self, library_name, media_agent_name):
    &#34;&#34;&#34;
    Set default data path for that storage policy copy.

        Args:
            library_name    (str)   --   name of the library

            media_agent_name(str)   --   name of the media agent

        Raises:
            SDKException:
                - If type of required input parameters is not string
                - If API response is not successful
    &#34;&#34;&#34;
    if not (isinstance(media_agent_name, str)) and isinstance(library_name):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    request_json = {
        &#34;storagePolicyCopyInfo&#34;: {
            &#34;dataPathProperties&#34;: [
                {
                    &#34;operationFlags&#34;: {
                        &#34;setDefault&#34;: True
                    },
                    &#34;mediaAgent&#34;: {
                        &#34;mediaAgentName&#34;: media_agent_name
                    },
                    &#34;library&#34;: {
                        &#34;libraryName&#34;: library_name
                    }
                }
            ]
        }
    }

    flag, response = self._cvpysdk_object.make_request(&#39;PUT&#39;, self._STORAGE_POLICY_COPY,
                                                       request_json)
    self.refresh()
    if flag:
        if response.json():
            response = response.json()
            if &#34;error&#34; in response and response.get(&#34;error&#34;, {}).get(&#34;errorCode&#34;) != 0:
                error_message = response.get(&#34;error&#34;, {}).get(&#34;errorMessage&#34;)
                raise SDKException(&#39;Response&#39;, &#39;101&#39;, error_message)
        else:
            raise SDKException(&#39;Response&#39;, &#39;102&#39;)
    else:
        error_message = response.json().get(&#34;errorMessage&#34;)
        raise SDKException(&#39;Response&#39;, &#39;111&#39;, error_message)</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_encryption_properties"><code class="name flex">
<span>def <span class="ident">set_encryption_properties</span></span>(<span>self, **props)</span>
</code></dt>
<dd>
<div class="desc"><p>sets copy encryption properties based on given inputs</p>
<h2 id="args">Args</h2>
<p>**props
dict of keyword arguments as follows:</p>
<pre><code>preserve            (Bool)      whether to set preserve source encryption or not    default:False

plain_text          (Bool)      whether to store as plaintext or not                default:False

network_encryption       (Bool)      whether to set network encryption or not       default:False

re_encryption          (Bool)      whether to set re-encryption or not              default:False

encryption_type            (str)       encryption type specification             default:"BlowFish"

encryption_length          (int)       encryption key length specification          default:128
</code></pre>
<h2 id="returns">Returns</h2>
<p>SDKException:
if failed to set copy encryption
if the type of inputs are not correct</p>
<hr>
<p>to preserve encryption &ndash;&gt; set_encryption_properties(preserve=True)</p>
<p>to store as plaintext &ndash;&gt; set_encryption_properties(plaintext=True)</p>
<p>to set network encryption &ndash;&gt; set_encryption_properties(plaintext=True, network_encryption=True,
encryption_type="BlowFish", encryption_length=128)</p>
<p>to set re-encryption &ndash;&gt; set_encryption_properties(re_encryption=True,
encryption_type="BlowFish", encryption_length=128)</p>
<hr>
<p><Encryption_type>
<Encryption_length></p>
<p>"Blowfish"
128
"Blowfish"
256
"TwoFish"
128
"TwoFish"
256
"Serpent"
128
"Serpent"
256
"GOST"
256
"AES"
128
"AES"
256
"DES3"
192</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L3800-L3894" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_encryption_properties(self, **props):
    &#34;&#34;&#34;sets copy encryption properties based on given inputs

        Args:

            **props         dict of keyword arguments as follows:

                preserve            (Bool)      whether to set preserve source encryption or not    default:False

                plain_text          (Bool)      whether to store as plaintext or not                default:False

                network_encryption       (Bool)      whether to set network encryption or not       default:False

                re_encryption          (Bool)      whether to set re-encryption or not              default:False

                encryption_type            (str)       encryption type specification             default:&#34;BlowFish&#34;

                encryption_length          (int)       encryption key length specification          default:128

        Returns:
              SDKException:
                        if failed to set copy encryption
                        if the type of inputs are not correct

        ***********************************************************************************************************

        to preserve encryption --&gt; set_encryption_properties(preserve=True)

        to store as plaintext --&gt; set_encryption_properties(plaintext=True)

        to set network encryption --&gt; set_encryption_properties(plaintext=True, network_encryption=True,
                                                                encryption_type=&#34;BlowFish&#34;, encryption_length=128)

        to set re-encryption --&gt; set_encryption_properties(re_encryption=True,
                                                           encryption_type=&#34;BlowFish&#34;, encryption_length=128)

        ***********************************************************************************************************

        &lt;Encryption_type&gt;   &lt;Encryption_length&gt;

        &#34;Blowfish&#34;                  128
        &#34;Blowfish&#34;                  256
        &#34;TwoFish&#34;                   128
        &#34;TwoFish&#34;                   256
        &#34;Serpent&#34;                   128
        &#34;Serpent&#34;                   256
        &#34;GOST&#34;                      256
        &#34;AES&#34;                       128
        &#34;AES&#34;                       256
        &#34;DES3&#34;                      192
    &#34;&#34;&#34;
    preserve = props.get(&#39;preserve&#39;, False)
    plain_text = props.get(&#39;plain_text&#39;, False)
    network_encryption = props.get(&#39;network_encryption&#39;, False)
    re_encryption = props.get(&#39;re_encryption&#39;, False)
    encryption_type = props.get(&#39;encryption_type&#39;, &#39;BlowFish&#39;)
    encryption_length = props.get(&#39;encryption_length&#39;, 128)

    if not isinstance(preserve, bool) or \
            not isinstance(plain_text, bool) or \
            not isinstance(network_encryption, bool) or \
            not isinstance(re_encryption, bool) or \
            not isinstance(encryption_type, str) or \
            not isinstance(encryption_length, int):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    self._copy_flags[&#39;preserveEncryptionModeAsInSource&#39;] = int(preserve)
    self._copy_flags[&#39;auxCopyReencryptData&#39;] = int(re_encryption)
    self._copy_flags[&#39;storePlainText&#39;] = int(plain_text)
    self._copy_flags[&#39;encryptOnNetworkUsingSelectedCipher&#39;] = int(network_encryption)

    self._copy_properties[&#39;extendedFlags&#39;][&#39;encryptOnDependentPrimary&#39;] = 0

    if plain_text and not network_encryption:

        self._copy_properties[&#39;dataEncryption&#39;] = {}

    else:

        if &#34;dataEncryption&#34; not in self._copy_properties:
            self._copy_properties[&#34;dataEncryption&#34;] = {
                &#34;encryptData&#34;: 0
            }
            self._data_encryption = self._copy_properties[&#34;dataEncryption&#34;]

    if re_encryption or network_encryption:

        self._data_encryption[&#39;encryptData&#39;] = 1
        self._data_encryption[&#39;encryptionType&#39;] = encryption_type
        self._data_encryption[&#39;encryptionKeyLength&#39;] = encryption_length

        if re_encryption:
            self._copy_properties[&#39;extendedFlags&#39;][&#39;encryptOnDependentPrimary&#39;] = 1

    self._set_copy_properties()</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_inline_copy"><code class="name flex">
<span>def <span class="ident">set_inline_copy</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the inline copy on storage policy copy as the value provided as input.</p>
<h2 id="args">Args</h2>
<p>value
(bool) &ndash;
inline copy on storage policy copy value to be set on a copy (True/False)</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if failed to update inline copy on storage policy copy</p>
<pre><code>if the type of value input is not correct
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4362-L4378" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_inline_copy(self, value):
    &#34;&#34;&#34; Sets the inline copy on storage policy copy as the value provided as input.
        Args:
            value    (bool) --  inline copy on storage policy copy value to be set on a copy (True/False)

        Raises:
            SDKException:
                if failed to update inline copy on storage policy copy

                if the type of value input is not correct
    &#34;&#34;&#34;
    if not isinstance(value, bool):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    self._copy_flags[&#39;inlineAuxCopy&#39;] = int(value)

    self._set_copy_properties()</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_key_management_server"><code class="name flex">
<span>def <span class="ident">set_key_management_server</span></span>(<span>self, kms_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the Key Management Server to this copy</p>
<h2 id="args">Args</h2>
<p>kms_name
(str) &ndash; The Key Management Server's name
Raises SDKException:
If input is not valid</p>
<pre><code>If API response is not successful
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4504-L4523" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_key_management_server(self, kms_name):
    &#34;&#34;&#34;Sets the Key Management Server to this copy

        Args:
            kms_name  (str) -- The Key Management Server&#39;s name

        Raises SDKException:
            If input is not valid

            If API response is not successful

    &#34;&#34;&#34;
    if not isinstance(kms_name, str):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    self._copy_properties[&#34;dataEncryption&#34;] = {
        &#34;keyProviderName&#34;: kms_name,
        &#34;rotateMasterKey&#34;: True
    }
    self._set_copy_properties()</code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_multiplexing_factor"><code class="name flex">
<span>def <span class="ident">set_multiplexing_factor</span></span>(<span>self, mux_factor)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets/Unset the multiplexing factor for the storage policy copy</p>
<h2 id="args">Args</h2>
<p>mux_factor
(int) &ndash; The value for multiplexing factor
Raises SDKException:
If input is not valid</p>
<pre><code>If API response is not successful
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4525-L4542" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_multiplexing_factor(self, mux_factor):
    &#34;&#34;&#34;Sets/Unset the multiplexing factor for the storage policy copy

        Args:
            mux_factor  (int) -- The value for multiplexing factor

        Raises SDKException:
            If input is not valid

            If API response is not successful
    &#34;&#34;&#34;
    if not isinstance(mux_factor, int):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    self._copy_properties[&#39;mediaProperties&#39;] = {
        &#34;multiplexingFactor&#34; : mux_factor
    }
    self._set_copy_properties()    </code></pre>
</details>
</dd>
<dt id="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_parallel_copy"><code class="name flex">
<span>def <span class="ident">set_parallel_copy</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the parallel copy on storage policy copy as the value provided as input.</p>
<h2 id="args">Args</h2>
<p>value
(bool) &ndash;
parallel copy on storage policy copy value to be set on a copy (True/False)</p>
<h2 id="raises">Raises</h2>
<p>SDKException:
if failed to update parallel copy on storage policy copy</p>
<pre><code>if the type of value input is not correct
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/Commvault/cvpysdk/blob/ea427ccfbe1b4a06c8c59fca8d0a81b0eca27e2d/cvpysdk/policies/storage_policies.py#L4315-L4331" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_parallel_copy(self, value):
    &#34;&#34;&#34; Sets the parallel copy on storage policy copy as the value provided as input.
        Args:
            value    (bool) --  parallel copy on storage policy copy value to be set on a copy (True/False)

        Raises:
            SDKException:
                if failed to update parallel copy on storage policy copy

                if the type of value input is not correct
    &#34;&#34;&#34;
    if not isinstance(value, bool):
        raise SDKException(&#39;Storage&#39;, &#39;101&#39;)

    self._copy_flags[&#39;enableParallelCopy&#39;] = int(value)

    self._set_copy_properties()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="GitHub home" href="https://github.com/Commvault/cvpysdk">
<img src="https://commvault.github.io/cvpysdk/logo.png" alt="" width="100%"> Commvault Python SDK
</a> <br>
<a class="homelink" title="Go to Top Level" href="https://commvault.github.io/cvpysdk/cvpysdk/index.html"> Go to Top Level </a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#attributes">Attributes</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cvpysdk.policies" href="index.html">cvpysdk.policies</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cvpysdk.policies.storage_policies.StoragePolicies" href="#cvpysdk.policies.storage_policies.StoragePolicies">StoragePolicies</a></code></h4>
<ul class="">
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicies.add" href="#cvpysdk.policies.storage_policies.StoragePolicies.add">add</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicies.add_global_storage_policy" href="#cvpysdk.policies.storage_policies.StoragePolicies.add_global_storage_policy">add_global_storage_policy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicies.add_tape_sp" href="#cvpysdk.policies.storage_policies.StoragePolicies.add_tape_sp">add_tape_sp</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicies.all_storage_policies" href="#cvpysdk.policies.storage_policies.StoragePolicies.all_storage_policies">all_storage_policies</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicies.delete" href="#cvpysdk.policies.storage_policies.StoragePolicies.delete">delete</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicies.get" href="#cvpysdk.policies.storage_policies.StoragePolicies.get">get</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicies.has_policy" href="#cvpysdk.policies.storage_policies.StoragePolicies.has_policy">has_policy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicies.refresh" href="#cvpysdk.policies.storage_policies.StoragePolicies.refresh">refresh</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cvpysdk.policies.storage_policies.StoragePolicy" href="#cvpysdk.policies.storage_policies.StoragePolicy">StoragePolicy</a></code></h4>
<ul class="">
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.add_ddb_partition" href="#cvpysdk.policies.storage_policies.StoragePolicy.add_ddb_partition">add_ddb_partition</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.aux_copies" href="#cvpysdk.policies.storage_policies.StoragePolicy.aux_copies">aux_copies</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.copies" href="#cvpysdk.policies.storage_policies.StoragePolicy.copies">copies</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.create_dedupe_secondary_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.create_dedupe_secondary_copy">create_dedupe_secondary_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.create_secondary_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.create_secondary_copy">create_secondary_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.create_selective_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.create_selective_copy">create_selective_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.create_snap_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.create_snap_copy">create_snap_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.delete_job" href="#cvpysdk.policies.storage_policies.StoragePolicy.delete_job">delete_job</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.delete_secondary_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.delete_secondary_copy">delete_secondary_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.description" href="#cvpysdk.policies.storage_policies.StoragePolicy.description">description</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.edit_block_size_on_gdsp" href="#cvpysdk.policies.storage_policies.StoragePolicy.edit_block_size_on_gdsp">edit_block_size_on_gdsp</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.enable_content_indexing" href="#cvpysdk.policies.storage_policies.StoragePolicy.enable_content_indexing">enable_content_indexing</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.enable_entity_extraction" href="#cvpysdk.policies.storage_policies.StoragePolicy.enable_entity_extraction">enable_entity_extraction</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.get_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.get_copy">get_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.get_copy_precedence" href="#cvpysdk.policies.storage_policies.StoragePolicy.get_copy_precedence">get_copy_precedence</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.get_primary_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.get_primary_copy">get_primary_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.get_secondary_copies" href="#cvpysdk.policies.storage_policies.StoragePolicy.get_secondary_copies">get_secondary_copies</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.has_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.has_copy">has_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.library_id" href="#cvpysdk.policies.storage_policies.StoragePolicy.library_id">library_id</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.library_name" href="#cvpysdk.policies.storage_policies.StoragePolicy.library_name">library_name</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.mark_for_recovery" href="#cvpysdk.policies.storage_policies.StoragePolicy.mark_for_recovery">mark_for_recovery</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.modify_dynamic_stream_allocation" href="#cvpysdk.policies.storage_policies.StoragePolicy.modify_dynamic_stream_allocation">modify_dynamic_stream_allocation</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.move_dedupe_store" href="#cvpysdk.policies.storage_policies.StoragePolicy.move_dedupe_store">move_dedupe_store</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.name" href="#cvpysdk.policies.storage_policies.StoragePolicy.name">name</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.reassociate_all_subclients" href="#cvpysdk.policies.storage_policies.StoragePolicy.reassociate_all_subclients">reassociate_all_subclients</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.refresh" href="#cvpysdk.policies.storage_policies.StoragePolicy.refresh">refresh</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.run_aux_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.run_aux_copy">run_aux_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.run_backup_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.run_backup_copy">run_backup_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.run_content_indexing" href="#cvpysdk.policies.storage_policies.StoragePolicy.run_content_indexing">run_content_indexing</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.run_data_forecast" href="#cvpysdk.policies.storage_policies.StoragePolicy.run_data_forecast">run_data_forecast</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.run_data_verification" href="#cvpysdk.policies.storage_policies.StoragePolicy.run_data_verification">run_data_verification</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.run_ddb_verification" href="#cvpysdk.policies.storage_policies.StoragePolicy.run_ddb_verification">run_ddb_verification</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.run_recon" href="#cvpysdk.policies.storage_policies.StoragePolicy.run_recon">run_recon</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.run_snapshot_cataloging" href="#cvpysdk.policies.storage_policies.StoragePolicy.run_snapshot_cataloging">run_snapshot_cataloging</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.seal_ddb" href="#cvpysdk.policies.storage_policies.StoragePolicy.seal_ddb">seal_ddb</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.snap_copy" href="#cvpysdk.policies.storage_policies.StoragePolicy.snap_copy">snap_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.start_over" href="#cvpysdk.policies.storage_policies.StoragePolicy.start_over">start_over</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_advanced_properties" href="#cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_advanced_properties">storage_policy_advanced_properties</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_id" href="#cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_id">storage_policy_id</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_name" href="#cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_name">storage_policy_name</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_properties" href="#cvpysdk.policies.storage_policies.StoragePolicy.storage_policy_properties">storage_policy_properties</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.update_snapshot_options" href="#cvpysdk.policies.storage_policies.StoragePolicy.update_snapshot_options">update_snapshot_options</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicy.update_transactional_ddb" href="#cvpysdk.policies.storage_policies.StoragePolicy.update_transactional_ddb">update_transactional_ddb</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy">StoragePolicyCopy</a></code></h4>
<ul class="">
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.add_svm_association" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.add_svm_association">add_svm_association</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.all_copies" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.all_copies">all_copies</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_client_side_dedup" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_client_side_dedup">copy_client_side_dedup</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_dedupe_dash_full" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_dedupe_dash_full">copy_dedupe_dash_full</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_dedupe_disk_cache" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_dedupe_disk_cache">copy_dedupe_disk_cache</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_name" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_name">copy_name</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_precedence" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_precedence">copy_precedence</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_reencryption" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_reencryption">copy_reencryption</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_retention" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_retention">copy_retention</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_retention_managed_disk_space" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_retention_managed_disk_space">copy_retention_managed_disk_space</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_software_compression" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.copy_software_compression">copy_software_compression</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.ddb_resiliency" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.ddb_resiliency">ddb_resiliency</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.delete_datapath" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.delete_datapath">delete_datapath</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.delete_job" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.delete_job">delete_job</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.disable_compliance_lock" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.disable_compliance_lock">disable_compliance_lock</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.do_not_copy_jobs" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.do_not_copy_jobs">do_not_copy_jobs</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.do_not_verify_data" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.do_not_verify_data">do_not_verify_data</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.enable_compliance_lock" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.enable_compliance_lock">enable_compliance_lock</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.extended_retention_rules" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.extended_retention_rules">extended_retention_rules</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.get_copy_Precedence" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.get_copy_Precedence">get_copy_Precedence</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.get_copy_id" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.get_copy_id">get_copy_id</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.get_jobs_on_copy" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.get_jobs_on_copy">get_jobs_on_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.get_store_seal_frequency" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.get_store_seal_frequency">get_store_seal_frequency</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.is_active" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.is_active">is_active</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.is_compliance_lock_enabled" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.is_compliance_lock_enabled">is_compliance_lock_enabled</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.is_dedupe_enabled" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.is_dedupe_enabled">is_dedupe_enabled</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.is_inline_copy" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.is_inline_copy">is_inline_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.is_parallel_copy" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.is_parallel_copy">is_parallel_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.mark_jobs_bad" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.mark_jobs_bad">mark_jobs_bad</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.media_agent" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.media_agent">media_agent</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.network_throttle_bandwidth" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.network_throttle_bandwidth">network_throttle_bandwidth</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.override_pool_retention" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.override_pool_retention">override_pool_retention</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.pick_for_copy" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.pick_for_copy">pick_for_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.pick_jobs_for_backupcopy" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.pick_jobs_for_backupcopy">pick_jobs_for_backupcopy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.pick_jobs_for_data_verification" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.pick_jobs_for_data_verification">pick_jobs_for_data_verification</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.recopy_jobs" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.recopy_jobs">recopy_jobs</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.refresh" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.refresh">refresh</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.rotate_encryption_master_key" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.rotate_encryption_master_key">rotate_encryption_master_key</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_copy_software_compression" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.set_copy_software_compression">set_copy_software_compression</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_ddb_resiliency" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.set_ddb_resiliency">set_ddb_resiliency</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_default_datapath" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.set_default_datapath">set_default_datapath</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_encryption_properties" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.set_encryption_properties">set_encryption_properties</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_inline_copy" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.set_inline_copy">set_inline_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_key_management_server" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.set_key_management_server">set_key_management_server</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_multiplexing_factor" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.set_multiplexing_factor">set_multiplexing_factor</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.set_parallel_copy" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.set_parallel_copy">set_parallel_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.source_copy" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.source_copy">source_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.space_optimized_auxillary_copy" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.space_optimized_auxillary_copy">space_optimized_auxillary_copy</a></code></li>
<li><code><a title="cvpysdk.policies.storage_policies.StoragePolicyCopy.store_priming" href="#cvpysdk.policies.storage_policies.StoragePolicyCopy.store_priming">store_priming</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>